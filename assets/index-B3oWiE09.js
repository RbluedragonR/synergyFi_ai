const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      "assets/secp256k1-D3JKpjK0.js",
      "assets/index-Djehc54V.js",
      "assets/index-D3NKRryd.css",
      "assets/embedded-wallet-Bw6GWc0g.js",
      "assets/if-defined-EXyKF6lo.js",
      "assets/index-BLMhEb6r.js",
      "assets/index-CDkY6vAj.js",
      "assets/ref-CVCDVHZs.js",
      "assets/index-DeVP0by4.js",
      "assets/index-yuaMqux5.js",
      "assets/index-BBH-gMlk.js",
      "assets/index-Djr8O8Yy.js",
      "assets/index-C1gdV2sx.js",
      "assets/index-B0JoxPNY.js",
      "assets/index-bRoVtHzS.js",
      "assets/email-ClmOx2jD.js",
      "assets/index-BmpLZ_Hs.js",
      "assets/socials-CJiCiaPs.js",
      "assets/index-ORudbjLl.js",
      "assets/ConstantsUtil-Dmg8YACJ.js",
      "assets/index-sOXPdumd.js",
      "assets/index-Csf-le2x.js",
      "assets/index-BocVcZob.js",
      "assets/browser-DL7x0OUv.js",
      "assets/index-DKcGFiCo.js",
      "assets/swaps-BVCMXjeT.js",
      "assets/index-CkRQ-kUE.js",
      "assets/index-BFrCxwdF.js",
      "assets/index-8hLfhLp3.js",
      "assets/send-BFRertPl.js",
      "assets/index-BYHiG5LX.js",
      "assets/index-8Cg8CdJw.js",
      "assets/receive-CXGPcPXa.js",
      "assets/index-CrIyHH0f.js",
      "assets/onramp-o2jWTin6.js",
      "assets/index-C3BaHExj.js",
      "assets/index-B-HOE4wV.js",
      "assets/index-eSOCm5IC.js",
      "assets/transactions-aaTVJ1mw.js",
      "assets/index-Ckx9Wzlf.js",
      "assets/index-DTp-ME2r.js",
      "assets/index-BclBWlv0.js",
      "assets/index-mokCsY3_.js",
      "assets/index-DzZ7pn50.js",
      "assets/w3m-modal-DeD7NBtf.js",
    ])
) => i.map((i) => d[i]);
import {
  c0 as qg,
  c1 as Hg,
  c2 as Wg,
  c3 as zg,
  c4 as Vg,
  c5 as Kg,
  c6 as Qr,
  c7 as ts,
  c8 as wd,
  c9 as Gg,
  ca as j,
  cb as en,
  cc as Yg,
  cd as Zg,
  ce as jc,
  cf as ei,
  cg as cr,
  ch as ti,
  ci as $l,
  cj as _t,
  ck as Jg,
  cl as Xg,
  cm as Yt,
  cn as Wn,
  co as si,
  cp as Dl,
  cq as cs,
  cr as Qg,
  cs as Ll,
  ct as Ml,
  cu as $a,
  cv as Bl,
  cw as yd,
  cx as em,
  cy as tm,
  cz as sm,
  cA as Ed,
  cB as Dr,
  cC as np,
  cD as Vs,
  cE as xs,
  cF as nn,
  cG as As,
  cH as $o,
  cI as bd,
} from "./index-Djehc54V.js";
function _d(s, e = {}) {
  const {
    key: t = "fallback",
    name: n = "Fallback",
    rank: r = !1,
    shouldThrow: i = nm,
    retryCount: o,
    retryDelay: a,
  } = e;
  return ({ chain: c, pollingInterval: l = 4e3, timeout: d, ...u }) => {
    let p = s,
      w = () => {};
    const g = qg(
      {
        key: t,
        name: n,
        async request({ method: m, params: f }) {
          let E;
          const b = async (_ = 0) => {
            const N = p[_]({ ...u, chain: c, retryCount: 0, timeout: d });
            try {
              const A = await N.request({ method: m, params: f });
              return (
                w({
                  method: m,
                  params: f,
                  response: A,
                  transport: N,
                  status: "success",
                }),
                A
              );
            } catch (A) {
              if (
                (w({
                  error: A,
                  method: m,
                  params: f,
                  transport: N,
                  status: "error",
                }),
                i(A) ||
                  _ === p.length - 1 ||
                  (E ??
                    (E = p.slice(_ + 1).some((L) => {
                      const { include: Q, exclude: K } =
                        L({ chain: c }).config.methods || {};
                      return Q ? Q.includes(m) : K ? !K.includes(m) : !0;
                    })),
                  !E))
              )
                throw A;
              return b(_ + 1);
            }
          };
          return b();
        },
        retryCount: o,
        retryDelay: a,
        type: "fallback",
      },
      {
        onResponse: (m) => (w = m),
        transports: p.map((m) => m({ chain: c, retryCount: 0 })),
      }
    );
    if (r) {
      const m = typeof r == "object" ? r : {};
      rm({
        chain: c,
        interval: m.interval ?? l,
        onTransports: (f) => (p = f),
        ping: m.ping,
        sampleCount: m.sampleCount,
        timeout: m.timeout,
        transports: p,
        weights: m.weights,
      });
    }
    return g;
  };
}
function nm(s) {
  return !!(
    "code" in s &&
    typeof s.code == "number" &&
    (s.code === Hg.code ||
      s.code === Wg.code ||
      zg.nodeMessage.test(s.message) ||
      s.code === 5e3)
  );
}
function rm({
  chain: s,
  interval: e = 4e3,
  onTransports: t,
  ping: n,
  sampleCount: r = 10,
  timeout: i = 1e3,
  transports: o,
  weights: a = {},
}) {
  const { stability: c = 0.7, latency: l = 0.3 } = a,
    d = [],
    u = async () => {
      const p = await Promise.all(
        o.map(async (m) => {
          const f = m({ chain: s, retryCount: 0, timeout: i }),
            E = Date.now();
          let b, _;
          try {
            await (n
              ? n({ transport: f })
              : f.request({ method: "net_listening" })),
              (_ = 1);
          } catch {
            _ = 0;
          } finally {
            b = Date.now();
          }
          return { latency: b - E, success: _ };
        })
      );
      d.push(p), d.length > r && d.shift();
      const w = Math.max(
          ...d.map((m) => Math.max(...m.map(({ latency: f }) => f)))
        ),
        g = o
          .map((m, f) => {
            const E = d.map((L) => L[f].latency),
              _ = 1 - E.reduce((L, Q) => L + Q, 0) / E.length / w,
              N = d.map((L) => L[f].success),
              A = N.reduce((L, Q) => L + Q, 0) / N.length;
            return A === 0 ? [0, f] : [l * _ + c * A, f];
          })
          .sort((m, f) => f[0] - m[0]);
      t(g.map(([, m]) => o[m])), await Vg(e), u();
    };
  u();
}
const im = Symbol(),
  Cd = Object.getPrototypeOf,
  qc = new WeakMap(),
  om = (s) =>
    s &&
    (qc.has(s)
      ? qc.get(s)
      : Cd(s) === Object.prototype || Cd(s) === Array.prototype),
  am = (s) => (om(s) && s[im]) || null,
  vd = (s, e = !0) => {
    qc.set(s, e);
  },
  la = {},
  Fl = (s) => typeof s == "object" && s !== null,
  cm = (s) =>
    Fl(s) &&
    !Ao.has(s) &&
    (Array.isArray(s) || !(Symbol.iterator in s)) &&
    !(s instanceof WeakMap) &&
    !(s instanceof WeakSet) &&
    !(s instanceof Error) &&
    !(s instanceof Number) &&
    !(s instanceof Date) &&
    !(s instanceof String) &&
    !(s instanceof RegExp) &&
    !(s instanceof ArrayBuffer) &&
    !(s instanceof Promise),
  rp = (s, e) => {
    const t = Hc.get(s);
    if ((t == null ? void 0 : t[0]) === e) return t[1];
    const n = Array.isArray(s) ? [] : Object.create(Object.getPrototypeOf(s));
    return (
      vd(n, !0),
      Hc.set(s, [e, n]),
      Reflect.ownKeys(s).forEach((r) => {
        if (Object.getOwnPropertyDescriptor(n, r)) return;
        const i = Reflect.get(s, r),
          { enumerable: o } = Reflect.getOwnPropertyDescriptor(s, r),
          a = { value: i, enumerable: o, configurable: !0 };
        if (Ao.has(i)) vd(i, !1);
        else if (Tn.has(i)) {
          const [c, l] = Tn.get(i);
          a.value = rp(c, l());
        }
        Object.defineProperty(n, r, a);
      }),
      Object.preventExtensions(n)
    );
  },
  lm = (s, e, t, n) => ({
    deleteProperty(r, i) {
      const o = Reflect.get(r, i);
      t(i);
      const a = Reflect.deleteProperty(r, i);
      return a && n(["delete", [i], o]), a;
    },
    set(r, i, o, a) {
      const c = !s() && Reflect.has(r, i),
        l = Reflect.get(r, i, a);
      if (c && (Ad(l, o) || (Ji.has(o) && Ad(l, Ji.get(o))))) return !0;
      t(i), Fl(o) && (o = am(o) || o);
      const d = !Tn.has(o) && um(o) ? qe(o) : o;
      return e(i, d), Reflect.set(r, i, d, a), n(["set", [i], o, l]), !0;
    },
  }),
  Tn = new WeakMap(),
  Ao = new WeakSet(),
  Hc = new WeakMap(),
  Ti = [1, 1],
  Ji = new WeakMap();
let Ad = Object.is,
  dm = (s, e) => new Proxy(s, e),
  um = cm,
  hm = rp,
  pm = lm;
function qe(s = {}) {
  if (!Fl(s)) throw new Error("object required");
  const e = Ji.get(s);
  if (e) return e;
  let t = Ti[0];
  const n = new Set(),
    r = (f, E = ++Ti[0]) => {
      t !== E && ((t = E), n.forEach((b) => b(f, E)));
    };
  let i = Ti[1];
  const o = (f = ++Ti[1]) => (
      i !== f &&
        !n.size &&
        ((i = f),
        c.forEach(([E]) => {
          const b = E[1](f);
          b > t && (t = b);
        })),
      t
    ),
    a = (f) => (E, b) => {
      const _ = [...E];
      (_[1] = [f, ..._[1]]), r(_, b);
    },
    c = new Map(),
    l = (f, E) => {
      const b = !Ao.has(E) && Tn.get(E);
      if (b) {
        if ((la ? "production" : void 0) !== "production" && c.has(f))
          throw new Error("prop listener already exists");
        if (n.size) {
          const _ = b[2](a(f));
          c.set(f, [b, _]);
        } else c.set(f, [b]);
      }
    },
    d = (f) => {
      var E;
      const b = c.get(f);
      b && (c.delete(f), (E = b[1]) == null || E.call(b));
    },
    u = (f) => (
      n.add(f),
      n.size === 1 &&
        c.forEach(([b, _], N) => {
          if ((la ? "production" : void 0) !== "production" && _)
            throw new Error("remove already exists");
          const A = b[2](a(N));
          c.set(N, [b, A]);
        }),
      () => {
        n.delete(f),
          n.size === 0 &&
            c.forEach(([b, _], N) => {
              _ && (_(), c.set(N, [b]));
            });
      }
    );
  let p = !0;
  const w = pm(() => p, l, d, r),
    g = dm(s, w);
  Ji.set(s, g);
  const m = [s, o, u];
  return (
    Tn.set(g, m),
    Reflect.ownKeys(s).forEach((f) => {
      const E = Object.getOwnPropertyDescriptor(s, f);
      "value" in E && E.writable && (g[f] = s[f]);
    }),
    (p = !1),
    g
  );
}
function ft(s, e, t) {
  const n = Tn.get(s);
  (la ? "production" : void 0) !== "production" &&
    !n &&
    console.warn("Please use proxy object");
  let r;
  const i = [],
    o = n[2];
  let a = !1;
  const l = o((d) => {
    i.push(d),
      r ||
        (r = Promise.resolve().then(() => {
          (r = void 0), a && e(i.splice(0));
        }));
  });
  return (
    (a = !0),
    () => {
      (a = !1), l();
    }
  );
}
function Xi(s) {
  const e = Tn.get(s);
  (la ? "production" : void 0) !== "production" &&
    !e &&
    console.warn("Please use proxy object");
  const [t, n] = e;
  return hm(t, n());
}
function Qn(s) {
  return Ao.add(s), s;
}
function fm() {
  return {
    proxyStateMap: Tn,
    refSet: Ao,
    snapCache: Hc,
    versionHolder: Ti,
    proxyCache: Ji,
  };
}
function Ct(s, e, t, n) {
  let r = s[e];
  return ft(s, () => {
    const i = s[e];
    Object.is(r, i) || t((r = i));
  });
}
const { proxyStateMap: gm, snapCache: mm } = fm(),
  Do = (s) => gm.has(s);
function wm(s) {
  const e = [];
  let t = 0;
  const n = new Map(),
    r = new WeakMap(),
    i = () => {
      const l = mm.get(a),
        d = l == null ? void 0 : l[1];
      if (d && !r.has(d)) {
        const u = new Map(n);
        r.set(d, u);
      }
    },
    o = (l) => r.get(l) || n,
    a = {
      data: e,
      index: t,
      epoch: 0,
      get size() {
        return Do(this) || i(), o(this).size;
      },
      get(l) {
        const u = o(this).get(l);
        if (u === void 0) {
          this.epoch;
          return;
        }
        return this.data[u];
      },
      has(l) {
        const d = o(this);
        return this.epoch, d.has(l);
      },
      set(l, d) {
        if (!Do(this))
          throw new Error("Cannot perform mutations on a snapshot");
        const u = n.get(l);
        return (
          u === void 0
            ? (n.set(l, this.index), (this.data[this.index++] = d))
            : (this.data[u] = d),
          this.epoch++,
          this
        );
      },
      delete(l) {
        if (!Do(this))
          throw new Error("Cannot perform mutations on a snapshot");
        const d = n.get(l);
        return d === void 0
          ? !1
          : (delete this.data[d], n.delete(l), this.epoch++, !0);
      },
      clear() {
        if (!Do(this))
          throw new Error("Cannot perform mutations on a snapshot");
        (this.data.length = 0), (this.index = 0), this.epoch++, n.clear();
      },
      forEach(l) {
        this.epoch,
          o(this).forEach((u, p) => {
            l(this.data[u], p, this);
          });
      },
      *entries() {
        this.epoch;
        const l = o(this);
        for (const [d, u] of l) yield [d, this.data[u]];
      },
      *keys() {
        this.epoch;
        const l = o(this);
        for (const d of l.keys()) yield d;
      },
      *values() {
        this.epoch;
        const l = o(this);
        for (const d of l.values()) yield this.data[d];
      },
      [Symbol.iterator]() {
        return this.entries();
      },
      get [Symbol.toStringTag]() {
        return "Map";
      },
      toJSON() {
        return new Map(this.entries());
      },
    },
    c = qe(a);
  return (
    Object.defineProperties(c, {
      size: { enumerable: !1 },
      index: { enumerable: !1 },
      epoch: { enumerable: !1 },
      data: { enumerable: !1 },
      toJSON: { enumerable: !1 },
    }),
    Object.seal(c),
    c
  );
}
var Id = {};
const S = {
    WC_NAME_SUFFIX: ".reown.id",
    BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
    PULSE_API_URL: "https://pulse.walletconnect.org",
    W3M_API_URL: "https://api.web3modal.org",
    CONNECTOR_ID: {
      WALLET_CONNECT: "walletConnect",
      INJECTED: "injected",
      COINBASE: "coinbaseWallet",
      COINBASE_SDK: "coinbaseWalletSDK",
      SAFE: "safe",
      LEDGER: "ledger",
      AUTH: "ID_AUTH",
    },
    CONNECTOR_NAMES: { AUTH: "Auth" },
    AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
    CHAIN: { EVM: "eip155", SOLANA: "solana", BITCOIN: "bip122" },
    CHAIN_NAME_MAP: {
      eip155: "EVM Networks",
      solana: "Solana",
      polkadot: "Polkadot",
      bip122: "Bitcoin",
      cosmos: "Cosmos",
    },
    USDT_CONTRACT_ADDRESSES: [
      "0xdac17f958d2ee523a2206206994597c13d831ec7",
      "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
      "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
      "0x919C1c267BC06a7039e03fcc2eF738525769109c",
      "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
      "0x55d398326f99059fF775485246999027B3197955",
      "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
    ],
    HTTP_STATUS_CODES: {
      SERVER_ERROR: 500,
      TOO_MANY_REQUESTS: 429,
      SERVICE_UNAVAILABLE: 503,
      FORBIDDEN: 403,
    },
    UNSUPPORTED_NETWORK_NAME: "Unknown Network",
    SECURE_SITE_SDK_ORIGIN:
      (typeof process < "u" && typeof Id < "u"
        ? Id.NEXT_PUBLIC_SECURE_SITE_ORIGIN
        : void 0) || "https://secure.walletconnect.org",
    REMOTE_FEATURES_ALERTS: {
      MULTI_WALLET_NOT_ENABLED: {
        DEFAULT: {
          shortMessage: "Multi-Wallet Not Enabled",
          longMessage:
            "Multi-wallet support is not enabled. Please enable it in your AppKit configuration at cloud.reown.com.",
        },
      },
    },
  },
  ip = {
    caipNetworkIdToNumber(s) {
      return s ? Number(s.split(":")[1]) : void 0;
    },
    parseEvmChainId(s) {
      return typeof s == "string" ? this.caipNetworkIdToNumber(s) : s;
    },
    getNetworksByNamespace(s, e) {
      return (
        (s == null ? void 0 : s.filter((t) => t.chainNamespace === e)) || []
      );
    },
    getFirstNetworkByNamespace(s, e) {
      return this.getNetworksByNamespace(s, e)[0];
    },
    getNetworkNameByCaipNetworkId(s, e) {
      var r;
      if (!e) return;
      const t = s.find((i) => i.caipNetworkId === e);
      if (t) return t.name;
      const [n] = e.split(":");
      return ((r = S.CHAIN_NAME_MAP) == null ? void 0 : r[n]) || void 0;
    },
  };
var ym = 20,
  Em = 1,
  ni = 1e6,
  bm = 1e6,
  _m = -7,
  Cm = 21,
  vm = !1,
  Io = "[big.js] ",
  lr = Io + "Invalid ",
  Da = lr + "decimal places",
  Am = lr + "rounding mode",
  op = Io + "Division by zero",
  $e = {},
  Us = void 0,
  Im = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function ap() {
  function s(e) {
    var t = this;
    if (!(t instanceof s)) return e === Us ? ap() : new s(e);
    if (e instanceof s) (t.s = e.s), (t.e = e.e), (t.c = e.c.slice());
    else {
      if (typeof e != "string") {
        if (s.strict === !0 && typeof e != "bigint")
          throw TypeError(lr + "value");
        e = e === 0 && 1 / e < 0 ? "-0" : String(e);
      }
      Sm(t, e);
    }
    t.constructor = s;
  }
  return (
    (s.prototype = $e),
    (s.DP = ym),
    (s.RM = Em),
    (s.NE = _m),
    (s.PE = Cm),
    (s.strict = vm),
    (s.roundDown = 0),
    (s.roundHalfUp = 1),
    (s.roundHalfEven = 2),
    (s.roundUp = 3),
    s
  );
}
function Sm(s, e) {
  var t, n, r;
  if (!Im.test(e)) throw Error(lr + "number");
  for (
    s.s = e.charAt(0) == "-" ? ((e = e.slice(1)), -1) : 1,
      (t = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
      (n = e.search(/e/i)) > 0
        ? (t < 0 && (t = n), (t += +e.slice(n + 1)), (e = e.substring(0, n)))
        : t < 0 && (t = e.length),
      r = e.length,
      n = 0;
    n < r && e.charAt(n) == "0";

  )
    ++n;
  if (n == r) s.c = [(s.e = 0)];
  else {
    for (; r > 0 && e.charAt(--r) == "0"; );
    for (s.e = t - n - 1, s.c = [], t = 0; n <= r; ) s.c[t++] = +e.charAt(n++);
  }
  return s;
}
function dr(s, e, t, n) {
  var r = s.c;
  if (
    (t === Us && (t = s.constructor.RM),
    t !== 0 && t !== 1 && t !== 2 && t !== 3)
  )
    throw Error(Am);
  if (e < 1)
    (n =
      (t === 3 && (n || !!r[0])) ||
      (e === 0 &&
        ((t === 1 && r[0] >= 5) ||
          (t === 2 && (r[0] > 5 || (r[0] === 5 && (n || r[1] !== Us))))))),
      (r.length = 1),
      n ? ((s.e = s.e - e + 1), (r[0] = 1)) : (r[0] = s.e = 0);
  else if (e < r.length) {
    if (
      ((n =
        (t === 1 && r[e] >= 5) ||
        (t === 2 &&
          (r[e] > 5 ||
            (r[e] === 5 && (n || r[e + 1] !== Us || r[e - 1] & 1)))) ||
        (t === 3 && (n || !!r[0]))),
      (r.length = e),
      n)
    ) {
      for (; ++r[--e] > 9; )
        if (((r[e] = 0), e === 0)) {
          ++s.e, r.unshift(1);
          break;
        }
    }
    for (e = r.length; !r[--e]; ) r.pop();
  }
  return s;
}
function ur(s, e, t) {
  var n = s.e,
    r = s.c.join(""),
    i = r.length;
  if (e)
    r =
      r.charAt(0) + (i > 1 ? "." + r.slice(1) : "") + (n < 0 ? "e" : "e+") + n;
  else if (n < 0) {
    for (; ++n; ) r = "0" + r;
    r = "0." + r;
  } else if (n > 0)
    if (++n > i) for (n -= i; n--; ) r += "0";
    else n < i && (r = r.slice(0, n) + "." + r.slice(n));
  else i > 1 && (r = r.charAt(0) + "." + r.slice(1));
  return s.s < 0 && t ? "-" + r : r;
}
$e.abs = function () {
  var s = new this.constructor(this);
  return (s.s = 1), s;
};
$e.cmp = function (s) {
  var e,
    t = this,
    n = t.c,
    r = (s = new t.constructor(s)).c,
    i = t.s,
    o = s.s,
    a = t.e,
    c = s.e;
  if (!n[0] || !r[0]) return n[0] ? i : r[0] ? -o : 0;
  if (i != o) return i;
  if (((e = i < 0), a != c)) return (a > c) ^ e ? 1 : -1;
  for (o = (a = n.length) < (c = r.length) ? a : c, i = -1; ++i < o; )
    if (n[i] != r[i]) return (n[i] > r[i]) ^ e ? 1 : -1;
  return a == c ? 0 : (a > c) ^ e ? 1 : -1;
};
$e.div = function (s) {
  var e = this,
    t = e.constructor,
    n = e.c,
    r = (s = new t(s)).c,
    i = e.s == s.s ? 1 : -1,
    o = t.DP;
  if (o !== ~~o || o < 0 || o > ni) throw Error(Da);
  if (!r[0]) throw Error(op);
  if (!n[0]) return (s.s = i), (s.c = [(s.e = 0)]), s;
  var a,
    c,
    l,
    d,
    u,
    p = r.slice(),
    w = (a = r.length),
    g = n.length,
    m = n.slice(0, a),
    f = m.length,
    E = s,
    b = (E.c = []),
    _ = 0,
    N = o + (E.e = e.e - s.e) + 1;
  for (E.s = i, i = N < 0 ? 0 : N, p.unshift(0); f++ < a; ) m.push(0);
  do {
    for (l = 0; l < 10; l++) {
      if (a != (f = m.length)) d = a > f ? 1 : -1;
      else
        for (u = -1, d = 0; ++u < a; )
          if (r[u] != m[u]) {
            d = r[u] > m[u] ? 1 : -1;
            break;
          }
      if (d < 0) {
        for (c = f == a ? r : p; f; ) {
          if (m[--f] < c[f]) {
            for (u = f; u && !m[--u]; ) m[u] = 9;
            --m[u], (m[f] += 10);
          }
          m[f] -= c[f];
        }
        for (; !m[0]; ) m.shift();
      } else break;
    }
    (b[_++] = d ? l : ++l), m[0] && d ? (m[f] = n[w] || 0) : (m = [n[w]]);
  } while ((w++ < g || m[0] !== Us) && i--);
  return (
    !b[0] && _ != 1 && (b.shift(), E.e--, N--),
    _ > N && dr(E, N, t.RM, m[0] !== Us),
    E
  );
};
$e.eq = function (s) {
  return this.cmp(s) === 0;
};
$e.gt = function (s) {
  return this.cmp(s) > 0;
};
$e.gte = function (s) {
  return this.cmp(s) > -1;
};
$e.lt = function (s) {
  return this.cmp(s) < 0;
};
$e.lte = function (s) {
  return this.cmp(s) < 1;
};
$e.minus = $e.sub = function (s) {
  var e,
    t,
    n,
    r,
    i = this,
    o = i.constructor,
    a = i.s,
    c = (s = new o(s)).s;
  if (a != c) return (s.s = -c), i.plus(s);
  var l = i.c.slice(),
    d = i.e,
    u = s.c,
    p = s.e;
  if (!l[0] || !u[0])
    return u[0] ? (s.s = -c) : l[0] ? (s = new o(i)) : (s.s = 1), s;
  if ((a = d - p)) {
    for (
      (r = a < 0) ? ((a = -a), (n = l)) : ((p = d), (n = u)),
        n.reverse(),
        c = a;
      c--;

    )
      n.push(0);
    n.reverse();
  } else
    for (t = ((r = l.length < u.length) ? l : u).length, a = c = 0; c < t; c++)
      if (l[c] != u[c]) {
        r = l[c] < u[c];
        break;
      }
  if (
    (r && ((n = l), (l = u), (u = n), (s.s = -s.s)),
    (c = (t = u.length) - (e = l.length)) > 0)
  )
    for (; c--; ) l[e++] = 0;
  for (c = e; t > a; ) {
    if (l[--t] < u[t]) {
      for (e = t; e && !l[--e]; ) l[e] = 9;
      --l[e], (l[t] += 10);
    }
    l[t] -= u[t];
  }
  for (; l[--c] === 0; ) l.pop();
  for (; l[0] === 0; ) l.shift(), --p;
  return l[0] || ((s.s = 1), (l = [(p = 0)])), (s.c = l), (s.e = p), s;
};
$e.mod = function (s) {
  var e,
    t = this,
    n = t.constructor,
    r = t.s,
    i = (s = new n(s)).s;
  if (!s.c[0]) throw Error(op);
  return (
    (t.s = s.s = 1),
    (e = s.cmp(t) == 1),
    (t.s = r),
    (s.s = i),
    e
      ? new n(t)
      : ((r = n.DP),
        (i = n.RM),
        (n.DP = n.RM = 0),
        (t = t.div(s)),
        (n.DP = r),
        (n.RM = i),
        this.minus(t.times(s)))
  );
};
$e.neg = function () {
  var s = new this.constructor(this);
  return (s.s = -s.s), s;
};
$e.plus = $e.add = function (s) {
  var e,
    t,
    n,
    r = this,
    i = r.constructor;
  if (((s = new i(s)), r.s != s.s)) return (s.s = -s.s), r.minus(s);
  var o = r.e,
    a = r.c,
    c = s.e,
    l = s.c;
  if (!a[0] || !l[0]) return l[0] || (a[0] ? (s = new i(r)) : (s.s = r.s)), s;
  if (((a = a.slice()), (e = o - c))) {
    for (e > 0 ? ((c = o), (n = l)) : ((e = -e), (n = a)), n.reverse(); e--; )
      n.push(0);
    n.reverse();
  }
  for (
    a.length - l.length < 0 && ((n = l), (l = a), (a = n)), e = l.length, t = 0;
    e;
    a[e] %= 10
  )
    t = ((a[--e] = a[e] + l[e] + t) / 10) | 0;
  for (t && (a.unshift(t), ++c), e = a.length; a[--e] === 0; ) a.pop();
  return (s.c = a), (s.e = c), s;
};
$e.pow = function (s) {
  var e = this,
    t = new e.constructor("1"),
    n = t,
    r = s < 0;
  if (s !== ~~s || s < -1e6 || s > bm) throw Error(lr + "exponent");
  for (r && (s = -s); s & 1 && (n = n.times(e)), (s >>= 1), !!s; )
    e = e.times(e);
  return r ? t.div(n) : n;
};
$e.prec = function (s, e) {
  if (s !== ~~s || s < 1 || s > ni) throw Error(lr + "precision");
  return dr(new this.constructor(this), s, e);
};
$e.round = function (s, e) {
  if (s === Us) s = 0;
  else if (s !== ~~s || s < -1e6 || s > ni) throw Error(Da);
  return dr(new this.constructor(this), s + this.e + 1, e);
};
$e.sqrt = function () {
  var s,
    e,
    t,
    n = this,
    r = n.constructor,
    i = n.s,
    o = n.e,
    a = new r("0.5");
  if (!n.c[0]) return new r(n);
  if (i < 0) throw Error(Io + "No square root");
  (i = Math.sqrt(+ur(n, !0, !0))),
    i === 0 || i === 1 / 0
      ? ((e = n.c.join("")),
        (e.length + o) & 1 || (e += "0"),
        (i = Math.sqrt(e)),
        (o = (((o + 1) / 2) | 0) - (o < 0 || o & 1)),
        (s = new r(
          (i == 1 / 0
            ? "5e"
            : (i = i.toExponential()).slice(0, i.indexOf("e") + 1)) + o
        )))
      : (s = new r(i + "")),
    (o = s.e + (r.DP += 4));
  do (t = s), (s = a.times(t.plus(n.div(t))));
  while (t.c.slice(0, o).join("") !== s.c.slice(0, o).join(""));
  return dr(s, (r.DP -= 4) + s.e + 1, r.RM);
};
$e.times = $e.mul = function (s) {
  var e,
    t = this,
    n = t.constructor,
    r = t.c,
    i = (s = new n(s)).c,
    o = r.length,
    a = i.length,
    c = t.e,
    l = s.e;
  if (((s.s = t.s == s.s ? 1 : -1), !r[0] || !i[0]))
    return (s.c = [(s.e = 0)]), s;
  for (
    s.e = c + l,
      o < a && ((e = r), (r = i), (i = e), (l = o), (o = a), (a = l)),
      e = new Array((l = o + a));
    l--;

  )
    e[l] = 0;
  for (c = a; c--; ) {
    for (a = 0, l = o + c; l > c; )
      (a = e[l] + i[c] * r[l - c - 1] + a),
        (e[l--] = a % 10),
        (a = (a / 10) | 0);
    e[l] = a;
  }
  for (a ? ++s.e : e.shift(), c = e.length; !e[--c]; ) e.pop();
  return (s.c = e), s;
};
$e.toExponential = function (s, e) {
  var t = this,
    n = t.c[0];
  if (s !== Us) {
    if (s !== ~~s || s < 0 || s > ni) throw Error(Da);
    for (t = dr(new t.constructor(t), ++s, e); t.c.length < s; ) t.c.push(0);
  }
  return ur(t, !0, !!n);
};
$e.toFixed = function (s, e) {
  var t = this,
    n = t.c[0];
  if (s !== Us) {
    if (s !== ~~s || s < 0 || s > ni) throw Error(Da);
    for (
      t = dr(new t.constructor(t), s + t.e + 1, e), s = s + t.e + 1;
      t.c.length < s;

    )
      t.c.push(0);
  }
  return ur(t, !1, !!n);
};
$e[Symbol.for("nodejs.util.inspect.custom")] =
  $e.toJSON =
  $e.toString =
    function () {
      var s = this,
        e = s.constructor;
      return ur(s, s.e <= e.NE || s.e >= e.PE, !!s.c[0]);
    };
$e.toNumber = function () {
  var s = +ur(this, !0, !0);
  if (this.constructor.strict === !0 && !this.eq(s.toString()))
    throw Error(Io + "Imprecise conversion");
  return s;
};
$e.toPrecision = function (s, e) {
  var t = this,
    n = t.constructor,
    r = t.c[0];
  if (s !== Us) {
    if (s !== ~~s || s < 1 || s > ni) throw Error(lr + "precision");
    for (t = dr(new n(t), s, e); t.c.length < s; ) t.c.push(0);
  }
  return ur(t, s <= t.e || t.e <= n.NE || t.e >= n.PE, !!r);
};
$e.valueOf = function () {
  var s = this,
    e = s.constructor;
  if (e.strict === !0) throw Error(Io + "valueOf disallowed");
  return ur(s, s.e <= e.NE || s.e >= e.PE, !0);
};
var di = ap();
const Nm = {
    bigNumber(s) {
      return s ? new di(s) : new di(0);
    },
    multiply(s, e) {
      if (s === void 0 || e === void 0) return new di(0);
      const t = new di(s),
        n = new di(e);
      return t.times(n);
    },
    formatNumberToLocalString(s, e = 2) {
      return s === void 0
        ? "0.00"
        : typeof s == "number"
        ? s.toLocaleString("en-US", {
            maximumFractionDigits: e,
            minimumFractionDigits: e,
          })
        : parseFloat(s).toLocaleString("en-US", {
            maximumFractionDigits: e,
            minimumFractionDigits: e,
          });
    },
    parseLocalStringToNumber(s) {
      return s === void 0 ? 0 : parseFloat(s.replace(/,/gu, ""));
    },
  },
  Tm = [
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        { name: "_from", type: "address" },
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
  ],
  Rm = [
    {
      type: "function",
      name: "approve",
      stateMutability: "nonpayable",
      inputs: [
        { name: "spender", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ type: "bool" }],
    },
  ],
  xm = [
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        { name: "recipient", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [],
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        { name: "sender", type: "address" },
        { name: "recipient", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
  ],
  Pm = {
    getERC20Abi: (s) => (S.USDT_CONTRACT_ADDRESSES.includes(s) ? xm : Tm),
    getSwapAbi: () => Rm,
  },
  Mt = {
    validateCaipAddress(s) {
      var e;
      if (((e = s.split(":")) == null ? void 0 : e.length) !== 3)
        throw new Error("Invalid CAIP Address");
      return s;
    },
    parseCaipAddress(s) {
      const e = s.split(":");
      if (e.length !== 3) throw new Error(`Invalid CAIP-10 address: ${s}`);
      const [t, n, r] = e;
      if (!t || !n || !r) throw new Error(`Invalid CAIP-10 address: ${s}`);
      return { chainNamespace: t, chainId: n, address: r };
    },
    parseCaipNetworkId(s) {
      const e = s.split(":");
      if (e.length !== 2) throw new Error(`Invalid CAIP-2 network id: ${s}`);
      const [t, n] = e;
      if (!t || !n) throw new Error(`Invalid CAIP-2 network id: ${s}`);
      return { chainNamespace: t, chainId: n };
    },
  },
  he = {
    ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
    CONNECTED_SOCIAL: "@appkit/connected_social",
    CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
    RECENT_WALLETS: "@appkit/recent_wallets",
    DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
    ACTIVE_NAMESPACE: "@appkit/active_namespace",
    CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
    CONNECTION_STATUS: "@appkit/connection_status",
    TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
    NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
    PORTFOLIO_CACHE: "@appkit/portfolio_cache",
    ENS_CACHE: "@appkit/ens_cache",
    IDENTITY_CACHE: "@appkit/identity_cache",
    PREFERRED_ACCOUNT_TYPES: "@appkit/preferred_account_types",
    CONNECTIONS: "@appkit/connections",
    DISCONNECTED_CONNECTOR_IDS: "@appkit/disconnected_connector_ids",
  };
function Xa(s) {
  if (!s) throw new Error("Namespace is required for CONNECTED_CONNECTOR_ID");
  return `@appkit/${s}:connected_connector_id`;
}
const le = {
  setItem(s, e) {
    Ri() && e !== void 0 && localStorage.setItem(s, e);
  },
  getItem(s) {
    if (Ri()) return localStorage.getItem(s) || void 0;
  },
  removeItem(s) {
    Ri() && localStorage.removeItem(s);
  },
  clear() {
    Ri() && localStorage.clear();
  },
};
function Ri() {
  return typeof window < "u" && typeof localStorage < "u";
}
function Zs(s, e) {
  return e === "light"
    ? {
        "--w3m-accent":
          (s == null ? void 0 : s["--w3m-accent"]) || "hsla(231, 100%, 70%, 1)",
        "--w3m-background": "#fff",
      }
    : {
        "--w3m-accent":
          (s == null ? void 0 : s["--w3m-accent"]) || "hsla(230, 100%, 67%, 1)",
        "--w3m-background": "#121313",
      };
}
var Sd = {};
const Qa =
    (typeof process < "u" && typeof Sd < "u"
      ? Sd.NEXT_PUBLIC_SECURE_SITE_ORIGIN
      : void 0) || "https://secure.walletconnect.org",
  cp = [
    {
      label: "Meld.io",
      name: "meld",
      feeRange: "1-2%",
      url: "https://meldcrypto.com",
      supportedChains: ["eip155", "solana"],
    },
    {
      label: "Coinbase",
      name: "coinbase",
      feeRange: "1-2%",
      url: "",
      supportedChains: ["eip155"],
    },
  ],
  Om = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU",
  Pe = {
    FOUR_MINUTES_MS: 24e4,
    TEN_SEC_MS: 1e4,
    ONE_SEC_MS: 1e3,
    SECURE_SITE: Qa,
    SECURE_SITE_DASHBOARD: `${Qa}/dashboard`,
    SECURE_SITE_FAVICON: `${Qa}/images/favicon.png`,
    WC_COINBASE_PAY_SDK_CHAINS: [
      "ethereum",
      "arbitrum",
      "polygon",
      "berachain",
      "avalanche-c-chain",
      "optimism",
      "celo",
      "base",
    ],
    WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
    WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
      Ethereum: "ethereum",
      "Arbitrum One": "arbitrum",
      Polygon: "polygon",
      Berachain: "berachain",
      Avalanche: "avalanche-c-chain",
      "OP Mainnet": "optimism",
      Celo: "celo",
      Base: "base",
    },
    SWAP_SUGGESTED_TOKENS: [
      "ETH",
      "UNI",
      "1INCH",
      "AAVE",
      "SOL",
      "ADA",
      "AVAX",
      "DOT",
      "LINK",
      "NITRO",
      "GAIA",
      "MILK",
      "TRX",
      "NEAR",
      "GNO",
      "WBTC",
      "DAI",
      "WETH",
      "USDC",
      "USDT",
      "ARB",
      "BAL",
      "BICO",
      "CRV",
      "ENS",
      "MATIC",
      "OP",
    ],
    BALANCE_SUPPORTED_CHAINS: [S.CHAIN.EVM, S.CHAIN.SOLANA],
    SWAP_SUPPORTED_NETWORKS: [
      "eip155:1",
      "eip155:42161",
      "eip155:10",
      "eip155:324",
      "eip155:8453",
      "eip155:56",
      "eip155:137",
      "eip155:100",
      "eip155:43114",
      "eip155:250",
      "eip155:8217",
      "eip155:1313161554",
    ],
    NAMES_SUPPORTED_CHAIN_NAMESPACES: [S.CHAIN.EVM],
    ONRAMP_SUPPORTED_CHAIN_NAMESPACES: [S.CHAIN.EVM, S.CHAIN.SOLANA],
    ACTIVITY_ENABLED_CHAIN_NAMESPACES: [S.CHAIN.EVM],
    NATIVE_TOKEN_ADDRESS: {
      eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
      solana: "So11111111111111111111111111111111111111111",
      polkadot: "0x",
      bip122: "0x",
      cosmos: "0x",
    },
    CONVERT_SLIPPAGE_TOLERANCE: 1,
    CONNECT_LABELS: { MOBILE: "Open and continue in the wallet app" },
    SEND_SUPPORTED_NAMESPACES: [S.CHAIN.EVM, S.CHAIN.SOLANA],
    DEFAULT_REMOTE_FEATURES: {
      swaps: ["1inch"],
      onramp: ["meld", "coinbase"],
      email: !0,
      socials: [
        "google",
        "x",
        "discord",
        "farcaster",
        "github",
        "apple",
        "facebook",
      ],
      activity: !0,
      reownBranding: !0,
      multiWallet: !1,
    },
    DEFAULT_REMOTE_FEATURES_DISABLED: {
      email: !1,
      socials: !1,
      swaps: !1,
      onramp: !1,
      activity: !1,
      reownBranding: !1,
    },
    DEFAULT_FEATURES: {
      receive: !0,
      send: !0,
      emailShowWallets: !0,
      connectorTypeOrder: [
        "walletConnect",
        "recent",
        "injected",
        "featured",
        "custom",
        "external",
        "recommended",
      ],
      analytics: !0,
      allWallets: !0,
      legalCheckbox: !1,
      smartSessions: !1,
      collapseWallets: !1,
      walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
      connectMethodsOrder: void 0,
      pay: !1,
    },
    DEFAULT_SOCIALS: [
      "google",
      "x",
      "farcaster",
      "discord",
      "apple",
      "github",
      "facebook",
    ],
    DEFAULT_ACCOUNT_TYPES: {
      bip122: "payment",
      eip155: "smartAccount",
      polkadot: "eoa",
      solana: "eoa",
    },
    ADAPTER_TYPES: { UNIVERSAL: "universal" },
    SIWX_DEFAULTS: { signOutOnDisconnect: !0 },
  },
  M = {
    cacheExpiry: {
      portfolio: 3e4,
      nativeBalance: 3e4,
      ens: 3e5,
      identity: 3e5,
    },
    isCacheExpired(s, e) {
      return Date.now() - s > e;
    },
    getActiveNetworkProps() {
      const s = M.getActiveNamespace(),
        e = M.getActiveCaipNetworkId(),
        t = e ? e.split(":")[1] : void 0,
        n = t ? (isNaN(Number(t)) ? t : Number(t)) : void 0;
      return { namespace: s, caipNetworkId: e, chainId: n };
    },
    setWalletConnectDeepLink({ name: s, href: e }) {
      try {
        le.setItem(he.DEEPLINK_CHOICE, JSON.stringify({ href: e, name: s }));
      } catch {
        console.info("Unable to set WalletConnect deep link");
      }
    },
    getWalletConnectDeepLink() {
      try {
        const s = le.getItem(he.DEEPLINK_CHOICE);
        if (s) return JSON.parse(s);
      } catch {
        console.info("Unable to get WalletConnect deep link");
      }
    },
    deleteWalletConnectDeepLink() {
      try {
        le.removeItem(he.DEEPLINK_CHOICE);
      } catch {
        console.info("Unable to delete WalletConnect deep link");
      }
    },
    setActiveNamespace(s) {
      try {
        le.setItem(he.ACTIVE_NAMESPACE, s);
      } catch {
        console.info("Unable to set active namespace");
      }
    },
    setActiveCaipNetworkId(s) {
      try {
        le.setItem(he.ACTIVE_CAIP_NETWORK_ID, s),
          M.setActiveNamespace(s.split(":")[0]);
      } catch {
        console.info("Unable to set active caip network id");
      }
    },
    getActiveCaipNetworkId() {
      try {
        return le.getItem(he.ACTIVE_CAIP_NETWORK_ID);
      } catch {
        console.info("Unable to get active caip network id");
        return;
      }
    },
    deleteActiveCaipNetworkId() {
      try {
        le.removeItem(he.ACTIVE_CAIP_NETWORK_ID);
      } catch {
        console.info("Unable to delete active caip network id");
      }
    },
    deleteConnectedConnectorId(s) {
      try {
        const e = Xa(s);
        le.removeItem(e);
      } catch {
        console.info("Unable to delete connected connector id");
      }
    },
    setAppKitRecent(s) {
      try {
        const e = M.getRecentWallets();
        e.find((n) => n.id === s.id) ||
          (e.unshift(s),
          e.length > 2 && e.pop(),
          le.setItem(he.RECENT_WALLETS, JSON.stringify(e)));
      } catch {
        console.info("Unable to set AppKit recent");
      }
    },
    getRecentWallets() {
      try {
        const s = le.getItem(he.RECENT_WALLETS);
        return s ? JSON.parse(s) : [];
      } catch {
        console.info("Unable to get AppKit recent");
      }
      return [];
    },
    setConnectedConnectorId(s, e) {
      try {
        const t = Xa(s);
        le.setItem(t, e);
      } catch {
        console.info("Unable to set Connected Connector Id");
      }
    },
    getActiveNamespace() {
      try {
        return le.getItem(he.ACTIVE_NAMESPACE);
      } catch {
        console.info("Unable to get active namespace");
      }
    },
    getConnectedConnectorId(s) {
      if (s)
        try {
          const e = Xa(s);
          return le.getItem(e);
        } catch {
          console.info("Unable to get connected connector id in namespace", s);
        }
    },
    setConnectedSocialProvider(s) {
      try {
        le.setItem(he.CONNECTED_SOCIAL, s);
      } catch {
        console.info("Unable to set connected social provider");
      }
    },
    getConnectedSocialProvider() {
      try {
        return le.getItem(he.CONNECTED_SOCIAL);
      } catch {
        console.info("Unable to get connected social provider");
      }
    },
    deleteConnectedSocialProvider() {
      try {
        le.removeItem(he.CONNECTED_SOCIAL);
      } catch {
        console.info("Unable to delete connected social provider");
      }
    },
    getConnectedSocialUsername() {
      try {
        return le.getItem(he.CONNECTED_SOCIAL_USERNAME);
      } catch {
        console.info("Unable to get connected social username");
      }
    },
    getStoredActiveCaipNetworkId() {
      var t;
      const s = le.getItem(he.ACTIVE_CAIP_NETWORK_ID);
      return (t = s == null ? void 0 : s.split(":")) == null ? void 0 : t[1];
    },
    setConnectionStatus(s) {
      try {
        le.setItem(he.CONNECTION_STATUS, s);
      } catch {
        console.info("Unable to set connection status");
      }
    },
    getConnectionStatus() {
      try {
        return le.getItem(he.CONNECTION_STATUS);
      } catch {
        return;
      }
    },
    getConnectedNamespaces() {
      try {
        const s = le.getItem(he.CONNECTED_NAMESPACES);
        return s != null && s.length ? s.split(",") : [];
      } catch {
        return [];
      }
    },
    setConnectedNamespaces(s) {
      try {
        const e = Array.from(new Set(s));
        le.setItem(he.CONNECTED_NAMESPACES, e.join(","));
      } catch {
        console.info("Unable to set namespaces in storage");
      }
    },
    addConnectedNamespace(s) {
      try {
        const e = M.getConnectedNamespaces();
        e.includes(s) || (e.push(s), M.setConnectedNamespaces(e));
      } catch {
        console.info("Unable to add connected namespace");
      }
    },
    removeConnectedNamespace(s) {
      try {
        const e = M.getConnectedNamespaces(),
          t = e.indexOf(s);
        t > -1 && (e.splice(t, 1), M.setConnectedNamespaces(e));
      } catch {
        console.info("Unable to remove connected namespace");
      }
    },
    getTelegramSocialProvider() {
      try {
        return le.getItem(he.TELEGRAM_SOCIAL_PROVIDER);
      } catch {
        return console.info("Unable to get telegram social provider"), null;
      }
    },
    setTelegramSocialProvider(s) {
      try {
        le.setItem(he.TELEGRAM_SOCIAL_PROVIDER, s);
      } catch {
        console.info("Unable to set telegram social provider");
      }
    },
    removeTelegramSocialProvider() {
      try {
        le.removeItem(he.TELEGRAM_SOCIAL_PROVIDER);
      } catch {
        console.info("Unable to remove telegram social provider");
      }
    },
    getBalanceCache() {
      let s = {};
      try {
        const e = le.getItem(he.PORTFOLIO_CACHE);
        s = e ? JSON.parse(e) : {};
      } catch {
        console.info("Unable to get balance cache");
      }
      return s;
    },
    removeAddressFromBalanceCache(s) {
      try {
        const e = M.getBalanceCache();
        le.setItem(he.PORTFOLIO_CACHE, JSON.stringify({ ...e, [s]: void 0 }));
      } catch {
        console.info("Unable to remove address from balance cache", s);
      }
    },
    getBalanceCacheForCaipAddress(s) {
      try {
        const t = M.getBalanceCache()[s];
        if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.portfolio))
          return t.balance;
        M.removeAddressFromBalanceCache(s);
      } catch {
        console.info("Unable to get balance cache for address", s);
      }
    },
    updateBalanceCache(s) {
      try {
        const e = M.getBalanceCache();
        (e[s.caipAddress] = s),
          le.setItem(he.PORTFOLIO_CACHE, JSON.stringify(e));
      } catch {
        console.info("Unable to update balance cache", s);
      }
    },
    getNativeBalanceCache() {
      let s = {};
      try {
        const e = le.getItem(he.NATIVE_BALANCE_CACHE);
        s = e ? JSON.parse(e) : {};
      } catch {
        console.info("Unable to get balance cache");
      }
      return s;
    },
    removeAddressFromNativeBalanceCache(s) {
      try {
        const e = M.getBalanceCache();
        le.setItem(
          he.NATIVE_BALANCE_CACHE,
          JSON.stringify({ ...e, [s]: void 0 })
        );
      } catch {
        console.info("Unable to remove address from balance cache", s);
      }
    },
    getNativeBalanceCacheForCaipAddress(s) {
      try {
        const t = M.getNativeBalanceCache()[s];
        if (
          t &&
          !this.isCacheExpired(t.timestamp, this.cacheExpiry.nativeBalance)
        )
          return t;
        console.info("Discarding cache for address", s),
          M.removeAddressFromBalanceCache(s);
      } catch {
        console.info("Unable to get balance cache for address", s);
      }
    },
    updateNativeBalanceCache(s) {
      try {
        const e = M.getNativeBalanceCache();
        (e[s.caipAddress] = s),
          le.setItem(he.NATIVE_BALANCE_CACHE, JSON.stringify(e));
      } catch {
        console.info("Unable to update balance cache", s);
      }
    },
    getEnsCache() {
      let s = {};
      try {
        const e = le.getItem(he.ENS_CACHE);
        s = e ? JSON.parse(e) : {};
      } catch {
        console.info("Unable to get ens name cache");
      }
      return s;
    },
    getEnsFromCacheForAddress(s) {
      try {
        const t = M.getEnsCache()[s];
        if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.ens))
          return t.ens;
        M.removeEnsFromCache(s);
      } catch {
        console.info("Unable to get ens name from cache", s);
      }
    },
    updateEnsCache(s) {
      try {
        const e = M.getEnsCache();
        (e[s.address] = s), le.setItem(he.ENS_CACHE, JSON.stringify(e));
      } catch {
        console.info("Unable to update ens name cache", s);
      }
    },
    removeEnsFromCache(s) {
      try {
        const e = M.getEnsCache();
        le.setItem(he.ENS_CACHE, JSON.stringify({ ...e, [s]: void 0 }));
      } catch {
        console.info("Unable to remove ens name from cache", s);
      }
    },
    getIdentityCache() {
      let s = {};
      try {
        const e = le.getItem(he.IDENTITY_CACHE);
        s = e ? JSON.parse(e) : {};
      } catch {
        console.info("Unable to get identity cache");
      }
      return s;
    },
    getIdentityFromCacheForAddress(s) {
      try {
        const t = M.getIdentityCache()[s];
        if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.identity))
          return t.identity;
        M.removeIdentityFromCache(s);
      } catch {
        console.info("Unable to get identity from cache", s);
      }
    },
    updateIdentityCache(s) {
      try {
        const e = M.getIdentityCache();
        (e[s.address] = { identity: s.identity, timestamp: s.timestamp }),
          le.setItem(he.IDENTITY_CACHE, JSON.stringify(e));
      } catch {
        console.info("Unable to update identity cache", s);
      }
    },
    removeIdentityFromCache(s) {
      try {
        const e = M.getIdentityCache();
        le.setItem(he.IDENTITY_CACHE, JSON.stringify({ ...e, [s]: void 0 }));
      } catch {
        console.info("Unable to remove identity from cache", s);
      }
    },
    clearAddressCache() {
      try {
        le.removeItem(he.PORTFOLIO_CACHE),
          le.removeItem(he.NATIVE_BALANCE_CACHE),
          le.removeItem(he.ENS_CACHE),
          le.removeItem(he.IDENTITY_CACHE);
      } catch {
        console.info("Unable to clear address cache");
      }
    },
    setPreferredAccountTypes(s) {
      try {
        le.setItem(he.PREFERRED_ACCOUNT_TYPES, JSON.stringify(s));
      } catch {
        console.info("Unable to set preferred account types", s);
      }
    },
    getPreferredAccountTypes() {
      try {
        const s = le.getItem(he.PREFERRED_ACCOUNT_TYPES);
        return s ? JSON.parse(s) : {};
      } catch {
        console.info("Unable to get preferred account types");
      }
      return {};
    },
    setConnections(s, e) {
      try {
        const t = M.getConnections(),
          n = t[e] ?? [],
          r = new Map();
        for (const o of n) r.set(o.connectorId, { ...o });
        for (const o of s) {
          const a = r.get(o.connectorId),
            c = o.connectorId === S.CONNECTOR_ID.AUTH;
          if (a && !c) {
            const l = new Set(a.accounts.map((u) => u.address.toLowerCase())),
              d = o.accounts.filter((u) => !l.has(u.address.toLowerCase()));
            a.accounts.push(...d);
          } else r.set(o.connectorId, { ...o });
        }
        const i = { ...t, [e]: Array.from(r.values()) };
        le.setItem(he.CONNECTIONS, JSON.stringify(i));
      } catch (t) {
        console.error("Unable to sync connections to storage", t);
      }
    },
    getConnections() {
      try {
        const s = le.getItem(he.CONNECTIONS);
        return s ? JSON.parse(s) : {};
      } catch (s) {
        return console.error("Unable to get connections from storage", s), {};
      }
    },
    deleteAddressFromConnection({ connectorId: s, address: e, namespace: t }) {
      try {
        const n = M.getConnections(),
          r = n[t] ?? [],
          i = new Map(r.map((a) => [a.connectorId, a])),
          o = i.get(s);
        o &&
          (o.accounts.filter((c) => c.address.toLowerCase() !== e.toLowerCase())
            .length === 0
            ? i.delete(s)
            : i.set(s, {
                ...o,
                accounts: o.accounts.filter(
                  (c) => c.address.toLowerCase() !== e.toLowerCase()
                ),
              })),
          le.setItem(
            he.CONNECTIONS,
            JSON.stringify({ ...n, [t]: Array.from(i.values()) })
          );
      } catch {
        console.error(
          `Unable to remove address "${e}" from connector "${s}" in namespace "${t}"`
        );
      }
    },
    getDisconnectedConnectorIds() {
      try {
        const s = le.getItem(he.DISCONNECTED_CONNECTOR_IDS);
        return s ? JSON.parse(s) : {};
      } catch {
        console.info("Unable to get disconnected connector ids");
      }
      return {};
    },
    addDisconnectedConnectorId(s, e) {
      try {
        const t = M.getDisconnectedConnectorIds(),
          n = t[e] ?? [];
        n.push(s),
          le.setItem(
            he.DISCONNECTED_CONNECTOR_IDS,
            JSON.stringify({ ...t, [e]: Array.from(new Set(n)) })
          );
      } catch {
        console.error(
          `Unable to set disconnected connector id "${s}" for namespace "${e}"`
        );
      }
    },
    removeDisconnectedConnectorId(s, e) {
      try {
        const t = M.getDisconnectedConnectorIds();
        let n = t[e] ?? [];
        (n = n.filter((r) => r.toLowerCase() !== s.toLowerCase())),
          le.setItem(
            he.DISCONNECTED_CONNECTOR_IDS,
            JSON.stringify({ ...t, [e]: Array.from(new Set(n)) })
          );
      } catch {
        console.error(
          `Unable to remove disconnected connector id "${s}" for namespace "${e}"`
        );
      }
    },
    isConnectorDisconnected(s, e) {
      try {
        return (M.getDisconnectedConnectorIds()[e] ?? []).some(
          (r) => r.toLowerCase() === s.toLowerCase()
        );
      } catch {
        console.info(
          `Unable to get disconnected connector id "${s}" for namespace "${e}"`
        );
      }
      return !1;
    },
  },
  ne = {
    isMobile() {
      var s;
      return this.isClient()
        ? !!(
            (window != null &&
              window.matchMedia &&
              typeof window.matchMedia == "function" &&
              (s = window.matchMedia("(pointer:coarse)")) != null &&
              s.matches) ||
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(
              navigator.userAgent
            )
          )
        : !1;
    },
    checkCaipNetwork(s, e = "") {
      return s == null
        ? void 0
        : s.caipNetworkId.toLocaleLowerCase().includes(e.toLowerCase());
    },
    isAndroid() {
      if (!this.isMobile()) return !1;
      const s =
        window == null ? void 0 : window.navigator.userAgent.toLowerCase();
      return ne.isMobile() && s.includes("android");
    },
    isIos() {
      if (!this.isMobile()) return !1;
      const s =
        window == null ? void 0 : window.navigator.userAgent.toLowerCase();
      return s.includes("iphone") || s.includes("ipad");
    },
    isSafari() {
      return this.isClient()
        ? (window == null
            ? void 0
            : window.navigator.userAgent.toLowerCase()
          ).includes("safari")
        : !1;
    },
    isClient() {
      return typeof window < "u";
    },
    isPairingExpired(s) {
      return s ? s - Date.now() <= Pe.TEN_SEC_MS : !0;
    },
    isAllowedRetry(s, e = Pe.ONE_SEC_MS) {
      return Date.now() - s >= e;
    },
    copyToClopboard(s) {
      navigator.clipboard.writeText(s);
    },
    isIframe() {
      try {
        return (
          (window == null ? void 0 : window.self) !==
          (window == null ? void 0 : window.top)
        );
      } catch {
        return !1;
      }
    },
    isSafeApp() {
      var s, e;
      if (ne.isClient() && window.self !== window.top)
        try {
          const t =
              (e =
                (s = window == null ? void 0 : window.location) == null
                  ? void 0
                  : s.ancestorOrigins) == null
                ? void 0
                : e[0],
            n = "https://app.safe.global";
          if (t) {
            const r = new URL(t),
              i = new URL(n);
            return r.hostname === i.hostname;
          }
        } catch {
          return !1;
        }
      return !1;
    },
    getPairingExpiry() {
      return Date.now() + Pe.FOUR_MINUTES_MS;
    },
    getNetworkId(s) {
      return s == null ? void 0 : s.split(":")[1];
    },
    getPlainAddress(s) {
      return s == null ? void 0 : s.split(":")[2];
    },
    async wait(s) {
      return new Promise((e) => {
        setTimeout(e, s);
      });
    },
    debounce(s, e = 500) {
      let t;
      return (...n) => {
        function r() {
          s(...n);
        }
        t && clearTimeout(t), (t = setTimeout(r, e));
      };
    },
    isHttpUrl(s) {
      return s.startsWith("http://") || s.startsWith("https://");
    },
    formatNativeUrl(s, e, t = null) {
      if (ne.isHttpUrl(s)) return this.formatUniversalUrl(s, e);
      let n = s,
        r = t;
      n.includes("://") ||
        ((n = s.replaceAll("/", "").replaceAll(":", "")), (n = `${n}://`)),
        n.endsWith("/") || (n = `${n}/`),
        r && !(r != null && r.endsWith("/")) && (r = `${r}/`),
        this.isTelegram() && this.isAndroid() && (e = encodeURIComponent(e));
      const i = encodeURIComponent(e);
      return {
        redirect: `${n}wc?uri=${i}`,
        redirectUniversalLink: r ? `${r}wc?uri=${i}` : void 0,
        href: n,
      };
    },
    formatUniversalUrl(s, e) {
      if (!ne.isHttpUrl(s)) return this.formatNativeUrl(s, e);
      let t = s;
      t.endsWith("/") || (t = `${t}/`);
      const n = encodeURIComponent(e);
      return { redirect: `${t}wc?uri=${n}`, href: t };
    },
    getOpenTargetForPlatform(s) {
      return s === "popupWindow"
        ? s
        : this.isTelegram()
        ? M.getTelegramSocialProvider()
          ? "_top"
          : "_blank"
        : s;
    },
    openHref(s, e, t) {
      window == null ||
        window.open(
          s,
          this.getOpenTargetForPlatform(e),
          t || "noreferrer noopener"
        );
    },
    returnOpenHref(s, e, t) {
      return window == null
        ? void 0
        : window.open(
            s,
            this.getOpenTargetForPlatform(e),
            t || "noreferrer noopener"
          );
    },
    isTelegram() {
      return (
        typeof window < "u" &&
        (!!window.TelegramWebviewProxy ||
          !!window.Telegram ||
          !!window.TelegramWebviewProxyProto)
      );
    },
    isPWA() {
      var t, n;
      if (typeof window > "u") return !1;
      const s =
          window != null &&
          window.matchMedia &&
          typeof window.matchMedia == "function"
            ? (t = window.matchMedia("(display-mode: standalone)")) == null
              ? void 0
              : t.matches
            : !1,
        e =
          (n = window == null ? void 0 : window.navigator) == null
            ? void 0
            : n.standalone;
      return !!(s || e);
    },
    async preloadImage(s) {
      const e = new Promise((t, n) => {
        const r = new Image();
        (r.onload = t),
          (r.onerror = n),
          (r.crossOrigin = "anonymous"),
          (r.src = s);
      });
      return Promise.race([e, ne.wait(2e3)]);
    },
    formatBalance(s, e) {
      let t = "0.000";
      if (typeof s == "string") {
        const n = Number(s);
        if (n) {
          const r = Math.floor(n * 1e3) / 1e3;
          r && (t = r.toString());
        }
      }
      return `${t}${e ? ` ${e}` : ""}`;
    },
    formatBalance2(s, e) {
      var n;
      let t;
      if (s === "0") t = "0";
      else if (typeof s == "string") {
        const r = Number(s);
        r &&
          (t =
            (n = r.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null
              ? void 0
              : n[0]);
      }
      return { value: t ?? "0", rest: t === "0" ? "000" : "", symbol: e };
    },
    getApiUrl() {
      return S.W3M_API_URL;
    },
    getBlockchainApiUrl() {
      return S.BLOCKCHAIN_API_RPC_URL;
    },
    getAnalyticsUrl() {
      return S.PULSE_API_URL;
    },
    getUUID() {
      return crypto != null && crypto.randomUUID
        ? crypto.randomUUID()
        : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (s) => {
            const e = (Math.random() * 16) | 0;
            return (s === "x" ? e : (e & 3) | 8).toString(16);
          });
    },
    parseError(s) {
      var e, t;
      return typeof s == "string"
        ? s
        : typeof ((t =
            (e = s == null ? void 0 : s.issues) == null ? void 0 : e[0]) == null
            ? void 0
            : t.message) == "string"
        ? s.issues[0].message
        : s instanceof Error
        ? s.message
        : "Unknown error";
    },
    sortRequestedNetworks(s, e = []) {
      const t = {};
      return (
        e &&
          s &&
          (s.forEach((n, r) => {
            t[n] = r;
          }),
          e.sort((n, r) => {
            const i = t[n.id],
              o = t[r.id];
            return i !== void 0 && o !== void 0
              ? i - o
              : i !== void 0
              ? -1
              : o !== void 0
              ? 1
              : 0;
          })),
        e
      );
    },
    calculateBalance(s) {
      let e = 0;
      for (const t of s) e += t.value ?? 0;
      return e;
    },
    formatTokenBalance(s) {
      const e = s.toFixed(2),
        [t, n] = e.split(".");
      return { dollars: t, pennies: n };
    },
    isAddress(s, e = "eip155") {
      switch (e) {
        case "eip155":
          if (/^(?:0x)?[0-9a-f]{40}$/iu.test(s)) {
            if (
              /^(?:0x)?[0-9a-f]{40}$/iu.test(s) ||
              /^(?:0x)?[0-9A-F]{40}$/iu.test(s)
            )
              return !0;
          } else return !1;
          return !1;
        case "solana":
          return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(s);
        default:
          return !1;
      }
    },
    uniqueBy(s, e) {
      const t = new Set();
      return s.filter((n) => {
        const r = n[e];
        return t.has(r) ? !1 : (t.add(r), !0);
      });
    },
    generateSdkVersion(s, e, t) {
      const r =
        s.length === 0
          ? Pe.ADAPTER_TYPES.UNIVERSAL
          : s.map((i) => i.adapterType).join(",");
      return `${e}-${r}-${t}`;
    },
    createAccount(s, e, t, n, r) {
      return { namespace: s, address: e, type: t, publicKey: n, path: r };
    },
    isCaipAddress(s) {
      if (typeof s != "string") return !1;
      const e = s.split(":"),
        t = e[0];
      return e.filter(Boolean).length === 3 && t in S.CHAIN_NAME_MAP;
    },
    getAccount(s) {
      return s
        ? typeof s == "string"
          ? { address: s, chainId: void 0 }
          : { address: s.address, chainId: s.chainId }
        : { address: void 0, chainId: void 0 };
    },
    isMac() {
      const s =
        window == null ? void 0 : window.navigator.userAgent.toLowerCase();
      return s.includes("macintosh") && !s.includes("safari");
    },
    formatTelegramSocialLoginUrl(s) {
      const e = `--${encodeURIComponent(
          window == null ? void 0 : window.location.href
        )}`,
        t = "state=";
      if (new URL(s).host === "auth.magic.link") {
        const r = "provider_authorization_url=",
          i = s.substring(s.indexOf(r) + r.length),
          o = this.injectIntoUrl(decodeURIComponent(i), t, e);
        return s.replace(i, encodeURIComponent(o));
      }
      return this.injectIntoUrl(s, t, e);
    },
    injectIntoUrl(s, e, t) {
      const n = s.indexOf(e);
      if (n === -1)
        throw new Error(`${e} parameter not found in the URL: ${s}`);
      const r = s.indexOf("&", n),
        i = e.length,
        o = r !== -1 ? r : s.length,
        a = s.substring(0, n + i),
        c = s.substring(n + i, o),
        l = s.substring(r),
        d = c + t;
      return a + d + l;
    },
  };
async function ui(...s) {
  const e = await fetch(...s);
  if (!e.ok) throw new Error(`HTTP status code: ${e.status}`, { cause: e });
  return e;
}
class So {
  constructor({ baseUrl: e, clientId: t }) {
    (this.baseUrl = e), (this.clientId = t);
  }
  async get({ headers: e, signal: t, cache: n, ...r }) {
    const i = this.createUrl(r);
    return (
      await ui(i, { method: "GET", headers: e, signal: t, cache: n })
    ).json();
  }
  async getBlob({ headers: e, signal: t, ...n }) {
    const r = this.createUrl(n);
    return (await ui(r, { method: "GET", headers: e, signal: t })).blob();
  }
  async post({ body: e, headers: t, signal: n, ...r }) {
    const i = this.createUrl(r);
    return (
      await ui(i, {
        method: "POST",
        headers: t,
        body: e ? JSON.stringify(e) : void 0,
        signal: n,
      })
    ).json();
  }
  async put({ body: e, headers: t, signal: n, ...r }) {
    const i = this.createUrl(r);
    return (
      await ui(i, {
        method: "PUT",
        headers: t,
        body: e ? JSON.stringify(e) : void 0,
        signal: n,
      })
    ).json();
  }
  async delete({ body: e, headers: t, signal: n, ...r }) {
    const i = this.createUrl(r);
    return (
      await ui(i, {
        method: "DELETE",
        headers: t,
        body: e ? JSON.stringify(e) : void 0,
        signal: n,
      })
    ).json();
  }
  createUrl({ path: e, params: t }) {
    const n = new URL(e, this.baseUrl);
    return (
      t &&
        Object.entries(t).forEach(([r, i]) => {
          i && n.searchParams.append(r, i);
        }),
      this.clientId && n.searchParams.append("clientId", this.clientId),
      n
    );
  }
}
const km = {
    getFeatureValue(s, e) {
      const t = e == null ? void 0 : e[s];
      return t === void 0 ? Pe.DEFAULT_FEATURES[s] : t;
    },
    filterSocialsByPlatform(s) {
      if (!s || !s.length) return s;
      if (ne.isTelegram()) {
        if (ne.isIos()) return s.filter((e) => e !== "google");
        if (ne.isMac()) return s.filter((e) => e !== "x");
        if (ne.isAndroid())
          return s.filter((e) => !["facebook", "x"].includes(e));
      }
      return s;
    },
  },
  oe = qe({
    features: Pe.DEFAULT_FEATURES,
    projectId: "",
    sdkType: "appkit",
    sdkVersion: "html-wagmi-undefined",
    defaultAccountTypes: Pe.DEFAULT_ACCOUNT_TYPES,
    enableNetworkSwitch: !0,
    experimental_preferUniversalLinks: !1,
    remoteFeatures: {},
  }),
  R = {
    state: oe,
    subscribeKey(s, e) {
      return Ct(oe, s, e);
    },
    setOptions(s) {
      Object.assign(oe, s);
    },
    setRemoteFeatures(s) {
      var t;
      if (!s) return;
      const e = { ...oe.remoteFeatures, ...s };
      (oe.remoteFeatures = e),
        (t = oe.remoteFeatures) != null &&
          t.socials &&
          (oe.remoteFeatures.socials = km.filterSocialsByPlatform(
            oe.remoteFeatures.socials
          ));
    },
    setFeatures(s) {
      if (!s) return;
      oe.features || (oe.features = Pe.DEFAULT_FEATURES);
      const e = { ...oe.features, ...s };
      oe.features = e;
    },
    setProjectId(s) {
      oe.projectId = s;
    },
    setCustomRpcUrls(s) {
      oe.customRpcUrls = s;
    },
    setAllWallets(s) {
      oe.allWallets = s;
    },
    setIncludeWalletIds(s) {
      oe.includeWalletIds = s;
    },
    setExcludeWalletIds(s) {
      oe.excludeWalletIds = s;
    },
    setFeaturedWalletIds(s) {
      oe.featuredWalletIds = s;
    },
    setTokens(s) {
      oe.tokens = s;
    },
    setTermsConditionsUrl(s) {
      oe.termsConditionsUrl = s;
    },
    setPrivacyPolicyUrl(s) {
      oe.privacyPolicyUrl = s;
    },
    setCustomWallets(s) {
      oe.customWallets = s;
    },
    setIsSiweEnabled(s) {
      oe.isSiweEnabled = s;
    },
    setIsUniversalProvider(s) {
      oe.isUniversalProvider = s;
    },
    setSdkVersion(s) {
      oe.sdkVersion = s;
    },
    setMetadata(s) {
      oe.metadata = s;
    },
    setDisableAppend(s) {
      oe.disableAppend = s;
    },
    setEIP6963Enabled(s) {
      oe.enableEIP6963 = s;
    },
    setDebug(s) {
      oe.debug = s;
    },
    setEnableWalletConnect(s) {
      oe.enableWalletConnect = s;
    },
    setEnableWalletGuide(s) {
      oe.enableWalletGuide = s;
    },
    setEnableAuthLogger(s) {
      oe.enableAuthLogger = s;
    },
    setEnableWallets(s) {
      oe.enableWallets = s;
    },
    setPreferUniversalLinks(s) {
      oe.experimental_preferUniversalLinks = s;
    },
    setSIWX(s) {
      if (s)
        for (const [e, t] of Object.entries(Pe.SIWX_DEFAULTS))
          s[e] ?? (s[e] = t);
      oe.siwx = s;
    },
    setConnectMethodsOrder(s) {
      oe.features = { ...oe.features, connectMethodsOrder: s };
    },
    setWalletFeaturesOrder(s) {
      oe.features = { ...oe.features, walletFeaturesOrder: s };
    },
    setSocialsOrder(s) {
      oe.remoteFeatures = { ...oe.remoteFeatures, socials: s };
    },
    setCollapseWallets(s) {
      oe.features = { ...oe.features, collapseWallets: s };
    },
    setEnableEmbedded(s) {
      oe.enableEmbedded = s;
    },
    setAllowUnsupportedChain(s) {
      oe.allowUnsupportedChain = s;
    },
    setManualWCControl(s) {
      oe.manualWCControl = s;
    },
    setEnableNetworkSwitch(s) {
      oe.enableNetworkSwitch = s;
    },
    setEnableReconnect(s) {
      oe.enableReconnect = s;
    },
    setDefaultAccountTypes(s = {}) {
      Object.entries(s).forEach(([e, t]) => {
        t && (oe.defaultAccountTypes[e] = t);
      });
    },
    setUniversalProviderConfigOverride(s) {
      oe.universalProviderConfigOverride = s;
    },
    getUniversalProviderConfigOverride() {
      return oe.universalProviderConfigOverride;
    },
    getSnapshot() {
      return Xi(oe);
    },
  },
  Um = Object.freeze({ enabled: !0, events: [] }),
  $m = new So({ baseUrl: ne.getAnalyticsUrl(), clientId: null }),
  Dm = 5,
  Lm = 60 * 1e3,
  rn = qe({ ...Um }),
  Mm = {
    state: rn,
    subscribeKey(s, e) {
      return Ct(rn, s, e);
    },
    async sendError(s, e) {
      if (!rn.enabled) return;
      const t = Date.now();
      if (
        rn.events.filter((i) => {
          const o = new Date(i.properties.timestamp || "").getTime();
          return t - o < Lm;
        }).length >= Dm
      )
        return;
      const r = {
        type: "error",
        event: e,
        properties: {
          errorType: s.name,
          errorMessage: s.message,
          stackTrace: s.stack,
          timestamp: new Date().toISOString(),
        },
      };
      rn.events.push(r);
      try {
        if (typeof window > "u") return;
        const { projectId: i, sdkType: o, sdkVersion: a } = R.state;
        await $m.post({
          path: "/e",
          params: { projectId: i, st: o, sv: a || "html-wagmi-4.2.2" },
          body: {
            eventId: ne.getUUID(),
            url: window.location.href,
            domain: window.location.hostname,
            timestamp: new Date().toISOString(),
            props: {
              type: "error",
              event: e,
              errorType: s.name,
              errorMessage: s.message,
              stackTrace: s.stack,
            },
          },
        });
      } catch {}
    },
    enable() {
      rn.enabled = !0;
    },
    disable() {
      rn.enabled = !1;
    },
    clearEvents() {
      rn.events = [];
    },
  };
class Wr extends Error {
  constructor(e, t, n) {
    super(e),
      (this.name = "AppKitError"),
      (this.category = t),
      (this.originalError = n),
      Object.setPrototypeOf(this, Wr.prototype);
    let r = !1;
    if (n instanceof Error && typeof n.stack == "string" && n.stack) {
      const i = n.stack,
        o = i.indexOf(`
`);
      if (o > -1) {
        const a = i.substring(o + 1);
        (this.stack = `${this.name}: ${this.message}
${a}`),
          (r = !0);
      }
    }
    r ||
      (Error.captureStackTrace
        ? Error.captureStackTrace(this, Wr)
        : this.stack || (this.stack = `${this.name}: ${this.message}`));
  }
}
function Nd(s, e) {
  const t =
    s instanceof Wr
      ? s
      : new Wr(s instanceof Error ? s.message : String(s), e, s);
  throw (Mm.sendError(t, t.category), t);
}
function Zt(s, e = "INTERNAL_SDK_ERROR") {
  const t = {};
  return (
    Object.keys(s).forEach((n) => {
      const r = s[n];
      if (typeof r == "function") {
        let i = r;
        r.constructor.name === "AsyncFunction"
          ? (i = async (...o) => {
              try {
                return await r(...o);
              } catch (a) {
                return Nd(a, e);
              }
            })
          : (i = (...o) => {
              try {
                return r(...o);
              } catch (a) {
                return Nd(a, e);
              }
            }),
          (t[n] = i);
      } else t[n] = r;
    }),
    t
  );
}
var zr = {};
const Bm = "https://secure.walletconnect.org/sdk",
  Fm =
    (typeof process < "u" && typeof zr < "u"
      ? zr.NEXT_PUBLIC_SECURE_SITE_SDK_URL
      : void 0) || Bm,
  jm =
    (typeof process < "u" && typeof zr < "u"
      ? zr.NEXT_PUBLIC_DEFAULT_LOG_LEVEL
      : void 0) || "error",
  qm =
    (typeof process < "u" && typeof zr < "u"
      ? zr.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION
      : void 0) || "4",
  te = {
    APP_EVENT_KEY: "@w3m-app/",
    FRAME_EVENT_KEY: "@w3m-frame/",
    RPC_METHOD_KEY: "RPC_",
    STORAGE_KEY: "@appkit-wallet/",
    SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
    EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
    LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
    LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
    EMAIL: "EMAIL",
    PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
    SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
    SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
    SOCIAL_USERNAME: "SOCIAL_USERNAME",
    APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
    APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
    APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
    APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
    APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
    APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
    APP_GET_USER: "@w3m-app/GET_USER",
    APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
    APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
    APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
    APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
    APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
    APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
    APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
    APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
    APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
    APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
    APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS:
      "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
    APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
    APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
    APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
    APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
    APP_RELOAD: "@w3m-app/RELOAD",
    APP_RPC_ABORT: "@w3m-app/RPC_ABORT",
    FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
    FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
    FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
    FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
    FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
    FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
    FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
    FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
    FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
    FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
    FRAME_CONNECT_FARCASTER_SUCCESS: "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
    FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
    FRAME_GET_FARCASTER_URI_SUCCESS: "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
    FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
    FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS:
      "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
    FRAME_GET_SOCIAL_REDIRECT_URI_ERROR:
      "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
    FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
    FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
    FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
    FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
    FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
    FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
    FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
    FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
    FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
    FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
    FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
    FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
    FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS:
      "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR:
      "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS:
      "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR:
      "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
    FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
    FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
    FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
    FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
      "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
      "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
    FRAME_INIT_SMART_ACCOUNT_SUCCESS: "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
    FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
    FRAME_SET_PREFERRED_ACCOUNT_SUCCESS:
      "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
    FRAME_SET_PREFERRED_ACCOUNT_ERROR: "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
    FRAME_READY: "@w3m-frame/READY",
    FRAME_RELOAD_SUCCESS: "@w3m-frame/RELOAD_SUCCESS",
    FRAME_RELOAD_ERROR: "@w3m-frame/RELOAD_ERROR",
    FRAME_RPC_ABORT_SUCCESS: "@w3m-frame/RPC_ABORT_SUCCESS",
    FRAME_RPC_ABORT_ERROR: "@w3m-frame/RPC_ABORT_ERROR",
    RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
    RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
    RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT",
  },
  nt = {
    SAFE_RPC_METHODS: [
      "eth_accounts",
      "eth_blockNumber",
      "eth_call",
      "eth_chainId",
      "eth_estimateGas",
      "eth_feeHistory",
      "eth_gasPrice",
      "eth_getAccount",
      "eth_getBalance",
      "eth_getBlockByHash",
      "eth_getBlockByNumber",
      "eth_getBlockReceipts",
      "eth_getBlockTransactionCountByHash",
      "eth_getBlockTransactionCountByNumber",
      "eth_getCode",
      "eth_getFilterChanges",
      "eth_getFilterLogs",
      "eth_getLogs",
      "eth_getProof",
      "eth_getStorageAt",
      "eth_getTransactionByBlockHashAndIndex",
      "eth_getTransactionByBlockNumberAndIndex",
      "eth_getTransactionByHash",
      "eth_getTransactionCount",
      "eth_getTransactionReceipt",
      "eth_getUncleCountByBlockHash",
      "eth_getUncleCountByBlockNumber",
      "eth_maxPriorityFeePerGas",
      "eth_newBlockFilter",
      "eth_newFilter",
      "eth_newPendingTransactionFilter",
      "eth_sendRawTransaction",
      "eth_syncing",
      "eth_uninstallFilter",
      "wallet_getCapabilities",
      "wallet_getCallsStatus",
      "eth_getUserOperationReceipt",
      "eth_estimateUserOperationGas",
      "eth_getUserOperationByHash",
      "eth_supportedEntryPoints",
      "wallet_getAssets",
    ],
    NOT_SAFE_RPC_METHODS: [
      "personal_sign",
      "eth_signTypedData_v4",
      "eth_sendTransaction",
      "solana_signMessage",
      "solana_signTransaction",
      "solana_signAllTransactions",
      "solana_signAndSendTransaction",
      "wallet_sendCalls",
      "wallet_grantPermissions",
      "wallet_revokePermissions",
      "eth_sendUserOperation",
    ],
    GET_CHAIN_ID: "eth_chainId",
    RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
    RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
    ACCOUNT_TYPES: { EOA: "eoa", SMART_ACCOUNT: "smartAccount" },
  },
  Ps = {
    PHANTOM: {
      id: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
      url: "https://phantom.app",
    },
    SOLFLARE: {
      id: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
      url: "https://solflare.com",
    },
    COINBASE: {
      id: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
      url: "https://go.cb-w.com",
    },
  },
  Hm = {
    handleMobileDeeplinkRedirect(s, e) {
      const t = window.location.href,
        n = encodeURIComponent(t);
      if (s === Ps.PHANTOM.id && !("phantom" in window)) {
        const r = t.startsWith("https") ? "https" : "http",
          i = t.split("/")[2],
          o = encodeURIComponent(`${r}://${i}`);
        window.location.href = `${Ps.PHANTOM.url}/ul/browse/${n}?ref=${o}`;
      }
      s === Ps.SOLFLARE.id &&
        !("solflare" in window) &&
        (window.location.href = `${Ps.SOLFLARE.url}/ul/v1/browse/${n}?ref=${n}`),
        e === S.CHAIN.SOLANA &&
          s === Ps.COINBASE.id &&
          !("coinbaseSolana" in window) &&
          (window.location.href = `${Ps.COINBASE.url}/dapp?cb_url=${n}`);
    },
  },
  jt = qe({
    walletImages: {},
    networkImages: {},
    chainImages: {},
    connectorImages: {},
    tokenImages: {},
    currencyImages: {},
  }),
  Wm = {
    state: jt,
    subscribeNetworkImages(s) {
      return ft(jt.networkImages, () => s(jt.networkImages));
    },
    subscribeKey(s, e) {
      return Ct(jt, s, e);
    },
    subscribe(s) {
      return ft(jt, () => s(jt));
    },
    setWalletImage(s, e) {
      jt.walletImages[s] = e;
    },
    setNetworkImage(s, e) {
      jt.networkImages[s] = e;
    },
    setChainImage(s, e) {
      jt.chainImages[s] = e;
    },
    setConnectorImage(s, e) {
      jt.connectorImages = { ...jt.connectorImages, [s]: e };
    },
    setTokenImage(s, e) {
      jt.tokenImages[s] = e;
    },
    setCurrencyImage(s, e) {
      jt.currencyImages[s] = e;
    },
  },
  gs = Zt(Wm),
  zm = {
    eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
    solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
    polkadot: "",
    bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
    cosmos: "",
  },
  ec = qe({ networkImagePromises: {} }),
  lp = {
    async fetchWalletImage(s) {
      if (s) return await re._fetchWalletImage(s), this.getWalletImageById(s);
    },
    async fetchNetworkImage(s) {
      if (!s) return;
      const e = this.getNetworkImageById(s);
      return (
        e ||
        (ec.networkImagePromises[s] ||
          (ec.networkImagePromises[s] = re._fetchNetworkImage(s)),
        await ec.networkImagePromises[s],
        this.getNetworkImageById(s))
      );
    },
    getWalletImageById(s) {
      if (s) return gs.state.walletImages[s];
    },
    getWalletImage(s) {
      if (s != null && s.image_url) return s == null ? void 0 : s.image_url;
      if (s != null && s.image_id) return gs.state.walletImages[s.image_id];
    },
    getNetworkImage(s) {
      var e, t, n;
      if ((e = s == null ? void 0 : s.assets) != null && e.imageUrl)
        return (t = s == null ? void 0 : s.assets) == null
          ? void 0
          : t.imageUrl;
      if ((n = s == null ? void 0 : s.assets) != null && n.imageId)
        return gs.state.networkImages[s.assets.imageId];
    },
    getNetworkImageById(s) {
      if (s) return gs.state.networkImages[s];
    },
    getConnectorImage(s) {
      var e;
      if (s != null && s.imageUrl) return s.imageUrl;
      if ((e = s == null ? void 0 : s.info) != null && e.icon)
        return s.info.icon;
      if (s != null && s.imageId) return gs.state.connectorImages[s.imageId];
    },
    getChainImage(s) {
      return gs.state.networkImages[zm[s]];
    },
  },
  on = qe({ message: "", variant: "info", open: !1 }),
  Vm = {
    state: on,
    subscribeKey(s, e) {
      return Ct(on, s, e);
    },
    open(s, e) {
      const { debug: t } = R.state,
        { shortMessage: n, longMessage: r } = s;
      t && ((on.message = n), (on.variant = e), (on.open = !0)),
        r && console.error(typeof r == "function" ? r() : r);
    },
    close() {
      (on.open = !1), (on.message = ""), (on.variant = "info");
    },
  },
  tt = Zt(Vm),
  Km = ne.getAnalyticsUrl(),
  Gm = new So({ baseUrl: Km, clientId: null }),
  Ym = ["MODAL_CREATED"],
  qs = qe({
    timestamp: Date.now(),
    reportedErrors: {},
    data: { type: "track", event: "MODAL_CREATED" },
  }),
  Ue = {
    state: qs,
    subscribe(s) {
      return ft(qs, () => s(qs));
    },
    getSdkProperties() {
      const { projectId: s, sdkType: e, sdkVersion: t } = R.state;
      return { projectId: s, st: e, sv: t || "html-wagmi-4.2.2" };
    },
    async _sendAnalyticsEvent(s) {
      try {
        const e = se.state.address;
        if (Ym.includes(s.data.event) || typeof window > "u") return;
        await Gm.post({
          path: "/e",
          params: Ue.getSdkProperties(),
          body: {
            eventId: ne.getUUID(),
            url: window.location.href,
            domain: window.location.hostname,
            timestamp: s.timestamp,
            props: { ...s.data, address: e },
          },
        }),
          (qs.reportedErrors.FORBIDDEN = !1);
      } catch (e) {
        e instanceof Error &&
          e.cause instanceof Response &&
          e.cause.status === S.HTTP_STATUS_CODES.FORBIDDEN &&
          !qs.reportedErrors.FORBIDDEN &&
          (tt.open(
            {
              shortMessage: "Invalid App Configuration",
              longMessage: `Origin ${
                Ri() ? window.origin : "uknown"
              } not found on Allowlist - update configuration on cloud.reown.com`,
            },
            "error"
          ),
          (qs.reportedErrors.FORBIDDEN = !0));
      }
    },
    sendEvent(s) {
      var e;
      (qs.timestamp = Date.now()),
        (qs.data = s),
        (e = R.state.features) != null &&
          e.analytics &&
          Ue._sendAnalyticsEvent(qs);
    },
  },
  Zm = ne.getApiUrl(),
  Tt = new So({ baseUrl: Zm, clientId: null }),
  Jm = 40,
  Td = 4,
  Xm = 20,
  fe = qe({
    promises: {},
    page: 1,
    count: 0,
    featured: [],
    allFeatured: [],
    recommended: [],
    allRecommended: [],
    wallets: [],
    filteredWallets: [],
    search: [],
    isAnalyticsEnabled: !1,
    excludedWallets: [],
    isFetchingRecommendedWallets: !1,
  }),
  re = {
    state: fe,
    subscribeKey(s, e) {
      return Ct(fe, s, e);
    },
    _getSdkProperties() {
      const { projectId: s, sdkType: e, sdkVersion: t } = R.state;
      return { projectId: s, st: e || "appkit", sv: t || "html-wagmi-4.2.2" };
    },
    _filterOutExtensions(s) {
      return R.state.isUniversalProvider
        ? s.filter((e) => !!(e.mobile_link || e.desktop_link || e.webapp_link))
        : s;
    },
    async _fetchWalletImage(s) {
      const e = `${Tt.baseUrl}/getWalletImage/${s}`,
        t = await Tt.getBlob({ path: e, params: re._getSdkProperties() });
      gs.setWalletImage(s, URL.createObjectURL(t));
    },
    async _fetchNetworkImage(s) {
      const e = `${Tt.baseUrl}/public/getAssetImage/${s}`,
        t = await Tt.getBlob({ path: e, params: re._getSdkProperties() });
      gs.setNetworkImage(s, URL.createObjectURL(t));
    },
    async _fetchConnectorImage(s) {
      const e = `${Tt.baseUrl}/public/getAssetImage/${s}`,
        t = await Tt.getBlob({ path: e, params: re._getSdkProperties() });
      gs.setConnectorImage(s, URL.createObjectURL(t));
    },
    async _fetchCurrencyImage(s) {
      const e = `${Tt.baseUrl}/public/getCurrencyImage/${s}`,
        t = await Tt.getBlob({ path: e, params: re._getSdkProperties() });
      gs.setCurrencyImage(s, URL.createObjectURL(t));
    },
    async _fetchTokenImage(s) {
      const e = `${Tt.baseUrl}/public/getTokenImage/${s}`,
        t = await Tt.getBlob({ path: e, params: re._getSdkProperties() });
      gs.setTokenImage(s, URL.createObjectURL(t));
    },
    _filterWalletsByPlatform(s) {
      return ne.isMobile()
        ? s == null
          ? void 0
          : s.filter((t) =>
              t.mobile_link || t.id === Ps.COINBASE.id
                ? !0
                : y.state.activeChain === "solana" &&
                  (t.id === Ps.SOLFLARE.id || t.id === Ps.PHANTOM.id)
            )
        : s;
    },
    async fetchProjectConfig() {
      return (
        await Tt.get({
          path: "/appkit/v1/config",
          params: re._getSdkProperties(),
        })
      ).features;
    },
    async fetchAllowedOrigins() {
      try {
        const { allowedOrigins: s } = await Tt.get({
          path: "/projects/v1/origins",
          params: re._getSdkProperties(),
        });
        return s;
      } catch (s) {
        if (s instanceof Error && s.cause instanceof Response) {
          const e = s.cause.status;
          if (e === S.HTTP_STATUS_CODES.TOO_MANY_REQUESTS)
            throw new Error("RATE_LIMITED", { cause: s });
          if (e >= S.HTTP_STATUS_CODES.SERVER_ERROR && e < 600)
            throw new Error("SERVER_ERROR", { cause: s });
          return [];
        }
        return [];
      }
    },
    async fetchNetworkImages() {
      const s = y.getAllRequestedCaipNetworks(),
        e =
          s == null
            ? void 0
            : s
                .map(({ assets: t }) => (t == null ? void 0 : t.imageId))
                .filter(Boolean)
                .filter((t) => !lp.getNetworkImageById(t));
      e && (await Promise.allSettled(e.map((t) => re._fetchNetworkImage(t))));
    },
    async fetchConnectorImages() {
      const { connectors: s } = q.state,
        e = s.map(({ imageId: t }) => t).filter(Boolean);
      await Promise.allSettled(e.map((t) => re._fetchConnectorImage(t)));
    },
    async fetchCurrencyImages(s = []) {
      await Promise.allSettled(s.map((e) => re._fetchCurrencyImage(e)));
    },
    async fetchTokenImages(s = []) {
      await Promise.allSettled(s.map((e) => re._fetchTokenImage(e)));
    },
    async fetchWallets(s) {
      var i;
      const e = s.exclude ?? [];
      re._getSdkProperties().sv.startsWith("html-core-") &&
        e.push(...Object.values(Ps).map((o) => o.id));
      const n = await Tt.get({
        path: "/getWallets",
        params: {
          ...re._getSdkProperties(),
          ...s,
          page: String(s.page),
          entries: String(s.entries),
          include: (i = s.include) == null ? void 0 : i.join(","),
          exclude: e.join(","),
        },
      });
      return {
        data: re._filterWalletsByPlatform(n == null ? void 0 : n.data) || [],
        count: n == null ? void 0 : n.count,
      };
    },
    async fetchFeaturedWallets() {
      const { featuredWalletIds: s } = R.state;
      if (s != null && s.length) {
        const e = {
            ...re._getSdkProperties(),
            page: 1,
            entries: (s == null ? void 0 : s.length) ?? Td,
            include: s,
          },
          { data: t } = await re.fetchWallets(e),
          n = [...t].sort((i, o) => s.indexOf(i.id) - s.indexOf(o.id)),
          r = n.map((i) => i.image_id).filter(Boolean);
        await Promise.allSettled(r.map((i) => re._fetchWalletImage(i))),
          (fe.featured = n),
          (fe.allFeatured = n);
      }
    },
    async fetchRecommendedWallets() {
      try {
        fe.isFetchingRecommendedWallets = !0;
        const {
            includeWalletIds: s,
            excludeWalletIds: e,
            featuredWalletIds: t,
          } = R.state,
          n = [...(e ?? []), ...(t ?? [])].filter(Boolean),
          r = y.getRequestedCaipNetworkIds().join(","),
          i = { page: 1, entries: Td, include: s, exclude: n, chains: r },
          { data: o, count: a } = await re.fetchWallets(i),
          c = M.getRecentWallets(),
          l = o.map((u) => u.image_id).filter(Boolean),
          d = c.map((u) => u.image_id).filter(Boolean);
        await Promise.allSettled(
          [...l, ...d].map((u) => re._fetchWalletImage(u))
        ),
          (fe.recommended = o),
          (fe.allRecommended = o),
          (fe.count = a ?? 0);
      } catch {
      } finally {
        fe.isFetchingRecommendedWallets = !1;
      }
    },
    async fetchWalletsByPage({ page: s }) {
      const {
          includeWalletIds: e,
          excludeWalletIds: t,
          featuredWalletIds: n,
        } = R.state,
        r = y.getRequestedCaipNetworkIds().join(","),
        i = [
          ...fe.recommended.map(({ id: d }) => d),
          ...(t ?? []),
          ...(n ?? []),
        ].filter(Boolean),
        o = { page: s, entries: Jm, include: e, exclude: i, chains: r },
        { data: a, count: c } = await re.fetchWallets(o),
        l = a
          .slice(0, Xm)
          .map((d) => d.image_id)
          .filter(Boolean);
      await Promise.allSettled(l.map((d) => re._fetchWalletImage(d))),
        (fe.wallets = ne
          .uniqueBy([...fe.wallets, ...re._filterOutExtensions(a)], "id")
          .filter((d) => {
            var u;
            return (u = d.chains) == null
              ? void 0
              : u.some((p) => r.includes(p));
          })),
        (fe.count = c > fe.count ? c : fe.count),
        (fe.page = s);
    },
    async initializeExcludedWallets({ ids: s }) {
      const e = { page: 1, entries: s.length, include: s },
        { data: t } = await re.fetchWallets(e);
      t &&
        t.forEach((n) => {
          fe.excludedWallets.push({ rdns: n.rdns, name: n.name });
        });
    },
    async searchWallet({ search: s, badge: e }) {
      const { includeWalletIds: t, excludeWalletIds: n } = R.state,
        r = y.getRequestedCaipNetworkIds().join(",");
      fe.search = [];
      const i = {
          page: 1,
          entries: 100,
          search: s == null ? void 0 : s.trim(),
          badge_type: e,
          include: t,
          exclude: n,
          chains: r,
        },
        { data: o } = await re.fetchWallets(i);
      Ue.sendEvent({
        type: "track",
        event: "SEARCH_WALLET",
        properties: { badge: e ?? "", search: s ?? "" },
      });
      const a = o.map((c) => c.image_id).filter(Boolean);
      await Promise.allSettled([
        ...a.map((c) => re._fetchWalletImage(c)),
        ne.wait(300),
      ]),
        (fe.search = re._filterOutExtensions(o));
    },
    initPromise(s, e) {
      const t = fe.promises[s];
      return t || (fe.promises[s] = e());
    },
    prefetch({
      fetchConnectorImages: s = !0,
      fetchFeaturedWallets: e = !0,
      fetchRecommendedWallets: t = !0,
      fetchNetworkImages: n = !0,
    } = {}) {
      const r = [
        s && re.initPromise("connectorImages", re.fetchConnectorImages),
        e && re.initPromise("featuredWallets", re.fetchFeaturedWallets),
        t && re.initPromise("recommendedWallets", re.fetchRecommendedWallets),
        n && re.initPromise("networkImages", re.fetchNetworkImages),
      ].filter(Boolean);
      return Promise.allSettled(r);
    },
    prefetchAnalyticsConfig() {
      var s;
      (s = R.state.features) != null &&
        s.analytics &&
        re.fetchAnalyticsConfig();
    },
    async fetchAnalyticsConfig() {
      try {
        const { isAnalyticsEnabled: s } = await Tt.get({
          path: "/getAnalyticsConfig",
          params: re._getSdkProperties(),
        });
        R.setFeatures({ analytics: s });
      } catch {
        R.setFeatures({ analytics: !1 });
      }
    },
    filterByNamespaces(s) {
      if (!(s != null && s.length)) {
        (fe.featured = fe.allFeatured), (fe.recommended = fe.allRecommended);
        return;
      }
      const e = y.getRequestedCaipNetworkIds().join(",");
      (fe.featured = fe.allFeatured.filter((t) => {
        var n;
        return (n = t.chains) == null ? void 0 : n.some((r) => e.includes(r));
      })),
        (fe.recommended = fe.allRecommended.filter((t) => {
          var n;
          return (n = t.chains) == null ? void 0 : n.some((r) => e.includes(r));
        })),
        (fe.filteredWallets = fe.wallets.filter((t) => {
          var n;
          return (n = t.chains) == null ? void 0 : n.some((r) => e.includes(r));
        }));
    },
    clearFilterByNamespaces() {
      fe.filteredWallets = [];
    },
    setFilterByNamespace(s) {
      if (!s) {
        (fe.featured = fe.allFeatured), (fe.recommended = fe.allRecommended);
        return;
      }
      const e = y.getRequestedCaipNetworkIds().join(",");
      (fe.featured = fe.allFeatured.filter((t) => {
        var n;
        return (n = t.chains) == null ? void 0 : n.some((r) => e.includes(r));
      })),
        (fe.recommended = fe.allRecommended.filter((t) => {
          var n;
          return (n = t.chains) == null ? void 0 : n.some((r) => e.includes(r));
        })),
        (fe.filteredWallets = fe.wallets.filter((t) => {
          var n;
          return (n = t.chains) == null ? void 0 : n.some((r) => e.includes(r));
        }));
    },
  },
  De = qe({ view: "Connect", history: ["Connect"], transactionStack: [] }),
  Qm = {
    state: De,
    subscribeKey(s, e) {
      return Ct(De, s, e);
    },
    pushTransactionStack(s) {
      De.transactionStack.push(s);
    },
    popTransactionStack(s) {
      const e = De.transactionStack.pop();
      if (!e) return;
      const { onSuccess: t, onError: n, onCancel: r } = e;
      switch (s) {
        case "success":
          t == null || t();
          break;
        case "error":
          n == null || n(), de.goBack();
          break;
        case "cancel":
          r == null || r(), de.goBack();
          break;
      }
    },
    push(s, e) {
      s !== De.view && ((De.view = s), De.history.push(s), (De.data = e));
    },
    reset(s, e) {
      (De.view = s), (De.history = [s]), (De.data = e);
    },
    replace(s, e) {
      De.history.at(-1) === s ||
        ((De.view = s), (De.history[De.history.length - 1] = s), (De.data = e));
    },
    goBack() {
      var n;
      const s = y.state.activeCaipAddress,
        e = de.state.view === "ConnectingFarcaster",
        t = !s && e;
      if (De.history.length > 1) {
        De.history.pop();
        const [r] = De.history.slice(-1);
        r && (s && r === "Connect" ? (De.view = "Account") : (De.view = r));
      } else Ne.close();
      (n = De.data) != null && n.wallet && (De.data.wallet = void 0),
        setTimeout(() => {
          var r, i, o;
          if (t) {
            se.setFarcasterUrl(void 0, y.state.activeChain);
            const a = q.getAuthConnector();
            (r = a == null ? void 0 : a.provider) == null || r.reload();
            const c = Xi(R.state);
            (o =
              (i = a == null ? void 0 : a.provider) == null
                ? void 0
                : i.syncDappData) == null ||
              o.call(i, {
                metadata: c.metadata,
                sdkVersion: c.sdkVersion,
                projectId: c.projectId,
                sdkType: c.sdkType,
              });
          }
        }, 100);
    },
    goBackToIndex(s) {
      if (De.history.length > 1) {
        De.history = De.history.slice(0, s + 1);
        const [e] = De.history.slice(-1);
        e && (De.view = e);
      }
    },
    goBackOrCloseModal() {
      de.state.history.length > 1 ? de.goBack() : Ne.close();
    },
  },
  de = Zt(Qm),
  Hs = qe({ themeMode: "dark", themeVariables: {}, w3mThemeVariables: void 0 }),
  Wc = {
    state: Hs,
    subscribe(s) {
      return ft(Hs, () => s(Hs));
    },
    setThemeMode(s) {
      Hs.themeMode = s;
      try {
        const e = q.getAuthConnector();
        if (e) {
          const t = Wc.getSnapshot().themeVariables;
          e.provider.syncTheme({
            themeMode: s,
            themeVariables: t,
            w3mThemeVariables: Zs(t, s),
          });
        }
      } catch {
        console.info("Unable to sync theme to auth connector");
      }
    },
    setThemeVariables(s) {
      Hs.themeVariables = { ...Hs.themeVariables, ...s };
      try {
        const e = q.getAuthConnector();
        if (e) {
          const t = Wc.getSnapshot().themeVariables;
          e.provider.syncTheme({
            themeVariables: t,
            w3mThemeVariables: Zs(Hs.themeVariables, Hs.themeMode),
          });
        }
      } catch {
        console.info("Unable to sync theme to auth connector");
      }
    },
    getSnapshot() {
      return Xi(Hs);
    },
  },
  $t = Zt(Wc),
  dp = {
    eip155: void 0,
    solana: void 0,
    polkadot: void 0,
    bip122: void 0,
    cosmos: void 0,
  },
  Ae = qe({
    allConnectors: [],
    connectors: [],
    activeConnector: void 0,
    filterByNamespace: void 0,
    activeConnectorIds: { ...dp },
    filterByNamespaceMap: {
      eip155: !0,
      solana: !0,
      polkadot: !0,
      bip122: !0,
      cosmos: !0,
    },
  }),
  ew = {
    state: Ae,
    subscribe(s) {
      return ft(Ae, () => {
        s(Ae);
      });
    },
    subscribeKey(s, e) {
      return Ct(Ae, s, e);
    },
    initialize(s) {
      s.forEach((e) => {
        const t = M.getConnectedConnectorId(e);
        t && q.setConnectorId(t, e);
      });
    },
    setActiveConnector(s) {
      s && (Ae.activeConnector = Qn(s));
    },
    setConnectors(s) {
      s.filter(
        (r) =>
          !Ae.allConnectors.some(
            (i) =>
              i.id === r.id &&
              q.getConnectorName(i.name) === q.getConnectorName(r.name) &&
              i.chain === r.chain
          )
      ).forEach((r) => {
        r.type !== "MULTI_CHAIN" && Ae.allConnectors.push(Qn(r));
      });
      const t = q.getEnabledNamespaces(),
        n = q.getEnabledConnectors(t);
      Ae.connectors = q.mergeMultiChainConnectors(n);
    },
    filterByNamespaces(s) {
      Object.keys(Ae.filterByNamespaceMap).forEach((e) => {
        Ae.filterByNamespaceMap[e] = !1;
      }),
        s.forEach((e) => {
          Ae.filterByNamespaceMap[e] = !0;
        }),
        q.updateConnectorsForEnabledNamespaces();
    },
    filterByNamespace(s, e) {
      (Ae.filterByNamespaceMap[s] = e),
        q.updateConnectorsForEnabledNamespaces();
    },
    updateConnectorsForEnabledNamespaces() {
      const s = q.getEnabledNamespaces(),
        e = q.getEnabledConnectors(s),
        t = q.areAllNamespacesEnabled();
      (Ae.connectors = q.mergeMultiChainConnectors(e)),
        t ? re.clearFilterByNamespaces() : re.filterByNamespaces(s);
    },
    getEnabledNamespaces() {
      return Object.entries(Ae.filterByNamespaceMap)
        .filter(([s, e]) => e)
        .map(([s]) => s);
    },
    getEnabledConnectors(s) {
      return Ae.allConnectors.filter((e) => s.includes(e.chain));
    },
    areAllNamespacesEnabled() {
      return Object.values(Ae.filterByNamespaceMap).every((s) => s);
    },
    mergeMultiChainConnectors(s) {
      const e = q.generateConnectorMapByName(s),
        t = [];
      return (
        e.forEach((n) => {
          const r = n[0],
            i = (r == null ? void 0 : r.id) === S.CONNECTOR_ID.AUTH;
          n.length > 1 && r
            ? t.push({
                name: r.name,
                imageUrl: r.imageUrl,
                imageId: r.imageId,
                connectors: [...n],
                type: i ? "AUTH" : "MULTI_CHAIN",
                chain: "eip155",
                id: (r == null ? void 0 : r.id) || "",
              })
            : r && t.push(r);
        }),
        t
      );
    },
    generateConnectorMapByName(s) {
      const e = new Map();
      return (
        s.forEach((t) => {
          const { name: n } = t,
            r = q.getConnectorName(n);
          if (!r) return;
          const i = e.get(r) || [];
          i.find((a) => a.chain === t.chain) || i.push(t), e.set(r, i);
        }),
        e
      );
    },
    getConnectorName(s) {
      return s && ({ "Trust Wallet": "Trust" }[s] || s);
    },
    getUniqueConnectorsByName(s) {
      const e = [];
      return (
        s.forEach((t) => {
          e.find((n) => n.chain === t.chain) || e.push(t);
        }),
        e
      );
    },
    addConnector(s) {
      var e, t, n;
      if (s.id === S.CONNECTOR_ID.AUTH) {
        const r = s,
          i = Xi(R.state),
          o = $t.getSnapshot().themeMode,
          a = $t.getSnapshot().themeVariables;
        (t =
          (e = r == null ? void 0 : r.provider) == null
            ? void 0
            : e.syncDappData) == null ||
          t.call(e, {
            metadata: i.metadata,
            sdkVersion: i.sdkVersion,
            projectId: i.projectId,
            sdkType: i.sdkType,
          }),
          (n = r == null ? void 0 : r.provider) == null ||
            n.syncTheme({
              themeMode: o,
              themeVariables: a,
              w3mThemeVariables: Zs(a, o),
            }),
          q.setConnectors([s]);
      } else q.setConnectors([s]);
    },
    getAuthConnector(s) {
      var n;
      const e = s || y.state.activeChain,
        t = Ae.connectors.find((r) => r.id === S.CONNECTOR_ID.AUTH);
      if (t)
        return (n = t == null ? void 0 : t.connectors) != null && n.length
          ? t.connectors.find((i) => i.chain === e)
          : t;
    },
    getAnnouncedConnectorRdns() {
      return Ae.connectors
        .filter((s) => s.type === "ANNOUNCED")
        .map((s) => {
          var e;
          return (e = s.info) == null ? void 0 : e.rdns;
        });
    },
    getConnectorById(s) {
      return Ae.allConnectors.find((e) => e.id === s);
    },
    getConnector(s, e) {
      return Ae.allConnectors
        .filter((n) => n.chain === y.state.activeChain)
        .find((n) => {
          var r;
          return (
            n.explorerId === s || ((r = n.info) == null ? void 0 : r.rdns) === e
          );
        });
    },
    syncIfAuthConnector(s) {
      var i, o;
      if (s.id !== "ID_AUTH") return;
      const e = s,
        t = Xi(R.state),
        n = $t.getSnapshot().themeMode,
        r = $t.getSnapshot().themeVariables;
      (o =
        (i = e == null ? void 0 : e.provider) == null
          ? void 0
          : i.syncDappData) == null ||
        o.call(i, {
          metadata: t.metadata,
          sdkVersion: t.sdkVersion,
          sdkType: t.sdkType,
          projectId: t.projectId,
        }),
        e.provider.syncTheme({
          themeMode: n,
          themeVariables: r,
          w3mThemeVariables: Zs(r, n),
        });
    },
    getConnectorsByNamespace(s) {
      const e = Ae.allConnectors.filter((t) => t.chain === s);
      return q.mergeMultiChainConnectors(e);
    },
    canSwitchToSmartAccount(s) {
      return y.checkIfSmartAccountEnabled() && Cs(s) === nt.ACCOUNT_TYPES.EOA;
    },
    selectWalletConnector(s) {
      const e = q.getConnector(s.id, s.rdns);
      Hm.handleMobileDeeplinkRedirect(
        (e == null ? void 0 : e.explorerId) || s.id,
        y.state.activeChain
      ),
        e
          ? de.push("ConnectingExternal", { connector: e })
          : de.push("ConnectingWalletConnect", { wallet: s });
    },
    getConnectors(s) {
      return s
        ? q.getConnectorsByNamespace(s)
        : q.mergeMultiChainConnectors(Ae.allConnectors);
    },
    setFilterByNamespace(s) {
      (Ae.filterByNamespace = s),
        (Ae.connectors = q.getConnectors(s)),
        re.setFilterByNamespace(s);
    },
    setConnectorId(s, e) {
      s &&
        ((Ae.activeConnectorIds = { ...Ae.activeConnectorIds, [e]: s }),
        M.setConnectedConnectorId(e, s));
    },
    removeConnectorId(s) {
      (Ae.activeConnectorIds = { ...Ae.activeConnectorIds, [s]: void 0 }),
        M.deleteConnectedConnectorId(s);
    },
    getConnectorId(s) {
      if (s) return Ae.activeConnectorIds[s];
    },
    isConnected(s) {
      return s
        ? !!Ae.activeConnectorIds[s]
        : Object.values(Ae.activeConnectorIds).some((e) => !!e);
    },
    resetConnectorIds() {
      Ae.activeConnectorIds = { ...dp };
    },
  },
  q = Zt(ew),
  tw = 1e3,
  hi = {
    checkNamespaceConnectorId(s, e) {
      return q.getConnectorId(s) === e;
    },
    isSocialProvider(s) {
      return Pe.DEFAULT_REMOTE_FEATURES.socials.includes(s);
    },
    connectWalletConnect({
      walletConnect: s,
      connector: e,
      closeModalOnConnect: t = !0,
      redirectViewOnModalClose: n = "Connect",
      onOpen: r,
      onConnect: i,
    }) {
      return new Promise((o, a) => {
        if (
          (s && q.setActiveConnector(e), r == null || r(ne.isMobile() && s), n)
        ) {
          const l = Ne.subscribeKey("open", (d) => {
            d ||
              (de.state.view !== n && de.replace(n),
              l(),
              a(new Error("Modal closed")));
          });
        }
        const c = y.subscribeKey("activeCaipAddress", (l) => {
          l &&
            (i == null || i(), t && Ne.close(), c(), o(Mt.parseCaipAddress(l)));
        });
      });
    },
    connectExternal(s) {
      return new Promise((e, t) => {
        const n = y.subscribeKey("activeCaipAddress", (r) => {
          r && (Ne.close(), n(), e(Mt.parseCaipAddress(r)));
        });
        H.connectExternal(s, s.chain).catch(() => {
          n(), t(new Error("Connection rejected"));
        });
      });
    },
    connectSocial({
      social: s,
      closeModalOnConnect: e = !0,
      onOpenFarcaster: t,
      onConnect: n,
    }) {
      let r = se.state.socialWindow,
        i = se.state.socialProvider,
        o = !1,
        a = null;
      const c = y.subscribeKey("activeCaipAddress", (l) => {
        l && (e && Ne.close(), c());
      });
      return new Promise((l, d) => {
        async function u(w) {
          var g;
          if ((g = w.data) != null && g.resultUri)
            if (w.origin === S.SECURE_SITE_SDK_ORIGIN) {
              window.removeEventListener("message", u, !1);
              try {
                const m = q.getAuthConnector();
                if (m && !o) {
                  r &&
                    (r.close(),
                    se.setSocialWindow(void 0, y.state.activeChain),
                    (r = se.state.socialWindow)),
                    (o = !0);
                  const f = w.data.resultUri;
                  i &&
                    Ue.sendEvent({
                      type: "track",
                      event: "SOCIAL_LOGIN_REQUEST_USER_DATA",
                      properties: { provider: i },
                    });
                  const E = y.state.activeCaipNetwork;
                  if (
                    (await m.provider.connectSocial({
                      uri: f,
                      chainId: E == null ? void 0 : E.caipNetworkId,
                    }),
                    i)
                  ) {
                    M.setConnectedSocialProvider(i),
                      await H.connectExternal(
                        { id: m.id, type: m.type, socialUri: f },
                        m.chain
                      );
                    const b = y.state.activeCaipAddress;
                    if (!b) {
                      d(new Error("Failed to connect"));
                      return;
                    }
                    l(Mt.parseCaipAddress(b)),
                      Ue.sendEvent({
                        type: "track",
                        event: "SOCIAL_LOGIN_SUCCESS",
                        properties: { provider: i },
                      });
                  }
                }
              } catch {
                i &&
                  Ue.sendEvent({
                    type: "track",
                    event: "SOCIAL_LOGIN_ERROR",
                    properties: { provider: i },
                  }),
                  d(new Error("Failed to connect"));
              }
            } else
              i &&
                Ue.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_ERROR",
                  properties: { provider: i },
                });
        }
        async function p() {
          if (
            (s &&
              (se.setSocialProvider(s, y.state.activeChain),
              (i = se.state.socialProvider),
              Ue.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_STARTED",
                properties: { provider: i },
              })),
            i === "farcaster")
          ) {
            t == null || t();
            const w = Ne.subscribeKey("open", (m) => {
                !m &&
                  s === "farcaster" &&
                  (d(new Error("Popup closed")), n == null || n(), w());
              }),
              g = q.getAuthConnector();
            if (g && !se.state.farcasterUrl)
              try {
                const { url: m } = await g.provider.getFarcasterUri();
                se.setFarcasterUrl(m, y.state.activeChain);
              } catch {
                d(new Error("Failed to connect to farcaster"));
              }
          } else {
            const w = q.getAuthConnector();
            a = ne.returnOpenHref(
              `${S.SECURE_SITE_SDK_ORIGIN}/loading`,
              "popupWindow",
              "width=600,height=800,scrollbars=yes"
            );
            try {
              if (w && i) {
                const { uri: g } = await w.provider.getSocialRedirectUri({
                  provider: i,
                });
                if (a && g) {
                  se.setSocialWindow(a, y.state.activeChain),
                    (r = se.state.socialWindow),
                    (a.location.href = g);
                  const m = setInterval(() => {
                    r != null &&
                      r.closed &&
                      !o &&
                      (d(new Error("Popup closed")), clearInterval(m));
                  }, 1e3);
                  window.addEventListener("message", u, !1);
                } else
                  a == null || a.close(),
                    d(new Error("Failed to initiate social connection"));
              }
            } catch {
              d(new Error("Failed to initiate social connection")),
                a == null || a.close();
            }
          }
        }
        p();
      });
    },
    connectEmail({
      closeModalOnConnect: s = !0,
      redirectViewOnModalClose: e = "Connect",
      onOpen: t,
      onConnect: n,
    }) {
      return new Promise((r, i) => {
        if ((t == null || t(), e)) {
          const a = Ne.subscribeKey("open", (c) => {
            c ||
              (de.state.view !== e && de.replace(e),
              a(),
              i(new Error("Modal closed")));
          });
        }
        const o = y.subscribeKey("activeCaipAddress", (a) => {
          a &&
            (n == null || n(), s && Ne.close(), o(), r(Mt.parseCaipAddress(a)));
        });
      });
    },
    async updateEmail() {
      const s = M.getConnectedConnectorId(y.state.activeChain),
        e = q.getAuthConnector();
      if (!e) throw new Error("No auth connector found");
      if (s !== S.CONNECTOR_ID.AUTH)
        throw new Error("Not connected to email or social");
      const t = e.provider.getEmail() ?? "";
      return (
        de.push("UpdateEmailWallet", { email: t, redirectView: void 0 }),
        new Promise((n, r) => {
          const i = setInterval(() => {
              const a = e.provider.getEmail() ?? "";
              a !== t && (Ne.close(), clearInterval(i), o(), n({ email: a }));
            }, tw),
            o = Ne.subscribeKey("open", (a) => {
              a ||
                (de.state.view !== "Connect" && de.push("Connect"),
                clearInterval(i),
                o(),
                r(new Error("Modal closed")));
            });
        })
      );
    },
    canSwitchToSmartAccount(s) {
      return y.checkIfSmartAccountEnabled() && Cs(s) === nt.ACCOUNT_TYPES.EOA;
    },
  };
function up() {
  var n, r;
  const s =
      ((n = y.state.activeCaipNetwork) == null ? void 0 : n.chainNamespace) ||
      "eip155",
    e = ((r = y.state.activeCaipNetwork) == null ? void 0 : r.id) || 1,
    t = Pe.NATIVE_TOKEN_ADDRESS[s];
  return `${s}:${e}:${t}`;
}
function Cs(s) {
  var t;
  return (t = y.getAccountData(s)) == null ? void 0 : t.preferredAccountType;
}
const da = {
    getConnectionStatus(s, e) {
      const t = q.state.activeConnectorIds[e],
        n = H.getConnections(e);
      return !!t && s.connectorId === t
        ? "connected"
        : n.some(
            (o) => o.connectorId.toLowerCase() === s.connectorId.toLowerCase()
          )
        ? "active"
        : "disconnected";
    },
    excludeConnectorAddressFromConnections({
      connections: s,
      connectorId: e,
      addresses: t,
    }) {
      return s.map((n) => {
        if ((e ? n.connectorId.toLowerCase() === e.toLowerCase() : !1) && t) {
          const i = n.accounts.filter(
            (o) => !t.some((c) => c.toLowerCase() === o.address.toLowerCase())
          );
          return { ...n, accounts: i };
        }
        return n;
      });
    },
    excludeExistingConnections(s, e) {
      const t = new Set(s);
      return e.filter((n) => !t.has(n.connectorId));
    },
    getConnectionsByConnectorId(s, e) {
      return s.filter((t) => t.connectorId.toLowerCase() === e.toLowerCase());
    },
    getConnectionsData(s) {
      var a;
      const e = !!((a = R.state.remoteFeatures) != null && a.multiWallet),
        t = q.state.activeConnectorIds[s],
        n = H.getConnections(s),
        i = (H.state.recentConnections.get(s) ?? []).filter((c) =>
          q.getConnectorById(c.connectorId)
        ),
        o = da.excludeExistingConnections(
          [...n.map((c) => c.connectorId), ...(t ? [t] : [])],
          i
        );
      return e
        ? { connections: n, recentConnections: o }
        : {
            connections: n.filter(
              (c) =>
                c.connectorId.toLowerCase() ===
                (t == null ? void 0 : t.toLowerCase())
            ),
            recentConnections: [],
          };
    },
  },
  Fn = Object.freeze({
    message: "",
    variant: "success",
    svg: void 0,
    open: !1,
    autoClose: !0,
  }),
  Qe = qe({ ...Fn }),
  sw = {
    state: Qe,
    subscribeKey(s, e) {
      return Ct(Qe, s, e);
    },
    showLoading(s, e = {}) {
      this._showMessage({ message: s, variant: "loading", ...e });
    },
    showSuccess(s) {
      this._showMessage({ message: s, variant: "success" });
    },
    showSvg(s, e) {
      this._showMessage({ message: s, svg: e });
    },
    showError(s) {
      const e = ne.parseError(s);
      this._showMessage({ message: e, variant: "error" });
    },
    hide() {
      (Qe.message = Fn.message),
        (Qe.variant = Fn.variant),
        (Qe.svg = Fn.svg),
        (Qe.open = Fn.open),
        (Qe.autoClose = Fn.autoClose);
    },
    _showMessage({
      message: s,
      svg: e,
      variant: t = "success",
      autoClose: n = Fn.autoClose,
    }) {
      Qe.open
        ? ((Qe.open = !1),
          setTimeout(() => {
            (Qe.message = s),
              (Qe.variant = t),
              (Qe.svg = e),
              (Qe.open = !0),
              (Qe.autoClose = n);
          }, 150))
        : ((Qe.message = s),
          (Qe.variant = t),
          (Qe.svg = e),
          (Qe.open = !0),
          (Qe.autoClose = n));
    },
  },
  ks = sw,
  Fe = qe({
    transactions: [],
    coinbaseTransactions: {},
    transactionsByYear: {},
    lastNetworkInView: void 0,
    loading: !1,
    empty: !1,
    next: void 0,
  }),
  nw = {
    state: Fe,
    subscribe(s) {
      return ft(Fe, () => s(Fe));
    },
    setLastNetworkInView(s) {
      Fe.lastNetworkInView = s;
    },
    async fetchTransactions(s, e) {
      var t;
      if (!s)
        throw new Error(
          "Transactions can't be fetched without an accountAddress"
        );
      Fe.loading = !0;
      try {
        const n = await ae.fetchTransactions({
            account: s,
            cursor: Fe.next,
            onramp: e,
            cache: e === "coinbase" ? "no-cache" : void 0,
            chainId:
              (t = y.state.activeCaipNetwork) == null
                ? void 0
                : t.caipNetworkId,
          }),
          r = xi.filterSpamTransactions(n.data),
          i = xi.filterByConnectedChain(r),
          o = [...Fe.transactions, ...i];
        (Fe.loading = !1),
          e === "coinbase"
            ? (Fe.coinbaseTransactions = xi.groupTransactionsByYearAndMonth(
                Fe.coinbaseTransactions,
                n.data
              ))
            : ((Fe.transactions = o),
              (Fe.transactionsByYear = xi.groupTransactionsByYearAndMonth(
                Fe.transactionsByYear,
                i
              ))),
          (Fe.empty = o.length === 0),
          (Fe.next = n.next ? n.next : void 0);
      } catch {
        const r = y.state.activeChain;
        Ue.sendEvent({
          type: "track",
          event: "ERROR_FETCH_TRANSACTIONS",
          properties: {
            address: s,
            projectId: R.state.projectId,
            cursor: Fe.next,
            isSmartAccount: Cs(r) === nt.ACCOUNT_TYPES.SMART_ACCOUNT,
          },
        }),
          ks.showError("Failed to fetch transactions"),
          (Fe.loading = !1),
          (Fe.empty = !0),
          (Fe.next = void 0);
      }
    },
    groupTransactionsByYearAndMonth(s = {}, e = []) {
      const t = s;
      return (
        e.forEach((n) => {
          const r = new Date(n.metadata.minedAt).getFullYear(),
            i = new Date(n.metadata.minedAt).getMonth(),
            o = t[r] ?? {},
            c = (o[i] ?? []).filter((l) => l.id !== n.id);
          t[r] = {
            ...o,
            [i]: [...c, n].sort(
              (l, d) =>
                new Date(d.metadata.minedAt).getTime() -
                new Date(l.metadata.minedAt).getTime()
            ),
          };
        }),
        t
      );
    },
    filterSpamTransactions(s) {
      return s.filter(
        (e) =>
          !e.transfers.every((n) => {
            var r;
            return ((r = n.nft_info) == null ? void 0 : r.flags.is_spam) === !0;
          })
      );
    },
    filterByConnectedChain(s) {
      var n;
      const e =
        (n = y.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId;
      return s.filter((r) => r.metadata.chain === e);
    },
    clearCursor() {
      Fe.next = void 0;
    },
    resetTransactions() {
      (Fe.transactions = []),
        (Fe.transactionsByYear = {}),
        (Fe.lastNetworkInView = void 0),
        (Fe.loading = !1),
        (Fe.empty = !1),
        (Fe.next = void 0);
    },
  },
  xi = Zt(nw, "API_ERROR"),
  Ce = qe({
    connections: new Map(),
    recentConnections: new Map(),
    isSwitchingConnection: !1,
    wcError: !1,
    buffering: !1,
    status: "disconnected",
  });
let Un;
const rw = {
    state: Ce,
    subscribe(s) {
      return ft(Ce, () => s(Ce));
    },
    subscribeKey(s, e) {
      return Ct(Ce, s, e);
    },
    _getClient() {
      return Ce._client;
    },
    setClient(s) {
      Ce._client = Qn(s);
    },
    initialize(s) {
      const e = s.filter((t) => !!t.namespace).map((t) => t.namespace);
      H.syncStorageConnections(e);
    },
    syncStorageConnections(s) {
      const e = M.getConnections(),
        t = s ?? Array.from(y.state.chains.keys());
      for (const n of t) {
        const r = e[n] ?? [],
          i = new Map(Ce.recentConnections);
        i.set(n, r), (Ce.recentConnections = i);
      }
    },
    getConnections(s) {
      return s ? Ce.connections.get(s) ?? [] : [];
    },
    hasAnyConnection(s) {
      const e = H.state.connections;
      return Array.from(e.values())
        .flatMap((t) => t)
        .some(({ connectorId: t }) => t === s);
    },
    async connectWalletConnect() {
      var s, e, t, n;
      if (ne.isTelegram() || (ne.isSafari() && ne.isIos())) {
        if (Un) {
          await Un, (Un = void 0);
          return;
        }
        if (!ne.isPairingExpired(Ce == null ? void 0 : Ce.wcPairingExpiry)) {
          const r = Ce.wcUri;
          Ce.wcUri = r;
          return;
        }
        (Un =
          (e =
            (s = H._getClient()) == null ? void 0 : s.connectWalletConnect) ==
          null
            ? void 0
            : e.call(s).catch(() => {})),
          (H.state.status = "connecting"),
          await Un,
          (Un = void 0),
          (Ce.wcPairingExpiry = void 0),
          (H.state.status = "connected");
      } else
        await ((n =
          (t = H._getClient()) == null ? void 0 : t.connectWalletConnect) ==
        null
          ? void 0
          : n.call(t));
    },
    async connectExternal(s, e, t = !0) {
      var r, i;
      const n = await ((i =
        (r = H._getClient()) == null ? void 0 : r.connectExternal) == null
        ? void 0
        : i.call(r, s));
      return t && y.setActiveNamespace(e), n;
    },
    async reconnectExternal(s) {
      var t, n;
      await ((n =
        (t = H._getClient()) == null ? void 0 : t.reconnectExternal) == null
        ? void 0
        : n.call(t, s));
      const e = s.chain || y.state.activeChain;
      e && q.setConnectorId(s.id, e);
    },
    async setPreferredAccountType(s, e) {
      var n;
      if (!e) return;
      Ne.setLoading(!0, y.state.activeChain);
      const t = q.getAuthConnector();
      t &&
        (se.setPreferredAccountType(s, e),
        await t.provider.setPreferredAccount(s),
        M.setPreferredAccountTypes(
          Object.entries(y.state.chains).reduce((r, [i, o]) => {
            const a = i,
              c = Cs(a);
            return c !== void 0 && (r[a] = c), r;
          }, {})
        ),
        await H.reconnectExternal(t),
        Ne.setLoading(!1, y.state.activeChain),
        Ue.sendEvent({
          type: "track",
          event: "SET_PREFERRED_ACCOUNT_TYPE",
          properties: {
            accountType: s,
            network:
              ((n = y.state.activeCaipNetwork) == null
                ? void 0
                : n.caipNetworkId) || "",
          },
        }));
    },
    async signMessage(s) {
      var e;
      return (e = H._getClient()) == null ? void 0 : e.signMessage(s);
    },
    parseUnits(s, e) {
      var t;
      return (t = H._getClient()) == null ? void 0 : t.parseUnits(s, e);
    },
    formatUnits(s, e) {
      var t;
      return (t = H._getClient()) == null ? void 0 : t.formatUnits(s, e);
    },
    async sendTransaction(s) {
      var e;
      return (e = H._getClient()) == null ? void 0 : e.sendTransaction(s);
    },
    async getCapabilities(s) {
      var e;
      return (e = H._getClient()) == null ? void 0 : e.getCapabilities(s);
    },
    async grantPermissions(s) {
      var e;
      return (e = H._getClient()) == null ? void 0 : e.grantPermissions(s);
    },
    async walletGetAssets(s) {
      var e;
      return (
        ((e = H._getClient()) == null ? void 0 : e.walletGetAssets(s)) ?? {}
      );
    },
    async estimateGas(s) {
      var e;
      return (e = H._getClient()) == null ? void 0 : e.estimateGas(s);
    },
    async writeContract(s) {
      var e;
      return (e = H._getClient()) == null ? void 0 : e.writeContract(s);
    },
    async getEnsAddress(s) {
      var e;
      return (e = H._getClient()) == null ? void 0 : e.getEnsAddress(s);
    },
    async getEnsAvatar(s) {
      var e;
      return (e = H._getClient()) == null ? void 0 : e.getEnsAvatar(s);
    },
    checkInstalled(s) {
      var e, t;
      return (
        ((t = (e = H._getClient()) == null ? void 0 : e.checkInstalled) == null
          ? void 0
          : t.call(e, s)) || !1
      );
    },
    resetWcConnection() {
      (Ce.wcUri = void 0),
        (Ce.wcPairingExpiry = void 0),
        (Ce.wcLinking = void 0),
        (Ce.recentWallet = void 0),
        (Ce.status = "disconnected"),
        xi.resetTransactions(),
        M.deleteWalletConnectDeepLink();
    },
    resetUri() {
      (Ce.wcUri = void 0), (Ce.wcPairingExpiry = void 0), (Un = void 0);
    },
    finalizeWcConnection() {
      var t, n;
      const { wcLinking: s, recentWallet: e } = H.state;
      s && M.setWalletConnectDeepLink(s),
        e && M.setAppKitRecent(e),
        Ue.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          properties: {
            method: s ? "mobile" : "qrcode",
            name:
              ((n = (t = de.state.data) == null ? void 0 : t.wallet) == null
                ? void 0
                : n.name) || "Unknown",
          },
        });
    },
    setWcBasic(s) {
      Ce.wcBasic = s;
    },
    setUri(s) {
      (Ce.wcUri = s), (Ce.wcPairingExpiry = ne.getPairingExpiry());
    },
    setWcLinking(s) {
      Ce.wcLinking = s;
    },
    setWcError(s) {
      (Ce.wcError = s), (Ce.buffering = !1);
    },
    setRecentWallet(s) {
      Ce.recentWallet = s;
    },
    setBuffering(s) {
      Ce.buffering = s;
    },
    setStatus(s) {
      Ce.status = s;
    },
    setIsSwitchingConnection(s) {
      Ce.isSwitchingConnection = s;
    },
    async disconnect({ id: s, namespace: e, initialDisconnect: t } = {}) {
      var n;
      try {
        await ((n = H._getClient()) == null
          ? void 0
          : n.disconnect({ id: s, chainNamespace: e, initialDisconnect: t }));
      } catch (r) {
        throw new Wr("Failed to disconnect", "INTERNAL_SDK_ERROR", r);
      }
    },
    setConnections(s, e) {
      const t = new Map(Ce.connections);
      t.set(e, s), (Ce.connections = t);
    },
    async handleAuthAccountSwitch({ address: s, namespace: e }) {
      var r, i;
      const t =
          (i = (r = se.state.user) == null ? void 0 : r.accounts) == null
            ? void 0
            : i.find((o) => o.type === "smartAccount"),
        n =
          t &&
          t.address.toLowerCase() === s.toLowerCase() &&
          hi.canSwitchToSmartAccount(e)
            ? "smartAccount"
            : "eoa";
      await H.setPreferredAccountType(n, e);
    },
    async handleActiveConnection({ connection: s, namespace: e, address: t }) {
      const n = q.getConnectorById(s.connectorId),
        r = s.connectorId === S.CONNECTOR_ID.AUTH;
      if (!n)
        throw new Error(`No connector found for connection: ${s.connectorId}`);
      if (r)
        r &&
          t &&
          (await H.handleAuthAccountSwitch({ address: t, namespace: e }));
      else {
        const i = await H.connectExternal(
          {
            id: n.id,
            type: n.type,
            provider: n.provider,
            address: t,
            chain: e,
          },
          e
        );
        return i == null ? void 0 : i.address;
      }
      return t;
    },
    async handleDisconnectedConnection({
      connection: s,
      namespace: e,
      address: t,
      closeModalOnConnect: n,
    }) {
      var l, d;
      const r = q.getConnectorById(s.connectorId),
        i =
          (d = (l = s.auth) == null ? void 0 : l.name) == null
            ? void 0
            : d.toLowerCase(),
        o = s.connectorId === S.CONNECTOR_ID.AUTH,
        a = s.connectorId === S.CONNECTOR_ID.WALLET_CONNECT;
      if (!r)
        throw new Error(`No connector found for connection: ${s.connectorId}`);
      let c;
      if (o)
        if (i && hi.isSocialProvider(i)) {
          const { address: u } = await hi.connectSocial({
            social: i,
            closeModalOnConnect: n,
            onOpenFarcaster() {
              Ne.open({ view: "ConnectingFarcaster" });
            },
            onConnect() {
              de.replace("ProfileWallets");
            },
          });
          c = u;
        } else {
          const { address: u } = await hi.connectEmail({
            closeModalOnConnect: n,
            onOpen() {
              Ne.open({ view: "EmailLogin" });
            },
            onConnect() {
              de.replace("ProfileWallets");
            },
          });
          c = u;
        }
      else if (a) {
        const { address: u } = await hi.connectWalletConnect({
          walletConnect: !0,
          connector: r,
          closeModalOnConnect: n,
          onOpen(p) {
            Ne.open({ view: p ? "AllWallets" : "ConnectingWalletConnect" });
          },
          onConnect() {
            de.replace("ProfileWallets");
          },
        });
        c = u;
      } else {
        const u = await H.connectExternal(
          { id: r.id, type: r.type, provider: r.provider, chain: e },
          e
        );
        u && (c = u.address);
      }
      return (
        o &&
          t &&
          (await H.handleAuthAccountSwitch({ address: t, namespace: e })),
        c
      );
    },
    async switchConnection({
      connection: s,
      address: e,
      namespace: t,
      closeModalOnConnect: n,
      onChange: r,
    }) {
      let i;
      const o = se.getCaipAddress(t);
      if (o) {
        const { address: c } = Mt.parseCaipAddress(o);
        i = c;
      }
      const a = da.getConnectionStatus(s, t);
      switch (a) {
        case "connected":
        case "active": {
          const c = await H.handleActiveConnection({
            connection: s,
            namespace: t,
            address: e,
          });
          if (i && c) {
            const l = c.toLowerCase() !== i.toLowerCase();
            r == null ||
              r({
                address: c,
                namespace: t,
                hasSwitchedAccount: l,
                hasSwitchedWallet: a === "active",
              });
          }
          break;
        }
        case "disconnected": {
          const c = await H.handleDisconnectedConnection({
            connection: s,
            namespace: t,
            address: e,
            closeModalOnConnect: n,
          });
          c &&
            (r == null ||
              r({
                address: c,
                namespace: t,
                hasSwitchedAccount: !0,
                hasSwitchedWallet: !0,
              }));
          break;
        }
        default:
          throw new Error(`Invalid connection status: ${a}`);
      }
    },
  },
  H = Zt(rw),
  fr = qe({
    loading: !1,
    open: !1,
    selectedNetworkId: void 0,
    activeChain: void 0,
    initialized: !1,
  }),
  $s = {
    state: fr,
    subscribe(s) {
      return ft(fr, () => s(fr));
    },
    subscribeOpen(s) {
      return Ct(fr, "open", s);
    },
    set(s) {
      Object.assign(fr, { ...fr, ...s });
    },
  },
  iw = {
    async getTokenList() {
      var n;
      const s = y.state.activeCaipNetwork,
        e = await ae.fetchSwapTokens({
          chainId: s == null ? void 0 : s.caipNetworkId,
        });
      return (
        ((n = e == null ? void 0 : e.tokens) == null
          ? void 0
          : n.map((r) => ({
              ...r,
              eip2612: !1,
              quantity: { decimals: "0", numeric: "0" },
              price: 0,
              value: 0,
            }))) || []
      );
    },
    async fetchGasPrice() {
      var e;
      const s = y.state.activeCaipNetwork;
      if (!s) return null;
      try {
        switch (s.chainNamespace) {
          case "solana":
            const t =
              (e = await (H == null
                ? void 0
                : H.estimateGas({ chainNamespace: "solana" }))) == null
                ? void 0
                : e.toString();
            return { standard: t, fast: t, instant: t };
          case "eip155":
          default:
            return await ae.fetchGasPrice({ chainId: s.caipNetworkId });
        }
      } catch {
        return null;
      }
    },
    async fetchSwapAllowance({
      tokenAddress: s,
      userAddress: e,
      sourceTokenAmount: t,
      sourceTokenDecimals: n,
    }) {
      const r = await ae.fetchSwapAllowance({
        tokenAddress: s,
        userAddress: e,
      });
      if (r != null && r.allowance && t && n) {
        const i = H.parseUnits(t, n) || 0;
        return BigInt(r.allowance) >= i;
      }
      return !1;
    },
    async getMyTokensWithBalance(s) {
      const e = await jl.getMyTokensWithBalance(s);
      return (
        se.setTokenBalance(e, y.state.activeChain),
        this.mapBalancesToSwapTokens(e)
      );
    },
    mapBalancesToSwapTokens(s) {
      return (
        (s == null
          ? void 0
          : s.map((e) => ({
              ...e,
              address: e != null && e.address ? e.address : up(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1,
            }))) || []
      );
    },
  },
  ke = qe({ tokenBalances: [], loading: !1 }),
  ow = {
    state: ke,
    subscribe(s) {
      return ft(ke, () => s(ke));
    },
    subscribeKey(s, e) {
      return Ct(ke, s, e);
    },
    setToken(s) {
      s && (ke.token = Qn(s));
    },
    setTokenAmount(s) {
      ke.sendTokenAmount = s;
    },
    setReceiverAddress(s) {
      ke.receiverAddress = s;
    },
    setReceiverProfileImageUrl(s) {
      ke.receiverProfileImageUrl = s;
    },
    setReceiverProfileName(s) {
      ke.receiverProfileName = s;
    },
    setNetworkBalanceInUsd(s) {
      ke.networkBalanceInUSD = s;
    },
    setLoading(s) {
      ke.loading = s;
    },
    async sendToken() {
      var s;
      try {
        switch (
          (xe.setLoading(!0),
          (s = y.state.activeCaipNetwork) == null ? void 0 : s.chainNamespace)
        ) {
          case "eip155":
            await xe.sendEvmToken();
            return;
          case "solana":
            await xe.sendSolanaToken();
            return;
          default:
            throw new Error("Unsupported chain");
        }
      } finally {
        xe.setLoading(!1);
      }
    },
    async sendEvmToken() {
      var t, n, r;
      const s = y.state.activeChain;
      if (!s)
        throw new Error(
          "SendController:sendEvmToken - activeChainNamespace is required"
        );
      const e = Cs(s);
      if (!xe.state.sendTokenAmount || !xe.state.receiverAddress)
        throw new Error("An amount and receiver address are required");
      if (!xe.state.token) throw new Error("A token is required");
      (t = xe.state.token) != null && t.address
        ? (Ue.sendEvent({
            type: "track",
            event: "SEND_INITIATED",
            properties: {
              isSmartAccount: e === nt.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: xe.state.token.address,
              amount: xe.state.sendTokenAmount,
              network:
                ((n = y.state.activeCaipNetwork) == null
                  ? void 0
                  : n.caipNetworkId) || "",
            },
          }),
          await xe.sendERC20Token({
            receiverAddress: xe.state.receiverAddress,
            tokenAddress: xe.state.token.address,
            sendTokenAmount: xe.state.sendTokenAmount,
            decimals: xe.state.token.quantity.decimals,
          }))
        : (Ue.sendEvent({
            type: "track",
            event: "SEND_INITIATED",
            properties: {
              isSmartAccount: e === nt.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: xe.state.token.symbol || "",
              amount: xe.state.sendTokenAmount,
              network:
                ((r = y.state.activeCaipNetwork) == null
                  ? void 0
                  : r.caipNetworkId) || "",
            },
          }),
          await xe.sendNativeToken({
            receiverAddress: xe.state.receiverAddress,
            sendTokenAmount: xe.state.sendTokenAmount,
            decimals: xe.state.token.quantity.decimals,
          }));
    },
    async fetchTokenBalance(s) {
      var i, o;
      ke.loading = !0;
      const e =
          (i = y.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId,
        t = (o = y.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace,
        n = y.state.activeCaipAddress,
        r = n ? ne.getPlainAddress(n) : void 0;
      if (ke.lastRetry && !ne.isAllowedRetry(ke.lastRetry, 30 * Pe.ONE_SEC_MS))
        return (ke.loading = !1), [];
      try {
        if (r && e && t) {
          const a = await jl.getMyTokensWithBalance();
          return (ke.tokenBalances = a), (ke.lastRetry = void 0), a;
        }
      } catch (a) {
        (ke.lastRetry = Date.now()),
          s == null || s(a),
          ks.showError("Token Balance Unavailable");
      } finally {
        ke.loading = !1;
      }
      return [];
    },
    fetchNetworkBalance() {
      if (ke.tokenBalances.length === 0) return;
      const s = iw.mapBalancesToSwapTokens(ke.tokenBalances);
      if (!s) return;
      const e = s.find((t) => t.address === up());
      e &&
        (ke.networkBalanceInUSD = e
          ? Nm.multiply(e.quantity.numeric, e.price).toString()
          : "0");
    },
    async sendNativeToken(s) {
      var i, o, a;
      de.pushTransactionStack({});
      const e = s.receiverAddress,
        t = se.state.address,
        n = H.parseUnits(s.sendTokenAmount.toString(), Number(s.decimals));
      await H.sendTransaction({
        chainNamespace: S.CHAIN.EVM,
        to: e,
        address: t,
        data: "0x",
        value: n ?? BigInt(0),
      }),
        Ue.sendEvent({
          type: "track",
          event: "SEND_SUCCESS",
          properties: {
            isSmartAccount: Cs("eip155") === nt.ACCOUNT_TYPES.SMART_ACCOUNT,
            token: ((i = xe.state.token) == null ? void 0 : i.symbol) || "",
            amount: s.sendTokenAmount,
            network:
              ((o = y.state.activeCaipNetwork) == null
                ? void 0
                : o.caipNetworkId) || "",
          },
        }),
        (a = H._getClient()) == null || a.updateBalance("eip155"),
        xe.resetSend();
    },
    async sendERC20Token(s) {
      de.pushTransactionStack({
        onSuccess() {
          de.replace("Account");
        },
      });
      const e = H.parseUnits(s.sendTokenAmount.toString(), Number(s.decimals));
      if (
        se.state.address &&
        s.sendTokenAmount &&
        s.receiverAddress &&
        s.tokenAddress
      ) {
        const t = ne.getPlainAddress(s.tokenAddress);
        if (!t)
          throw new Error(
            "SendController:sendERC20Token - tokenAddress is required"
          );
        await H.writeContract({
          fromAddress: se.state.address,
          tokenAddress: t,
          args: [s.receiverAddress, e ?? BigInt(0)],
          method: "transfer",
          abi: Pm.getERC20Abi(t),
          chainNamespace: S.CHAIN.EVM,
        }),
          xe.resetSend();
      }
    },
    async sendSolanaToken() {
      var s;
      if (!xe.state.sendTokenAmount || !xe.state.receiverAddress)
        throw new Error("An amount and receiver address are required");
      de.pushTransactionStack({
        onSuccess() {
          de.replace("Account");
        },
      }),
        await H.sendTransaction({
          chainNamespace: "solana",
          to: xe.state.receiverAddress,
          value: xe.state.sendTokenAmount,
        }),
        (s = H._getClient()) == null || s.updateBalance("solana"),
        xe.resetSend();
    },
    resetSend() {
      (ke.token = void 0),
        (ke.sendTokenAmount = void 0),
        (ke.receiverAddress = void 0),
        (ke.receiverProfileImageUrl = void 0),
        (ke.receiverProfileName = void 0),
        (ke.loading = !1),
        (ke.tokenBalances = []);
    },
  },
  xe = Zt(ow),
  tc = {
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: !1,
    addressLabels: new Map(),
    user: void 0,
    preferredAccountType: void 0,
  },
  Lo = {
    caipNetwork: void 0,
    supportsAllNetworks: !0,
    smartAccountEnabledNetworks: [],
  },
  W = qe({
    chains: wm(),
    activeCaipAddress: void 0,
    activeChain: void 0,
    activeCaipNetwork: void 0,
    noAdapters: !1,
    universalAdapter: {
      networkControllerClient: void 0,
      connectionControllerClient: void 0,
    },
    isSwitchingNamespace: !1,
  }),
  aw = {
    state: W,
    subscribe(s) {
      return ft(W, () => {
        s(W);
      });
    },
    subscribeKey(s, e) {
      return Ct(W, s, e);
    },
    subscribeChainProp(s, e, t) {
      let n;
      return ft(W.chains, () => {
        var i;
        const r = t || W.activeChain;
        if (r) {
          const o = (i = W.chains.get(r)) == null ? void 0 : i[s];
          n !== o && ((n = o), e(o));
        }
      });
    },
    initialize(s, e, t) {
      const { chainId: n, namespace: r } = M.getActiveNetworkProps(),
        i =
          e == null
            ? void 0
            : e.find(
                (d) => d.id.toString() === (n == null ? void 0 : n.toString())
              ),
        a =
          s.find((d) => (d == null ? void 0 : d.namespace) === r) ||
          (s == null ? void 0 : s[0]),
        c = s.map((d) => d.namespace).filter((d) => d !== void 0),
        l = R.state.enableEmbedded
          ? new Set([...c])
          : new Set([
              ...((e == null ? void 0 : e.map((d) => d.chainNamespace)) ?? []),
            ]);
      ((s == null ? void 0 : s.length) === 0 || !a) && (W.noAdapters = !0),
        W.noAdapters ||
          ((W.activeChain = a == null ? void 0 : a.namespace),
          (W.activeCaipNetwork = i),
          y.setChainNetworkData(a == null ? void 0 : a.namespace, {
            caipNetwork: i,
          }),
          W.activeChain &&
            $s.set({ activeChain: a == null ? void 0 : a.namespace })),
        l.forEach((d) => {
          const u =
              e == null ? void 0 : e.filter((g) => g.chainNamespace === d),
            p = M.getPreferredAccountTypes() || {},
            w = { ...R.state.defaultAccountTypes, ...p };
          y.state.chains.set(d, {
            namespace: d,
            networkState: qe({ ...Lo, caipNetwork: u == null ? void 0 : u[0] }),
            accountState: qe({ ...tc, preferredAccountType: w[d] }),
            caipNetworks: u ?? [],
            ...t,
          }),
            y.setRequestedCaipNetworks(u ?? [], d);
        });
    },
    removeAdapter(s) {
      var e, t;
      if (W.activeChain === s) {
        const n = Array.from(W.chains.entries()).find(([r]) => r !== s);
        if (n) {
          const r =
            (t = (e = n[1]) == null ? void 0 : e.caipNetworks) == null
              ? void 0
              : t[0];
          r && y.setActiveCaipNetwork(r);
        }
      }
      W.chains.delete(s);
    },
    addAdapter(
      s,
      { networkControllerClient: e, connectionControllerClient: t },
      n
    ) {
      if (!s.namespace)
        throw new Error(
          "ChainController:addAdapter - adapter must have a namespace"
        );
      W.chains.set(s.namespace, {
        namespace: s.namespace,
        networkState: { ...Lo, caipNetwork: n[0] },
        accountState: tc,
        caipNetworks: n,
        connectionControllerClient: t,
        networkControllerClient: e,
      }),
        y.setRequestedCaipNetworks(
          (n == null
            ? void 0
            : n.filter((r) => r.chainNamespace === s.namespace)) ?? [],
          s.namespace
        );
    },
    addNetwork(s) {
      var t;
      const e = W.chains.get(s.chainNamespace);
      if (e) {
        const n = [...(e.caipNetworks || [])];
        ((t = e.caipNetworks) != null && t.find((r) => r.id === s.id)) ||
          n.push(s),
          W.chains.set(s.chainNamespace, { ...e, caipNetworks: n }),
          y.setRequestedCaipNetworks(n, s.chainNamespace),
          q.filterByNamespace(s.chainNamespace, !0);
      }
    },
    removeNetwork(s, e) {
      var n, r, i;
      const t = W.chains.get(s);
      if (t) {
        const o = ((n = W.activeCaipNetwork) == null ? void 0 : n.id) === e,
          a = [
            ...(((r = t.caipNetworks) == null
              ? void 0
              : r.filter((c) => c.id !== e)) || []),
          ];
        o &&
          (i = t == null ? void 0 : t.caipNetworks) != null &&
          i[0] &&
          y.setActiveCaipNetwork(t.caipNetworks[0]),
          W.chains.set(s, { ...t, caipNetworks: a }),
          y.setRequestedCaipNetworks(a || [], s),
          a.length === 0 && q.filterByNamespace(s, !1);
      }
    },
    setAdapterNetworkState(s, e) {
      const t = W.chains.get(s);
      t &&
        ((t.networkState = { ...(t.networkState || Lo), ...e }),
        W.chains.set(s, t));
    },
    setChainAccountData(s, e, t = !0) {
      if (!s) throw new Error("Chain is required to update chain account data");
      const n = W.chains.get(s);
      if (n) {
        const r = { ...(n.accountState || tc), ...e };
        W.chains.set(s, { ...n, accountState: r }),
          (W.chains.size === 1 || W.activeChain === s) &&
            (e.caipAddress && (W.activeCaipAddress = e.caipAddress),
            se.replaceState(r));
      }
    },
    setChainNetworkData(s, e) {
      if (!s) return;
      const t = W.chains.get(s);
      if (t) {
        const n = { ...(t.networkState || Lo), ...e };
        W.chains.set(s, { ...t, networkState: n });
      }
    },
    setAccountProp(s, e, t, n = !0) {
      y.setChainAccountData(t, { [s]: e }, n);
    },
    setActiveNamespace(s) {
      var n, r;
      W.activeChain = s;
      const e = s ? W.chains.get(s) : void 0,
        t =
          (n = e == null ? void 0 : e.networkState) == null
            ? void 0
            : n.caipNetwork;
      t != null &&
        t.id &&
        s &&
        ((W.activeCaipAddress =
          (r = e == null ? void 0 : e.accountState) == null
            ? void 0
            : r.caipAddress),
        (W.activeCaipNetwork = t),
        y.setChainNetworkData(s, { caipNetwork: t }),
        M.setActiveCaipNetworkId(t == null ? void 0 : t.caipNetworkId),
        $s.set({
          activeChain: s,
          selectedNetworkId: t == null ? void 0 : t.caipNetworkId,
        }));
    },
    setActiveCaipNetwork(s) {
      var n, r, i;
      if (!s) return;
      W.activeChain !== s.chainNamespace && y.setIsSwitchingNamespace(!0);
      const e = W.chains.get(s.chainNamespace);
      (W.activeChain = s.chainNamespace),
        (W.activeCaipNetwork = s),
        y.setChainNetworkData(s.chainNamespace, { caipNetwork: s }),
        (n = e == null ? void 0 : e.accountState) != null && n.address
          ? (W.activeCaipAddress = `${s.chainNamespace}:${s.id}:${
              (r = e == null ? void 0 : e.accountState) == null
                ? void 0
                : r.address
            }`)
          : (W.activeCaipAddress = void 0),
        y.setAccountProp("caipAddress", W.activeCaipAddress, s.chainNamespace),
        e && se.replaceState(e.accountState),
        xe.resetSend(),
        $s.set({
          activeChain: W.activeChain,
          selectedNetworkId:
            (i = W.activeCaipNetwork) == null ? void 0 : i.caipNetworkId,
        }),
        M.setActiveCaipNetworkId(s.caipNetworkId),
        !y.checkIfSupportedNetwork(s.chainNamespace) &&
          R.state.enableNetworkSwitch &&
          !R.state.allowUnsupportedChain &&
          !H.state.wcBasic &&
          y.showUnsupportedChainUI();
    },
    addCaipNetwork(s) {
      var t;
      if (!s) return;
      const e = W.chains.get(s.chainNamespace);
      e && ((t = e == null ? void 0 : e.caipNetworks) == null || t.push(s));
    },
    async switchActiveNamespace(s) {
      var r;
      if (!s) return;
      const e = s !== y.state.activeChain,
        t = (r = y.getNetworkData(s)) == null ? void 0 : r.caipNetwork,
        n = y.getCaipNetworkByNamespace(s, t == null ? void 0 : t.id);
      e && n && (await y.switchActiveNetwork(n));
    },
    async switchActiveNetwork(s) {
      var i;
      const e = y.state.activeChain;
      if (!e)
        throw new Error(
          "ChainController:switchActiveNetwork - namespace is required"
        );
      const t = y.state.chains.get(e),
        n = !(
          (i = t == null ? void 0 : t.caipNetworks) != null &&
          i.some((o) => {
            var a;
            return o.id === ((a = W.activeCaipNetwork) == null ? void 0 : a.id);
          })
        ),
        r = y.getNetworkControllerClient(s.chainNamespace);
      if (r) {
        try {
          await r.switchCaipNetwork(s), n && Ne.close();
        } catch {
          de.goBack();
        }
        Ue.sendEvent({
          type: "track",
          event: "SWITCH_NETWORK",
          properties: { network: s.caipNetworkId },
        });
      }
    },
    getNetworkControllerClient(s) {
      const e = s || W.activeChain;
      if (!e)
        throw new Error(
          "ChainController:getNetworkControllerClient - chain is required"
        );
      const t = W.chains.get(e);
      if (!t) throw new Error("Chain adapter not found");
      if (!t.networkControllerClient)
        throw new Error("NetworkController client not set");
      return t.networkControllerClient;
    },
    getConnectionControllerClient(s) {
      const e = s || W.activeChain;
      if (!e)
        throw new Error(
          "Chain is required to get connection controller client"
        );
      const t = W.chains.get(e);
      if (!(t != null && t.connectionControllerClient))
        throw new Error("ConnectionController client not set");
      return t.connectionControllerClient;
    },
    getAccountProp(s, e) {
      var r;
      let t = W.activeChain;
      if ((e && (t = e), !t)) return;
      const n = (r = W.chains.get(t)) == null ? void 0 : r.accountState;
      if (n) return n[s];
    },
    getNetworkProp(s, e) {
      var n;
      const t = (n = W.chains.get(e)) == null ? void 0 : n.networkState;
      if (t) return t[s];
    },
    getRequestedCaipNetworks(s) {
      const e = W.chains.get(s),
        { approvedCaipNetworkIds: t = [], requestedCaipNetworks: n = [] } =
          (e == null ? void 0 : e.networkState) || {};
      return ne.sortRequestedNetworks(t, n);
    },
    getAllRequestedCaipNetworks() {
      const s = [];
      return (
        W.chains.forEach((e) => {
          if (!e.namespace)
            throw new Error(
              "ChainController:getAllRequestedCaipNetworks - chainAdapter must have a namespace"
            );
          const t = y.getRequestedCaipNetworks(e.namespace);
          s.push(...t);
        }),
        s
      );
    },
    setRequestedCaipNetworks(s, e) {
      y.setAdapterNetworkState(e, { requestedCaipNetworks: s });
      const n = y.getAllRequestedCaipNetworks().map((i) => i.chainNamespace),
        r = Array.from(new Set(n));
      q.filterByNamespaces(r);
    },
    getAllApprovedCaipNetworkIds() {
      const s = [];
      return (
        W.chains.forEach((e) => {
          if (!e.namespace)
            throw new Error(
              "ChainController:getAllApprovedCaipNetworkIds - chainAdapter must have a namespace"
            );
          const t = y.getApprovedCaipNetworkIds(e.namespace);
          s.push(...t);
        }),
        s
      );
    },
    getActiveCaipNetwork(s) {
      var e, t;
      return s
        ? (t = (e = W.chains.get(s)) == null ? void 0 : e.networkState) == null
          ? void 0
          : t.caipNetwork
        : W.activeCaipNetwork;
    },
    getActiveCaipAddress() {
      return W.activeCaipAddress;
    },
    getApprovedCaipNetworkIds(s) {
      var n;
      const e = W.chains.get(s);
      return (
        ((n = e == null ? void 0 : e.networkState) == null
          ? void 0
          : n.approvedCaipNetworkIds) || []
      );
    },
    async setApprovedCaipNetworksData(s) {
      const e = y.getNetworkControllerClient(),
        t = await (e == null ? void 0 : e.getApprovedCaipNetworksData());
      y.setAdapterNetworkState(s, {
        approvedCaipNetworkIds: t == null ? void 0 : t.approvedCaipNetworkIds,
        supportsAllNetworks: t == null ? void 0 : t.supportsAllNetworks,
      });
    },
    checkIfSupportedNetwork(s, e) {
      const t = e || W.activeCaipNetwork,
        n = y.getRequestedCaipNetworks(s);
      return n.length
        ? n == null
          ? void 0
          : n.some((r) => r.id === (t == null ? void 0 : t.id))
        : !0;
    },
    checkIfSupportedChainId(s) {
      if (!W.activeChain) return !0;
      const e = y.getRequestedCaipNetworks(W.activeChain);
      return e == null ? void 0 : e.some((t) => t.id === s);
    },
    setSmartAccountEnabledNetworks(s, e) {
      y.setAdapterNetworkState(e, { smartAccountEnabledNetworks: s });
    },
    checkIfSmartAccountEnabled() {
      var n;
      const s = ip.caipNetworkIdToNumber(
          (n = W.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
        ),
        e = W.activeChain;
      if (!e || !s) return !1;
      const t = y.getNetworkProp("smartAccountEnabledNetworks", e);
      return !!(t != null && t.includes(Number(s)));
    },
    showUnsupportedChainUI() {
      Ne.open({ view: "UnsupportedChain" });
    },
    checkIfNamesSupported() {
      const s = W.activeCaipNetwork;
      return !!(
        s != null &&
        s.chainNamespace &&
        Pe.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(s.chainNamespace)
      );
    },
    resetNetwork(s) {
      y.setAdapterNetworkState(s, {
        approvedCaipNetworkIds: void 0,
        supportsAllNetworks: !0,
      });
    },
    resetAccount(s) {
      const e = s;
      if (!e) throw new Error("Chain is required to set account prop");
      const t = y.getAccountProp("preferredAccountType", e);
      (W.activeCaipAddress = void 0),
        y.setChainAccountData(e, {
          smartAccountDeployed: !1,
          currentTab: 0,
          caipAddress: void 0,
          address: void 0,
          balance: void 0,
          balanceSymbol: void 0,
          profileName: void 0,
          profileImage: void 0,
          addressExplorerUrl: void 0,
          tokenBalance: [],
          connectedWalletInfo: void 0,
          preferredAccountType: t,
          socialProvider: void 0,
          socialWindow: void 0,
          farcasterUrl: void 0,
          user: void 0,
          status: "disconnected",
        }),
        q.removeConnectorId(e);
    },
    setIsSwitchingNamespace(s) {
      W.isSwitchingNamespace = s;
    },
    getFirstCaipNetworkSupportsAuthConnector() {
      var t, n;
      const s = [];
      let e;
      if (
        (W.chains.forEach((r) => {
          S.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((i) => i === r.namespace) &&
            r.namespace &&
            s.push(r.namespace);
        }),
        s.length > 0)
      ) {
        const r = s[0];
        return (
          (e = r
            ? (n = (t = W.chains.get(r)) == null ? void 0 : t.caipNetworks) ==
              null
              ? void 0
              : n[0]
            : void 0),
          e
        );
      }
    },
    getAccountData(s) {
      var e;
      return s
        ? (e = y.state.chains.get(s)) == null
          ? void 0
          : e.accountState
        : se.state;
    },
    getNetworkData(s) {
      var t;
      const e = s || W.activeChain;
      if (e)
        return (t = y.state.chains.get(e)) == null ? void 0 : t.networkState;
    },
    getCaipNetworkByNamespace(s, e) {
      var r, i, o;
      if (!s) return;
      const t = y.state.chains.get(s),
        n =
          (r = t == null ? void 0 : t.caipNetworks) == null
            ? void 0
            : r.find((a) => a.id === e);
      return (
        n ||
        ((i = t == null ? void 0 : t.networkState) == null
          ? void 0
          : i.caipNetwork) ||
        ((o = t == null ? void 0 : t.caipNetworks) == null ? void 0 : o[0])
      );
    },
    getRequestedCaipNetworkIds() {
      const s = q.state.filterByNamespace;
      return (s ? [W.chains.get(s)] : Array.from(W.chains.values()))
        .flatMap((t) => (t == null ? void 0 : t.caipNetworks) || [])
        .map((t) => t.caipNetworkId);
    },
    getCaipNetworks(s) {
      return s
        ? y.getRequestedCaipNetworks(s)
        : y.getAllRequestedCaipNetworks();
    },
    setLastConnectedSIWECaipNetwork(s) {
      W.lastConnectedSIWECaipNetwork = s;
    },
    getLastConnectedSIWECaipNetwork() {
      return W.lastConnectedSIWECaipNetwork;
    },
  },
  y = Zt(aw),
  cw = {
    purchaseCurrencies: [
      {
        id: "2b92315d-eab7-5bef-84fa-089a131333f5",
        name: "USD Coin",
        symbol: "USDC",
        networks: [
          {
            name: "ethereum-mainnet",
            display_name: "Ethereum",
            chain_id: "1",
            contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
          },
          {
            name: "polygon-mainnet",
            display_name: "Polygon",
            chain_id: "137",
            contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
          },
        ],
      },
      {
        id: "2b92315d-eab7-5bef-84fa-089a131333f5",
        name: "Ether",
        symbol: "ETH",
        networks: [
          {
            name: "ethereum-mainnet",
            display_name: "Ethereum",
            chain_id: "1",
            contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
          },
          {
            name: "polygon-mainnet",
            display_name: "Polygon",
            chain_id: "137",
            contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
          },
        ],
      },
    ],
    paymentCurrencies: [
      {
        id: "USD",
        payment_method_limits: [
          { id: "card", min: "10.00", max: "7500.00" },
          { id: "ach_bank_account", min: "10.00", max: "25000.00" },
        ],
      },
      {
        id: "EUR",
        payment_method_limits: [
          { id: "card", min: "10.00", max: "7500.00" },
          { id: "ach_bank_account", min: "10.00", max: "25000.00" },
        ],
      },
    ],
  },
  hp = ne.getBlockchainApiUrl(),
  Rt = qe({
    clientId: null,
    api: new So({ baseUrl: hp, clientId: null }),
    supportedChains: { http: [], ws: [] },
  }),
  ae = {
    state: Rt,
    async get(s) {
      const { st: e, sv: t } = ae.getSdkProperties(),
        n = R.state.projectId,
        r = { ...(s.params || {}), st: e, sv: t, projectId: n };
      return Rt.api.get({ ...s, params: r });
    },
    getSdkProperties() {
      const { sdkType: s, sdkVersion: e } = R.state;
      return { st: s || "unknown", sv: e || "unknown" };
    },
    async isNetworkSupported(s) {
      if (!s) return !1;
      try {
        Rt.supportedChains.http.length || (await ae.getSupportedNetworks());
      } catch {
        return !1;
      }
      return Rt.supportedChains.http.includes(s);
    },
    async getSupportedNetworks() {
      try {
        const s = await ae.get({ path: "v1/supported-chains" });
        return (Rt.supportedChains = s), s;
      } catch {
        return Rt.supportedChains;
      }
    },
    async fetchIdentity({ address: s, caipNetworkId: e }) {
      if (!(await ae.isNetworkSupported(e))) return { avatar: "", name: "" };
      const n = M.getIdentityFromCacheForAddress(s);
      if (n) return n;
      const r = await ae.get({
        path: `/v1/identity/${s}`,
        params: {
          sender: y.state.activeCaipAddress
            ? ne.getPlainAddress(y.state.activeCaipAddress)
            : void 0,
        },
      });
      return (
        M.updateIdentityCache({
          address: s,
          identity: r,
          timestamp: Date.now(),
        }),
        r
      );
    },
    async fetchTransactions({
      account: s,
      cursor: e,
      onramp: t,
      signal: n,
      cache: r,
      chainId: i,
    }) {
      var a;
      return (await ae.isNetworkSupported(
        (a = y.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId
      ))
        ? ae.get({
            path: `/v1/account/${s}/history`,
            params: { cursor: e, onramp: t, chainId: i },
            signal: n,
            cache: r,
          })
        : { data: [], next: void 0 };
    },
    async fetchSwapQuote({
      amount: s,
      userAddress: e,
      from: t,
      to: n,
      gasPrice: r,
    }) {
      var o;
      return (await ae.isNetworkSupported(
        (o = y.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId
      ))
        ? ae.get({
            path: "/v1/convert/quotes",
            headers: { "Content-Type": "application/json" },
            params: { amount: s, userAddress: e, from: t, to: n, gasPrice: r },
          })
        : { quotes: [] };
    },
    async fetchSwapTokens({ chainId: s }) {
      var t;
      return (await ae.isNetworkSupported(
        (t = y.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId
      ))
        ? ae.get({ path: "/v1/convert/tokens", params: { chainId: s } })
        : { tokens: [] };
    },
    async fetchTokenPrice({ addresses: s }) {
      var t;
      return (await ae.isNetworkSupported(
        (t = y.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId
      ))
        ? Rt.api.post({
            path: "/v1/fungible/price",
            body: {
              currency: "usd",
              addresses: s,
              projectId: R.state.projectId,
            },
            headers: { "Content-Type": "application/json" },
          })
        : { fungibles: [] };
    },
    async fetchSwapAllowance({ tokenAddress: s, userAddress: e }) {
      var n;
      return (await ae.isNetworkSupported(
        (n = y.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? ae.get({
            path: "/v1/convert/allowance",
            params: { tokenAddress: s, userAddress: e },
            headers: { "Content-Type": "application/json" },
          })
        : { allowance: "0" };
    },
    async fetchGasPrice({ chainId: s }) {
      var r;
      const { st: e, sv: t } = ae.getSdkProperties();
      if (
        !(await ae.isNetworkSupported(
          (r = y.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
        ))
      )
        throw new Error("Network not supported for Gas Price");
      return ae.get({
        path: "/v1/convert/gas-price",
        headers: { "Content-Type": "application/json" },
        params: { chainId: s, st: e, sv: t },
      });
    },
    async generateSwapCalldata({
      amount: s,
      from: e,
      to: t,
      userAddress: n,
      disableEstimate: r,
    }) {
      var o;
      if (
        !(await ae.isNetworkSupported(
          (o = y.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId
        ))
      )
        throw new Error("Network not supported for Swaps");
      return Rt.api.post({
        path: "/v1/convert/build-transaction",
        headers: { "Content-Type": "application/json" },
        body: {
          amount: s,
          eip155: { slippage: Pe.CONVERT_SLIPPAGE_TOLERANCE },
          projectId: R.state.projectId,
          from: e,
          to: t,
          userAddress: n,
          disableEstimate: r,
        },
      });
    },
    async generateApproveCalldata({ from: s, to: e, userAddress: t }) {
      var o;
      const { st: n, sv: r } = ae.getSdkProperties();
      if (
        !(await ae.isNetworkSupported(
          (o = y.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId
        ))
      )
        throw new Error("Network not supported for Swaps");
      return ae.get({
        path: "/v1/convert/build-approve",
        headers: { "Content-Type": "application/json" },
        params: { userAddress: t, from: s, to: e, st: n, sv: r },
      });
    },
    async getBalance(s, e, t) {
      var l;
      const { st: n, sv: r } = ae.getSdkProperties();
      if (
        !(await ae.isNetworkSupported(
          (l = y.state.activeCaipNetwork) == null ? void 0 : l.caipNetworkId
        ))
      )
        return ks.showError("Token Balance Unavailable"), { balances: [] };
      const o = `${e}:${s}`,
        a = M.getBalanceCacheForCaipAddress(o);
      if (a) return a;
      const c = await ae.get({
        path: `/v1/account/${s}/balance`,
        params: { currency: "usd", chainId: e, forceUpdate: t, st: n, sv: r },
      });
      return (
        M.updateBalanceCache({
          caipAddress: o,
          balance: c,
          timestamp: Date.now(),
        }),
        c
      );
    },
    async lookupEnsName(s) {
      var t;
      return (await ae.isNetworkSupported(
        (t = y.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId
      ))
        ? ae.get({
            path: `/v1/profile/account/${s}`,
            params: { apiVersion: "2" },
          })
        : { addresses: {}, attributes: [] };
    },
    async reverseLookupEnsName({ address: s }) {
      var t;
      return (await ae.isNetworkSupported(
        (t = y.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId
      ))
        ? ae.get({
            path: `/v1/profile/reverse/${s}`,
            params: { sender: se.state.address, apiVersion: "2" },
          })
        : [];
    },
    async getEnsNameSuggestions(s) {
      var t;
      return (await ae.isNetworkSupported(
        (t = y.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId
      ))
        ? ae.get({
            path: `/v1/profile/suggestions/${s}`,
            params: { zone: "reown.id" },
          })
        : { suggestions: [] };
    },
    async registerEnsName({
      coinType: s,
      address: e,
      message: t,
      signature: n,
    }) {
      var i;
      return (await ae.isNetworkSupported(
        (i = y.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
      ))
        ? Rt.api.post({
            path: "/v1/profile/account",
            body: { coin_type: s, address: e, message: t, signature: n },
            headers: { "Content-Type": "application/json" },
          })
        : { success: !1 };
    },
    async generateOnRampURL({
      destinationWallets: s,
      partnerUserId: e,
      defaultNetwork: t,
      purchaseAmount: n,
      paymentAmount: r,
    }) {
      var a;
      return (await ae.isNetworkSupported(
        (a = y.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId
      ))
        ? (
            await Rt.api.post({
              path: "/v1/generators/onrampurl",
              params: { projectId: R.state.projectId },
              body: {
                destinationWallets: s,
                defaultNetwork: t,
                partnerUserId: e,
                defaultExperience: "buy",
                presetCryptoAmount: n,
                presetFiatAmount: r,
              },
            })
          ).url
        : "";
    },
    async getOnrampOptions() {
      var e;
      if (
        !(await ae.isNetworkSupported(
          (e = y.state.activeCaipNetwork) == null ? void 0 : e.caipNetworkId
        ))
      )
        return { paymentCurrencies: [], purchaseCurrencies: [] };
      try {
        return await ae.get({ path: "/v1/onramp/options" });
      } catch {
        return cw;
      }
    },
    async getOnrampQuote({
      purchaseCurrency: s,
      paymentCurrency: e,
      amount: t,
      network: n,
    }) {
      var r;
      try {
        return (await ae.isNetworkSupported(
          (r = y.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
        ))
          ? await Rt.api.post({
              path: "/v1/onramp/quote",
              params: { projectId: R.state.projectId },
              body: {
                purchaseCurrency: s,
                paymentCurrency: e,
                amount: t,
                network: n,
              },
            })
          : null;
      } catch {
        return {
          coinbaseFee: { amount: t, currency: e.id },
          networkFee: { amount: t, currency: e.id },
          paymentSubtotal: { amount: t, currency: e.id },
          paymentTotal: { amount: t, currency: e.id },
          purchaseAmount: { amount: t, currency: e.id },
          quoteId: "mocked-quote-id",
        };
      }
    },
    async getSmartSessions(s) {
      var t;
      return (await ae.isNetworkSupported(
        (t = y.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId
      ))
        ? ae.get({ path: `/v1/sessions/${s}` })
        : [];
    },
    async revokeSmartSession(s, e, t) {
      var r;
      return (await ae.isNetworkSupported(
        (r = y.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
      ))
        ? Rt.api.post({
            path: `/v1/sessions/${s}/revoke`,
            params: { projectId: R.state.projectId },
            body: { pci: e, signature: t },
          })
        : { success: !1 };
    },
    setClientId(s) {
      (Rt.clientId = s), (Rt.api = new So({ baseUrl: hp, clientId: s }));
    },
  },
  sc = {
    createBalance(s, e) {
      const t = {
        name: s.metadata.name || "",
        symbol: s.metadata.symbol || "",
        decimals: s.metadata.decimals || 0,
        value: s.metadata.value || 0,
        price: s.metadata.price || 0,
        iconUrl: s.metadata.iconUrl || "",
      };
      return {
        name: t.name,
        symbol: t.symbol,
        chainId: e,
        address:
          s.address === "native"
            ? void 0
            : this.convertAddressToCAIP10Address(s.address, e),
        value: t.value,
        price: t.price,
        quantity: {
          decimals: t.decimals.toString(),
          numeric: this.convertHexToBalance({
            hex: s.balance,
            decimals: t.decimals,
          }),
        },
        iconUrl: t.iconUrl,
      };
    },
    convertHexToBalance({ hex: s, decimals: e }) {
      return Kg(BigInt(s), e);
    },
    convertAddressToCAIP10Address(s, e) {
      return `${e}:${s}`;
    },
    createCAIP2ChainId(s, e) {
      return `${e}:${parseInt(s, 16)}`;
    },
    getChainIdHexFromCAIP2ChainId(s) {
      const e = s.split(":");
      if (e.length < 2 || !e[1]) return "0x0";
      const t = e[1],
        n = parseInt(t, 10);
      return isNaN(n) ? "0x0" : `0x${n.toString(16)}`;
    },
    isWalletGetAssetsResponse(s) {
      return typeof s != "object" || s === null
        ? !1
        : Object.values(s).every(
            (e) => Array.isArray(e) && e.every((t) => this.isValidAsset(t))
          );
    },
    isValidAsset(s) {
      return (
        typeof s == "object" &&
        s !== null &&
        typeof s.address == "string" &&
        typeof s.balance == "string" &&
        (s.type === "ERC20" || s.type === "NATIVE") &&
        typeof s.metadata == "object" &&
        s.metadata !== null &&
        typeof s.metadata.name == "string" &&
        typeof s.metadata.symbol == "string" &&
        typeof s.metadata.decimals == "number" &&
        typeof s.metadata.price == "number" &&
        typeof s.metadata.iconUrl == "string"
      );
    },
  },
  jl = {
    async getMyTokensWithBalance(s) {
      const e = se.state.address,
        t = y.state.activeCaipNetwork,
        n = q.getConnectorId("eip155") === S.CONNECTOR_ID.AUTH;
      if (!e || !t) return [];
      const r = `${t.caipNetworkId}:${e}`,
        i = M.getBalanceCacheForCaipAddress(r);
      if (i) return i.balances;
      if (t.chainNamespace === S.CHAIN.EVM && n) {
        const a = await this.getEIP155Balances(e, t);
        if (a) return this.filterLowQualityTokens(a);
      }
      const o = await ae.getBalance(e, t.caipNetworkId, s);
      return this.filterLowQualityTokens(o.balances);
    },
    async getEIP155Balances(s, e) {
      var t, n;
      try {
        const r = sc.getChainIdHexFromCAIP2ChainId(e.caipNetworkId),
          i = await H.getCapabilities(s);
        if (
          !(
            (n =
              (t = i == null ? void 0 : i[r]) == null
                ? void 0
                : t.assetDiscovery) != null && n.supported
          )
        )
          return null;
        const o = await H.walletGetAssets({ account: s, chainFilter: [r] });
        if (!sc.isWalletGetAssetsResponse(o)) return null;
        const c = (o[r] || []).map((l) => sc.createBalance(l, e.caipNetworkId));
        return (
          M.updateBalanceCache({
            caipAddress: `${e.caipNetworkId}:${s}`,
            balance: { balances: c },
            timestamp: Date.now(),
          }),
          c
        );
      } catch {
        return null;
      }
    },
    filterLowQualityTokens(s) {
      return s.filter((e) => e.quantity.decimals !== "0");
    },
  },
  Is = qe({
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: !1,
    addressLabels: new Map(),
  }),
  lw = {
    state: Is,
    replaceState(s) {
      s && Object.assign(Is, Qn(s));
    },
    subscribe(s) {
      return y.subscribeChainProp("accountState", (e) => {
        if (e) return s(e);
      });
    },
    subscribeKey(s, e, t) {
      let n;
      return y.subscribeChainProp(
        "accountState",
        (r) => {
          if (r) {
            const i = r[s];
            n !== i && ((n = i), e(i));
          }
        },
        t
      );
    },
    setStatus(s, e) {
      y.setAccountProp("status", s, e);
    },
    getCaipAddress(s) {
      return y.getAccountProp("caipAddress", s);
    },
    setCaipAddress(s, e) {
      const t = s ? ne.getPlainAddress(s) : void 0;
      e === y.state.activeChain && (y.state.activeCaipAddress = s),
        y.setAccountProp("caipAddress", s, e),
        y.setAccountProp("address", t, e);
    },
    setBalance(s, e, t) {
      y.setAccountProp("balance", s, t),
        y.setAccountProp("balanceSymbol", e, t);
    },
    setProfileName(s, e) {
      y.setAccountProp("profileName", s, e);
    },
    setProfileImage(s, e) {
      y.setAccountProp("profileImage", s, e);
    },
    setUser(s, e) {
      y.setAccountProp("user", s, e);
    },
    setAddressExplorerUrl(s, e) {
      y.setAccountProp("addressExplorerUrl", s, e);
    },
    setSmartAccountDeployed(s, e) {
      y.setAccountProp("smartAccountDeployed", s, e);
    },
    setCurrentTab(s) {
      y.setAccountProp("currentTab", s, y.state.activeChain);
    },
    setTokenBalance(s, e) {
      s && y.setAccountProp("tokenBalance", s, e);
    },
    setShouldUpdateToAddress(s, e) {
      y.setAccountProp("shouldUpdateToAddress", s, e);
    },
    addAddressLabel(s, e, t) {
      const n = y.getAccountProp("addressLabels", t) || new Map();
      n.set(s, e), y.setAccountProp("addressLabels", n, t);
    },
    removeAddressLabel(s, e) {
      const t = y.getAccountProp("addressLabels", e) || new Map();
      t.delete(s), y.setAccountProp("addressLabels", t, e);
    },
    setConnectedWalletInfo(s, e) {
      y.setAccountProp("connectedWalletInfo", s, e, !1);
    },
    setPreferredAccountType(s, e) {
      y.setAccountProp("preferredAccountType", s, e);
    },
    setSocialProvider(s, e) {
      s && y.setAccountProp("socialProvider", s, e);
    },
    setSocialWindow(s, e) {
      y.setAccountProp("socialWindow", s ? Qn(s) : void 0, e);
    },
    setFarcasterUrl(s, e) {
      y.setAccountProp("farcasterUrl", s, e);
    },
    async fetchTokenBalance(s) {
      var i, o;
      Is.balanceLoading = !0;
      const e =
          (i = y.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId,
        t = (o = y.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace,
        n = y.state.activeCaipAddress,
        r = n ? ne.getPlainAddress(n) : void 0;
      if (Is.lastRetry && !ne.isAllowedRetry(Is.lastRetry, 30 * Pe.ONE_SEC_MS))
        return (Is.balanceLoading = !1), [];
      try {
        if (r && e && t) {
          const a = await jl.getMyTokensWithBalance();
          return (
            se.setTokenBalance(a, t),
            (Is.lastRetry = void 0),
            (Is.balanceLoading = !1),
            a
          );
        }
      } catch (a) {
        (Is.lastRetry = Date.now()),
          s == null || s(a),
          ks.showError("Token Balance Unavailable");
      } finally {
        Is.balanceLoading = !1;
      }
      return [];
    },
    resetAccount(s) {
      y.resetAccount(s);
    },
  },
  se = Zt(lw),
  dw = {
    onSwitchNetwork({ network: s, ignoreSwitchConfirmation: e = !1 }) {
      const t = y.state.activeCaipNetwork,
        n = de.state.data;
      if (s.id === (t == null ? void 0 : t.id)) return;
      const i = se.getCaipAddress(y.state.activeChain),
        o = s.chainNamespace !== y.state.activeChain,
        a = se.getCaipAddress(s.chainNamespace),
        l = q.getConnectorId(y.state.activeChain) === S.CONNECTOR_ID.AUTH,
        d = S.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
          (u) => u === s.chainNamespace
        );
      e || (l && d)
        ? de.push("SwitchNetwork", { ...n, network: s })
        : i && o && !a
        ? de.push("SwitchActiveChain", {
            switchToChain: s.chainNamespace,
            navigateTo: "Connect",
            navigateWithReplace: !0,
            network: s,
          })
        : de.push("SwitchNetwork", { ...n, network: s });
    },
  },
  xt = qe({
    loading: !1,
    loadingNamespaceMap: new Map(),
    open: !1,
    shake: !1,
    namespace: void 0,
  }),
  uw = {
    state: xt,
    subscribe(s) {
      return ft(xt, () => s(xt));
    },
    subscribeKey(s, e) {
      return Ct(xt, s, e);
    },
    async open(s) {
      var i, o;
      const e = s == null ? void 0 : s.namespace,
        t = y.state.activeChain,
        n = e && e !== t,
        r =
          (i = y.getAccountData(s == null ? void 0 : s.namespace)) == null
            ? void 0
            : i.caipAddress;
      if (
        (H.state.wcBasic
          ? re.prefetch({ fetchNetworkImages: !1, fetchConnectorImages: !1 })
          : await re.prefetch(),
        q.setFilterByNamespace(s == null ? void 0 : s.namespace),
        Ne.setLoading(!0, e),
        e && n)
      ) {
        const a =
          ((o = y.getNetworkData(e)) == null ? void 0 : o.caipNetwork) ||
          y.getRequestedCaipNetworks(e)[0];
        a && dw.onSwitchNetwork({ network: a, ignoreSwitchConfirmation: !0 });
      } else {
        const a = y.state.noAdapters;
        R.state.manualWCControl || (a && !r)
          ? ne.isMobile()
            ? de.reset("AllWallets")
            : de.reset("ConnectingWalletConnectBasic")
          : s != null && s.view
          ? de.reset(s.view, s.data)
          : r
          ? de.reset("Account")
          : de.reset("Connect");
      }
      (xt.open = !0),
        $s.set({ open: !0 }),
        Ue.sendEvent({
          type: "track",
          event: "MODAL_OPEN",
          properties: { connected: !!r },
        });
    },
    close() {
      const s = R.state.enableEmbedded,
        e = !!y.state.activeCaipAddress;
      xt.open &&
        Ue.sendEvent({
          type: "track",
          event: "MODAL_CLOSE",
          properties: { connected: e },
        }),
        (xt.open = !1),
        de.reset("Connect"),
        Ne.clearLoading(),
        s
          ? e
            ? de.replace("Account")
            : de.push("Connect")
          : $s.set({ open: !1 }),
        H.resetUri();
    },
    setLoading(s, e) {
      e && xt.loadingNamespaceMap.set(e, s),
        (xt.loading = s),
        $s.set({ loading: s });
    },
    clearLoading() {
      xt.loadingNamespaceMap.clear(), (xt.loading = !1);
    },
    shake() {
      xt.shake ||
        ((xt.shake = !0),
        setTimeout(() => {
          xt.shake = !1;
        }, 500));
    },
  },
  Ne = Zt(uw),
  $i = {
    id: "2b92315d-eab7-5bef-84fa-089a131333f5",
    name: "USD Coin",
    symbol: "USDC",
    networks: [
      {
        name: "ethereum-mainnet",
        display_name: "Ethereum",
        chain_id: "1",
        contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      },
      {
        name: "polygon-mainnet",
        display_name: "Polygon",
        chain_id: "137",
        contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
      },
    ],
  },
  zc = {
    id: "USD",
    payment_method_limits: [
      { id: "card", min: "10.00", max: "7500.00" },
      { id: "ach_bank_account", min: "10.00", max: "25000.00" },
    ],
  },
  hw = {
    providers: cp,
    selectedProvider: null,
    error: null,
    purchaseCurrency: $i,
    paymentCurrency: zc,
    purchaseCurrencies: [$i],
    paymentCurrencies: [],
    quotesLoading: !1,
  },
  ve = qe(hw),
  pw = {
    state: ve,
    subscribe(s) {
      return ft(ve, () => s(ve));
    },
    subscribeKey(s, e) {
      return Ct(ve, s, e);
    },
    setSelectedProvider(s) {
      if (s && s.name === "meld") {
        const e = y.state.activeChain,
          t = e === S.CHAIN.SOLANA ? "SOL" : "USDC",
          n = y.getAccountProp("address", e) ?? "",
          r = new URL(s.url);
        r.searchParams.append("publicKey", Om),
          r.searchParams.append("destinationCurrencyCode", t),
          r.searchParams.append("walletAddress", n),
          r.searchParams.append("externalCustomerId", R.state.projectId),
          (ve.selectedProvider = { ...s, url: r.toString() });
      } else ve.selectedProvider = s;
    },
    setOnrampProviders(s) {
      if (Array.isArray(s) && s.every((e) => typeof e == "string")) {
        const e = s,
          t = cp.filter((n) => e.includes(n.name));
        ve.providers = t;
      } else ve.providers = [];
    },
    setPurchaseCurrency(s) {
      ve.purchaseCurrency = s;
    },
    setPaymentCurrency(s) {
      ve.paymentCurrency = s;
    },
    setPurchaseAmount(s) {
      Vc.state.purchaseAmount = s;
    },
    setPaymentAmount(s) {
      Vc.state.paymentAmount = s;
    },
    async getAvailableCurrencies() {
      const s = await ae.getOnrampOptions();
      (ve.purchaseCurrencies = s.purchaseCurrencies),
        (ve.paymentCurrencies = s.paymentCurrencies),
        (ve.paymentCurrency = s.paymentCurrencies[0] || zc),
        (ve.purchaseCurrency = s.purchaseCurrencies[0] || $i),
        await re.fetchCurrencyImages(s.paymentCurrencies.map((e) => e.id)),
        await re.fetchTokenImages(s.purchaseCurrencies.map((e) => e.symbol));
    },
    async getQuote() {
      var s, e;
      ve.quotesLoading = !0;
      try {
        const t = await ae.getOnrampQuote({
          purchaseCurrency: ve.purchaseCurrency,
          paymentCurrency: ve.paymentCurrency,
          amount:
            ((s = ve.paymentAmount) == null ? void 0 : s.toString()) || "0",
          network: (e = ve.purchaseCurrency) == null ? void 0 : e.symbol,
        });
        return (
          (ve.quotesLoading = !1),
          (ve.purchaseAmount = Number(
            t == null ? void 0 : t.purchaseAmount.amount
          )),
          t
        );
      } catch (t) {
        return (ve.error = t.message), (ve.quotesLoading = !1), null;
      } finally {
        ve.quotesLoading = !1;
      }
    },
    resetState() {
      (ve.selectedProvider = null),
        (ve.error = null),
        (ve.purchaseCurrency = $i),
        (ve.paymentCurrency = zc),
        (ve.purchaseCurrencies = [$i]),
        (ve.paymentCurrencies = []),
        (ve.paymentAmount = void 0),
        (ve.purchaseAmount = void 0),
        (ve.quotesLoading = !1);
    },
  },
  Vc = Zt(pw),
  Rd = 2147483648,
  fw = {
    convertEVMChainIdToCoinType(s) {
      if (s >= Rd) throw new Error("Invalid chainId");
      return (Rd | s) >>> 0;
    },
  },
  Xt = qe({ suggestions: [], loading: !1 }),
  gw = {
    state: Xt,
    subscribe(s) {
      return ft(Xt, () => s(Xt));
    },
    subscribeKey(s, e) {
      return Ct(Xt, s, e);
    },
    async resolveName(s) {
      var e, t;
      try {
        return await ae.lookupEnsName(s);
      } catch (n) {
        const r = n;
        throw new Error(
          ((t = (e = r == null ? void 0 : r.reasons) == null ? void 0 : e[0]) ==
          null
            ? void 0
            : t.description) || "Error resolving name"
        );
      }
    },
    async isNameRegistered(s) {
      try {
        return await ae.lookupEnsName(s), !0;
      } catch {
        return !1;
      }
    },
    async getSuggestions(s) {
      try {
        (Xt.loading = !0), (Xt.suggestions = []);
        const e = await ae.getEnsNameSuggestions(s);
        return (
          (Xt.suggestions =
            e.suggestions.map((t) => ({ ...t, name: t.name })) || []),
          Xt.suggestions
        );
      } catch (e) {
        const t = Di.parseEnsApiError(e, "Error fetching name suggestions");
        throw new Error(t);
      } finally {
        Xt.loading = !1;
      }
    },
    async getNamesForAddress(s) {
      try {
        if (!y.state.activeCaipNetwork) return [];
        const t = M.getEnsFromCacheForAddress(s);
        if (t) return t;
        const n = await ae.reverseLookupEnsName({ address: s });
        return (
          M.updateEnsCache({ address: s, ens: n, timestamp: Date.now() }), n
        );
      } catch (e) {
        const t = Di.parseEnsApiError(e, "Error fetching names for address");
        throw new Error(t);
      }
    },
    async registerName(s) {
      const e = y.state.activeCaipNetwork,
        t = se.state.address,
        n = q.getAuthConnector();
      if (!e) throw new Error("Network not found");
      if (!t || !n) throw new Error("Address or auth connector not found");
      Xt.loading = !0;
      try {
        const r = JSON.stringify({
          name: s,
          attributes: {},
          timestamp: Math.floor(Date.now() / 1e3),
        });
        de.pushTransactionStack({
          onCancel() {
            de.replace("RegisterAccountName");
          },
        });
        const i = await H.signMessage(r);
        Xt.loading = !1;
        const o = e.id;
        if (!o) throw new Error("Network not found");
        const a = fw.convertEVMChainIdToCoinType(Number(o));
        await ae.registerEnsName({
          coinType: a,
          address: t,
          signature: i,
          message: r,
        }),
          se.setProfileName(s, e.chainNamespace),
          de.replace("RegisterAccountNameSuccess");
      } catch (r) {
        const i = Di.parseEnsApiError(r, `Error registering name ${s}`);
        throw (de.replace("RegisterAccountName"), new Error(i));
      } finally {
        Xt.loading = !1;
      }
    },
    validateName(s) {
      return /^[a-zA-Z0-9-]{4,}$/u.test(s);
    },
    parseEnsApiError(s, e) {
      var n, r;
      const t = s;
      return (
        ((r = (n = t == null ? void 0 : t.reasons) == null ? void 0 : n[0]) ==
        null
          ? void 0
          : r.description) || e
      );
    },
  },
  Di = Zt(gw);
var mw = Object.defineProperty,
  ww = (s, e, t) =>
    e in s
      ? mw(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  xd = (s, e, t) => ww(s, typeof e != "symbol" ? e + "" : e, t);
let yw = class extends Qr {
  constructor(e) {
    super(),
      (this.opts = e),
      xd(this, "protocol", "wc"),
      xd(this, "version", 2);
  }
};
var Ew = Object.defineProperty,
  bw = (s, e, t) =>
    e in s
      ? Ew(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  _w = (s, e, t) => bw(s, e + "", t);
let Cw = class extends Qr {
    constructor(e, t) {
      super(),
        (this.core = e),
        (this.logger = t),
        _w(this, "records", new Map());
    }
  },
  vw = class {
    constructor(e, t) {
      (this.logger = e), (this.core = t);
    }
  },
  Aw = class extends Qr {
    constructor(e, t) {
      super(), (this.relayer = e), (this.logger = t);
    }
  },
  Iw = class extends Qr {
    constructor(e) {
      super();
    }
  },
  Sw = class {
    constructor(e, t, n, r) {
      (this.core = e), (this.logger = t), (this.name = n);
    }
  },
  Nw = class extends Qr {
    constructor(e, t) {
      super(), (this.relayer = e), (this.logger = t);
    }
  },
  Tw = class extends Qr {
    constructor(e, t) {
      super(), (this.core = e), (this.logger = t);
    }
  },
  Rw = class {
    constructor(e, t, n) {
      (this.core = e), (this.logger = t), (this.store = n);
    }
  },
  xw = class {
    constructor(e, t) {
      (this.projectId = e), (this.logger = t);
    }
  },
  Pw = class {
    constructor(e, t, n) {
      (this.core = e), (this.logger = t), (this.telemetryEnabled = n);
    }
  };
var Ow = Object.defineProperty,
  kw = (s, e, t) =>
    e in s
      ? Ow(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Pd = (s, e, t) => kw(s, typeof e != "symbol" ? e + "" : e, t);
let Uw = class {
    constructor(e) {
      (this.opts = e), Pd(this, "protocol", "wc"), Pd(this, "version", 2);
    }
  },
  $w = class {
    constructor(e) {
      this.client = e;
    }
  };
function Qi(s, { strict: e = !0 } = {}) {
  return !s || typeof s != "string"
    ? !1
    : e
    ? /^0x[0-9a-fA-F]*$/.test(s)
    : s.startsWith("0x");
}
function Kc(s) {
  return Qi(s, { strict: !1 }) ? Math.ceil((s.length - 2) / 2) : s.length;
}
const pp = "2.31.0";
let pi = {
  getDocsUrl: ({ docsBaseUrl: s, docsPath: e = "", docsSlug: t }) =>
    e ? `${s ?? "https://viem.sh"}${e}${t ? `#${t}` : ""}` : void 0,
  version: `viem@${pp}`,
};
class er extends Error {
  constructor(e, t = {}) {
    var a;
    const n = (() => {
        var c;
        return t.cause instanceof er
          ? t.cause.details
          : (c = t.cause) != null && c.message
          ? t.cause.message
          : t.details;
      })(),
      r = (t.cause instanceof er && t.cause.docsPath) || t.docsPath,
      i =
        (a = pi.getDocsUrl) == null
          ? void 0
          : a.call(pi, { ...t, docsPath: r }),
      o = [
        e || "An error occurred.",
        "",
        ...(t.metaMessages ? [...t.metaMessages, ""] : []),
        ...(i ? [`Docs: ${i}`] : []),
        ...(n ? [`Details: ${n}`] : []),
        ...(pi.version ? [`Version: ${pi.version}`] : []),
      ].join(`
`);
    super(o, t.cause ? { cause: t.cause } : void 0),
      Object.defineProperty(this, "details", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docsPath", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "metaMessages", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "shortMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "version", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "BaseError",
      }),
      (this.details = n),
      (this.docsPath = r),
      (this.metaMessages = t.metaMessages),
      (this.name = t.name ?? this.name),
      (this.shortMessage = e),
      (this.version = pp);
  }
  walk(e) {
    return fp(this, e);
  }
}
function fp(s, e) {
  return e != null && e(s)
    ? s
    : s && typeof s == "object" && "cause" in s && s.cause !== void 0
    ? fp(s.cause, e)
    : e
    ? null
    : s;
}
class gp extends er {
  constructor({ size: e, targetSize: t, type: n }) {
    super(
      `${n.charAt(0).toUpperCase()}${n
        .slice(1)
        .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
      { name: "SizeExceedsPaddingSizeError" }
    );
  }
}
function ri(s, { dir: e, size: t = 32 } = {}) {
  return typeof s == "string"
    ? Dw(s, { dir: e, size: t })
    : Lw(s, { dir: e, size: t });
}
function Dw(s, { dir: e, size: t = 32 } = {}) {
  if (t === null) return s;
  const n = s.replace("0x", "");
  if (n.length > t * 2)
    throw new gp({ size: Math.ceil(n.length / 2), targetSize: t, type: "hex" });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](t * 2, "0")}`;
}
function Lw(s, { dir: e, size: t = 32 } = {}) {
  if (t === null) return s;
  if (s.length > t)
    throw new gp({ size: s.length, targetSize: t, type: "bytes" });
  const n = new Uint8Array(t);
  for (let r = 0; r < t; r++) {
    const i = e === "right";
    n[i ? r : t - r - 1] = s[i ? r : s.length - r - 1];
  }
  return n;
}
class Mw extends er {
  constructor({ max: e, min: t, signed: n, size: r, value: i }) {
    super(
      `Number "${i}" is not in safe ${
        r ? `${r * 8}-bit ${n ? "signed" : "unsigned"} ` : ""
      }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
      { name: "IntegerOutOfRangeError" }
    );
  }
}
class Bw extends er {
  constructor({ givenSize: e, maxSize: t }) {
    super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
      name: "SizeOverflowError",
    });
  }
}
function ii(s, { size: e }) {
  if (Kc(s) > e) throw new Bw({ givenSize: Kc(s), maxSize: e });
}
function Gc(s, e = {}) {
  const { signed: t } = e;
  e.size && ii(s, { size: e.size });
  const n = BigInt(s);
  if (!t) return n;
  const r = (s.length - 2) / 2,
    i = (1n << (BigInt(r) * 8n - 1n)) - 1n;
  return n <= i ? n : n - BigInt(`0x${"f".padStart(r * 2, "f")}`) - 1n;
}
function Fw(s, e = {}) {
  return Number(Gc(s, e));
}
const jw = Array.from({ length: 256 }, (s, e) =>
  e.toString(16).padStart(2, "0")
);
function Yc(s, e = {}) {
  return typeof s == "number" || typeof s == "bigint"
    ? wp(s, e)
    : typeof s == "string"
    ? Ww(s, e)
    : typeof s == "boolean"
    ? qw(s, e)
    : mp(s, e);
}
function qw(s, e = {}) {
  const t = `0x${Number(s)}`;
  return typeof e.size == "number"
    ? (ii(t, { size: e.size }), ri(t, { size: e.size }))
    : t;
}
function mp(s, e = {}) {
  let t = "";
  for (let r = 0; r < s.length; r++) t += jw[s[r]];
  const n = `0x${t}`;
  return typeof e.size == "number"
    ? (ii(n, { size: e.size }), ri(n, { dir: "right", size: e.size }))
    : n;
}
function wp(s, e = {}) {
  const { signed: t, size: n } = e,
    r = BigInt(s);
  let i;
  n
    ? t
      ? (i = (1n << (BigInt(n) * 8n - 1n)) - 1n)
      : (i = 2n ** (BigInt(n) * 8n) - 1n)
    : typeof s == "number" && (i = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof i == "bigint" && t ? -i - 1n : 0;
  if ((i && r > i) || r < o) {
    const c = typeof s == "bigint" ? "n" : "";
    throw new Mw({
      max: i ? `${i}${c}` : void 0,
      min: `${o}${c}`,
      signed: t,
      size: n,
      value: `${s}${c}`,
    });
  }
  const a = `0x${(t && r < 0 ? (1n << BigInt(n * 8)) + BigInt(r) : r).toString(
    16
  )}`;
  return n ? ri(a, { size: n }) : a;
}
const Hw = new TextEncoder();
function Ww(s, e = {}) {
  const t = Hw.encode(s);
  return mp(t, e);
}
const zw = new TextEncoder();
function Vw(s, e = {}) {
  return typeof s == "number" || typeof s == "bigint"
    ? Gw(s, e)
    : typeof s == "boolean"
    ? Kw(s, e)
    : Qi(s)
    ? yp(s, e)
    : Ep(s, e);
}
function Kw(s, e = {}) {
  const t = new Uint8Array(1);
  return (
    (t[0] = Number(s)),
    typeof e.size == "number"
      ? (ii(t, { size: e.size }), ri(t, { size: e.size }))
      : t
  );
}
const Ws = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
function Od(s) {
  if (s >= Ws.zero && s <= Ws.nine) return s - Ws.zero;
  if (s >= Ws.A && s <= Ws.F) return s - (Ws.A - 10);
  if (s >= Ws.a && s <= Ws.f) return s - (Ws.a - 10);
}
function yp(s, e = {}) {
  let t = s;
  e.size &&
    (ii(t, { size: e.size }), (t = ri(t, { dir: "right", size: e.size })));
  let n = t.slice(2);
  n.length % 2 && (n = `0${n}`);
  const r = n.length / 2,
    i = new Uint8Array(r);
  for (let o = 0, a = 0; o < r; o++) {
    const c = Od(n.charCodeAt(a++)),
      l = Od(n.charCodeAt(a++));
    if (c === void 0 || l === void 0)
      throw new er(
        `Invalid byte sequence ("${n[a - 2]}${n[a - 1]}" in "${n}").`
      );
    i[o] = c * 16 + l;
  }
  return i;
}
function Gw(s, e) {
  const t = wp(s, e);
  return yp(t);
}
function Ep(s, e = {}) {
  const t = zw.encode(s);
  return typeof e.size == "number"
    ? (ii(t, { size: e.size }), ri(t, { dir: "right", size: e.size }))
    : t;
}
const Mo = BigInt(2 ** 32 - 1),
  kd = BigInt(32);
function Yw(s, e = !1) {
  return e
    ? { h: Number(s & Mo), l: Number((s >> kd) & Mo) }
    : { h: Number((s >> kd) & Mo) | 0, l: Number(s & Mo) | 0 };
}
function Zw(s, e = !1) {
  const t = s.length;
  let n = new Uint32Array(t),
    r = new Uint32Array(t);
  for (let i = 0; i < t; i++) {
    const { h: o, l: a } = Yw(s[i], e);
    [n[i], r[i]] = [o, a];
  }
  return [n, r];
}
const Jw = (s, e, t) => (s << t) | (e >>> (32 - t)),
  Xw = (s, e, t) => (e << t) | (s >>> (32 - t)),
  Qw = (s, e, t) => (e << (t - 32)) | (s >>> (64 - t)),
  ey = (s, e, t) => (s << (t - 32)) | (e >>> (64 - t)),
  gr =
    typeof globalThis == "object" && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function ty(
  s
) {
  return (
    s instanceof Uint8Array ||
    (ArrayBuffer.isView(s) && s.constructor.name === "Uint8Array")
  );
}
function ua(s) {
  if (!Number.isSafeInteger(s) || s < 0)
    throw new Error("positive integer expected, got " + s);
}
function eo(s, ...e) {
  if (!ty(s)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(s.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + s.length
    );
}
function Kx(s) {
  if (typeof s != "function" || typeof s.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  ua(s.outputLen), ua(s.blockLen);
}
function Ud(s, e = !0) {
  if (s.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && s.finished) throw new Error("Hash#digest() has already been called");
}
function sy(s, e) {
  eo(s);
  const t = e.outputLen;
  if (s.length < t)
    throw new Error(
      "digestInto() expects output buffer of length at least " + t
    );
}
function ny(s) {
  return new Uint32Array(s.buffer, s.byteOffset, Math.floor(s.byteLength / 4));
}
function bp(...s) {
  for (let e = 0; e < s.length; e++) s[e].fill(0);
}
function Gx(s) {
  return new DataView(s.buffer, s.byteOffset, s.byteLength);
}
function Yx(s, e) {
  return (s << (32 - e)) | (s >>> e);
}
const ry = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function iy(s) {
  return (
    ((s << 24) & 4278190080) |
    ((s << 8) & 16711680) |
    ((s >>> 8) & 65280) |
    ((s >>> 24) & 255)
  );
}
function oy(s) {
  for (let e = 0; e < s.length; e++) s[e] = iy(s[e]);
  return s;
}
const $d = ry ? (s) => s : oy;
function ay(s) {
  if (typeof s != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(s));
}
function _p(s) {
  return typeof s == "string" && (s = ay(s)), eo(s), s;
}
function Zx(...s) {
  let e = 0;
  for (let n = 0; n < s.length; n++) {
    const r = s[n];
    eo(r), (e += r.length);
  }
  const t = new Uint8Array(e);
  for (let n = 0, r = 0; n < s.length; n++) {
    const i = s[n];
    t.set(i, r), (r += i.length);
  }
  return t;
}
class cy {}
function ly(s) {
  const e = (n) => s().update(_p(n)).digest(),
    t = s();
  return (
    (e.outputLen = t.outputLen),
    (e.blockLen = t.blockLen),
    (e.create = () => s()),
    e
  );
}
function Jx(s = 32) {
  if (gr && typeof gr.getRandomValues == "function")
    return gr.getRandomValues(new Uint8Array(s));
  if (gr && typeof gr.randomBytes == "function")
    return Uint8Array.from(gr.randomBytes(s));
  throw new Error("crypto.getRandomValues must be defined");
}
const dy = BigInt(0),
  fi = BigInt(1),
  uy = BigInt(2),
  hy = BigInt(7),
  py = BigInt(256),
  fy = BigInt(113),
  Cp = [],
  vp = [],
  Ap = [];
for (let s = 0, e = fi, t = 1, n = 0; s < 24; s++) {
  ([t, n] = [n, (2 * t + 3 * n) % 5]),
    Cp.push(2 * (5 * n + t)),
    vp.push((((s + 1) * (s + 2)) / 2) % 64);
  let r = dy;
  for (let i = 0; i < 7; i++)
    (e = ((e << fi) ^ ((e >> hy) * fy)) % py),
      e & uy && (r ^= fi << ((fi << BigInt(i)) - fi));
  Ap.push(r);
}
const Ip = Zw(Ap, !0),
  gy = Ip[0],
  my = Ip[1],
  Dd = (s, e, t) => (t > 32 ? Qw(s, e, t) : Jw(s, e, t)),
  Ld = (s, e, t) => (t > 32 ? ey(s, e, t) : Xw(s, e, t));
function wy(s, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      t[o] = s[o] ^ s[o + 10] ^ s[o + 20] ^ s[o + 30] ^ s[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        c = (o + 2) % 10,
        l = t[c],
        d = t[c + 1],
        u = Dd(l, d, 1) ^ t[a],
        p = Ld(l, d, 1) ^ t[a + 1];
      for (let w = 0; w < 50; w += 10) (s[o + w] ^= u), (s[o + w + 1] ^= p);
    }
    let r = s[2],
      i = s[3];
    for (let o = 0; o < 24; o++) {
      const a = vp[o],
        c = Dd(r, i, a),
        l = Ld(r, i, a),
        d = Cp[o];
      (r = s[d]), (i = s[d + 1]), (s[d] = c), (s[d + 1] = l);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) t[a] = s[o + a];
      for (let a = 0; a < 10; a++)
        s[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    (s[0] ^= gy[n]), (s[1] ^= my[n]);
  }
  bp(t);
}
class ql extends cy {
  constructor(e, t, n, r = !1, i = 24) {
    if (
      (super(),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      (this.enableXOF = !1),
      (this.blockLen = e),
      (this.suffix = t),
      (this.outputLen = n),
      (this.enableXOF = r),
      (this.rounds = i),
      ua(n),
      !(0 < e && e < 200))
    )
      throw new Error("only keccak-f1600 function is supported");
    (this.state = new Uint8Array(200)), (this.state32 = ny(this.state));
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    $d(this.state32),
      wy(this.state32, this.rounds),
      $d(this.state32),
      (this.posOut = 0),
      (this.pos = 0);
  }
  update(e) {
    Ud(this), (e = _p(e)), eo(e);
    const { blockLen: t, state: n } = this,
      r = e.length;
    for (let i = 0; i < r; ) {
      const o = Math.min(t - this.pos, r - i);
      for (let a = 0; a < o; a++) n[this.pos++] ^= e[i++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: t, pos: n, blockLen: r } = this;
    (e[n] ^= t),
      t & 128 && n === r - 1 && this.keccak(),
      (e[r - 1] ^= 128),
      this.keccak();
  }
  writeInto(e) {
    Ud(this, !1), eo(e), this.finish();
    const t = this.state,
      { blockLen: n } = this;
    for (let r = 0, i = e.length; r < i; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, i - r);
      e.set(t.subarray(this.posOut, this.posOut + o), r),
        (this.posOut += o),
        (r += o);
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return ua(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if ((sy(e, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), bp(this.state);
  }
  _cloneInto(e) {
    const {
      blockLen: t,
      suffix: n,
      outputLen: r,
      rounds: i,
      enableXOF: o,
    } = this;
    return (
      e || (e = new ql(t, n, r, o, i)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = i),
      (e.suffix = n),
      (e.outputLen = r),
      (e.enableXOF = o),
      (e.destroyed = this.destroyed),
      e
    );
  }
}
const yy = (s, e, t) => ly(() => new ql(e, s, t)),
  Ey = yy(1, 136, 256 / 8);
function Sp(s, e) {
  const t = e || "hex",
    n = Ey(Qi(s, { strict: !1 }) ? Vw(s) : s);
  return t === "bytes" ? n : Yc(n);
}
class by extends Map {
  constructor(e) {
    super(),
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.maxSize = e);
  }
  get(e) {
    const t = super.get(e);
    return super.has(e) && t !== void 0 && (this.delete(e), super.set(e, t)), t;
  }
  set(e, t) {
    if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const nc = new by(8192);
function _y(s, e) {
  if (nc.has(`${s}.${e}`)) return nc.get(`${s}.${e}`);
  const t = s.substring(2).toLowerCase(),
    n = Sp(Ep(t), "bytes"),
    r = t.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && r[o] && (r[o] = r[o].toUpperCase()),
      (n[o >> 1] & 15) >= 8 && r[o + 1] && (r[o + 1] = r[o + 1].toUpperCase());
  const i = `0x${r.join("")}`;
  return nc.set(`${s}.${e}`, i), i;
}
function Cy(s) {
  const e = Sp(`0x${s.substring(4)}`).substring(26);
  return _y(`0x${e}`);
}
async function vy({ hash: s, signature: e }) {
  const t = Qi(s) ? s : Yc(s),
    { secp256k1: n } = await ts(async () => {
      const { secp256k1: o } = await import("./secp256k1-D3JKpjK0.js");
      return { secp256k1: o };
    }, __vite__mapDeps([0, 1, 2]));
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: l, s: d, v: u, yParity: p } = e,
        w = Number(p ?? u),
        g = Md(w);
      return new n.Signature(Gc(l), Gc(d)).addRecoveryBit(g);
    }
    const o = Qi(e) ? e : Yc(e);
    if (Kc(o) !== 65) throw new Error("invalid signature length");
    const a = Fw(`0x${o.slice(130)}`),
      c = Md(a);
    return n.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(c);
  })()
    .recoverPublicKey(t.substring(2))
    .toHex(!1)}`;
}
function Md(s) {
  if (s === 0 || s === 1) return s;
  if (s === 27) return 0;
  if (s === 28) return 1;
  throw new Error("Invalid yParityOrV value");
}
async function Ay({ hash: s, signature: e }) {
  return Cy(await vy({ hash: s, signature: e }));
}
function Iy(s) {
  const e = s.length;
  let t = 0,
    n = 0;
  for (; n < e; ) {
    let r = s.charCodeAt(n++);
    if (r & 4294967168)
      if (!(r & 4294965248)) t += 2;
      else {
        if (r >= 55296 && r <= 56319 && n < e) {
          const i = s.charCodeAt(n);
          (i & 64512) === 56320 &&
            (++n, (r = ((r & 1023) << 10) + (i & 1023) + 65536));
        }
        r & 4294901760 ? (t += 4) : (t += 3);
      }
    else {
      t++;
      continue;
    }
  }
  return t;
}
function Sy(s, e, t) {
  const n = s.length;
  let r = t,
    i = 0;
  for (; i < n; ) {
    let o = s.charCodeAt(i++);
    if (o & 4294967168)
      if (!(o & 4294965248)) e[r++] = ((o >> 6) & 31) | 192;
      else {
        if (o >= 55296 && o <= 56319 && i < n) {
          const a = s.charCodeAt(i);
          (a & 64512) === 56320 &&
            (++i, (o = ((o & 1023) << 10) + (a & 1023) + 65536));
        }
        o & 4294901760
          ? ((e[r++] = ((o >> 18) & 7) | 240),
            (e[r++] = ((o >> 12) & 63) | 128),
            (e[r++] = ((o >> 6) & 63) | 128))
          : ((e[r++] = ((o >> 12) & 15) | 224),
            (e[r++] = ((o >> 6) & 63) | 128));
      }
    else {
      e[r++] = o;
      continue;
    }
    e[r++] = (o & 63) | 128;
  }
}
const Ny = new TextEncoder(),
  Ty = 50;
function Ry(s, e, t) {
  Ny.encodeInto(s, e.subarray(t));
}
function xy(s, e, t) {
  s.length > Ty ? Ry(s, e, t) : Sy(s, e, t);
}
const Py = 4096;
function Np(s, e, t) {
  let n = e;
  const r = n + t,
    i = [];
  let o = "";
  for (; n < r; ) {
    const a = s[n++];
    if (!(a & 128)) i.push(a);
    else if ((a & 224) === 192) {
      const c = s[n++] & 63;
      i.push(((a & 31) << 6) | c);
    } else if ((a & 240) === 224) {
      const c = s[n++] & 63,
        l = s[n++] & 63;
      i.push(((a & 31) << 12) | (c << 6) | l);
    } else if ((a & 248) === 240) {
      const c = s[n++] & 63,
        l = s[n++] & 63,
        d = s[n++] & 63;
      let u = ((a & 7) << 18) | (c << 12) | (l << 6) | d;
      u > 65535 &&
        ((u -= 65536),
        i.push(((u >>> 10) & 1023) | 55296),
        (u = 56320 | (u & 1023))),
        i.push(u);
    } else i.push(a);
    i.length >= Py && ((o += String.fromCharCode(...i)), (i.length = 0));
  }
  return i.length > 0 && (o += String.fromCharCode(...i)), o;
}
const Oy = new TextDecoder(),
  ky = 200;
function Uy(s, e, t) {
  const n = s.subarray(e, e + t);
  return Oy.decode(n);
}
function $y(s, e, t) {
  return t > ky ? Uy(s, e, t) : Np(s, e, t);
}
class Bo {
  constructor(e, t) {
    (this.type = e), (this.data = t);
  }
}
class Wt extends Error {
  constructor(e) {
    super(e);
    const t = Object.create(Wt.prototype);
    Object.setPrototypeOf(this, t),
      Object.defineProperty(this, "name", {
        configurable: !0,
        enumerable: !1,
        value: Wt.name,
      });
  }
}
const gi = 4294967295;
function Dy(s, e, t) {
  const n = t / 4294967296,
    r = t;
  s.setUint32(e, n), s.setUint32(e + 4, r);
}
function Tp(s, e, t) {
  const n = Math.floor(t / 4294967296),
    r = t;
  s.setUint32(e, n), s.setUint32(e + 4, r);
}
function Rp(s, e) {
  const t = s.getInt32(e),
    n = s.getUint32(e + 4);
  return t * 4294967296 + n;
}
function Ly(s, e) {
  const t = s.getUint32(e),
    n = s.getUint32(e + 4);
  return t * 4294967296 + n;
}
const My = -1,
  By = 4294967296 - 1,
  Fy = 17179869184 - 1;
function jy({ sec: s, nsec: e }) {
  if (s >= 0 && e >= 0 && s <= Fy)
    if (e === 0 && s <= By) {
      const t = new Uint8Array(4);
      return new DataView(t.buffer).setUint32(0, s), t;
    } else {
      const t = s / 4294967296,
        n = s & 4294967295,
        r = new Uint8Array(8),
        i = new DataView(r.buffer);
      return i.setUint32(0, (e << 2) | (t & 3)), i.setUint32(4, n), r;
    }
  else {
    const t = new Uint8Array(12),
      n = new DataView(t.buffer);
    return n.setUint32(0, e), Tp(n, 4, s), t;
  }
}
function qy(s) {
  const e = s.getTime(),
    t = Math.floor(e / 1e3),
    n = (e - t * 1e3) * 1e6,
    r = Math.floor(n / 1e9);
  return { sec: t + r, nsec: n - r * 1e9 };
}
function Hy(s) {
  if (s instanceof Date) {
    const e = qy(s);
    return jy(e);
  } else return null;
}
function Wy(s) {
  const e = new DataView(s.buffer, s.byteOffset, s.byteLength);
  switch (s.byteLength) {
    case 4:
      return { sec: e.getUint32(0), nsec: 0 };
    case 8: {
      const t = e.getUint32(0),
        n = e.getUint32(4),
        r = (t & 3) * 4294967296 + n,
        i = t >>> 2;
      return { sec: r, nsec: i };
    }
    case 12: {
      const t = Rp(e, 4),
        n = e.getUint32(0);
      return { sec: t, nsec: n };
    }
    default:
      throw new Wt(
        `Unrecognized data size for timestamp (expected 4, 8, or 12): ${s.length}`
      );
  }
}
function zy(s) {
  const e = Wy(s);
  return new Date(e.sec * 1e3 + e.nsec / 1e6);
}
const Vy = { type: My, encode: Hy, decode: zy };
class ha {
  constructor() {
    (this.builtInEncoders = []),
      (this.builtInDecoders = []),
      (this.encoders = []),
      (this.decoders = []),
      this.register(Vy);
  }
  register({ type: e, encode: t, decode: n }) {
    if (e >= 0) (this.encoders[e] = t), (this.decoders[e] = n);
    else {
      const r = -1 - e;
      (this.builtInEncoders[r] = t), (this.builtInDecoders[r] = n);
    }
  }
  tryToEncode(e, t) {
    for (let n = 0; n < this.builtInEncoders.length; n++) {
      const r = this.builtInEncoders[n];
      if (r != null) {
        const i = r(e, t);
        if (i != null) {
          const o = -1 - n;
          return new Bo(o, i);
        }
      }
    }
    for (let n = 0; n < this.encoders.length; n++) {
      const r = this.encoders[n];
      if (r != null) {
        const i = r(e, t);
        if (i != null) {
          const o = n;
          return new Bo(o, i);
        }
      }
    }
    return e instanceof Bo ? e : null;
  }
  decode(e, t, n) {
    const r = t < 0 ? this.builtInDecoders[-1 - t] : this.decoders[t];
    return r ? r(e, t, n) : new Bo(t, e);
  }
}
ha.defaultCodec = new ha();
function Ky(s) {
  return (
    s instanceof ArrayBuffer ||
    (typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer)
  );
}
function Zc(s) {
  return s instanceof Uint8Array
    ? s
    : ArrayBuffer.isView(s)
    ? new Uint8Array(s.buffer, s.byteOffset, s.byteLength)
    : Ky(s)
    ? new Uint8Array(s)
    : Uint8Array.from(s);
}
const Gy = 100,
  Yy = 2048;
class Hl {
  constructor(e) {
    (this.entered = !1),
      (this.extensionCodec =
        (e == null ? void 0 : e.extensionCodec) ?? ha.defaultCodec),
      (this.context = e == null ? void 0 : e.context),
      (this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ?? !1),
      (this.maxDepth = (e == null ? void 0 : e.maxDepth) ?? Gy),
      (this.initialBufferSize =
        (e == null ? void 0 : e.initialBufferSize) ?? Yy),
      (this.sortKeys = (e == null ? void 0 : e.sortKeys) ?? !1),
      (this.forceFloat32 = (e == null ? void 0 : e.forceFloat32) ?? !1),
      (this.ignoreUndefined = (e == null ? void 0 : e.ignoreUndefined) ?? !1),
      (this.forceIntegerToFloat =
        (e == null ? void 0 : e.forceIntegerToFloat) ?? !1),
      (this.pos = 0),
      (this.view = new DataView(new ArrayBuffer(this.initialBufferSize))),
      (this.bytes = new Uint8Array(this.view.buffer));
  }
  clone() {
    return new Hl({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      maxDepth: this.maxDepth,
      initialBufferSize: this.initialBufferSize,
      sortKeys: this.sortKeys,
      forceFloat32: this.forceFloat32,
      ignoreUndefined: this.ignoreUndefined,
      forceIntegerToFloat: this.forceIntegerToFloat,
    });
  }
  reinitializeState() {
    this.pos = 0;
  }
  encodeSharedRef(e) {
    if (this.entered) return this.clone().encodeSharedRef(e);
    try {
      return (
        (this.entered = !0),
        this.reinitializeState(),
        this.doEncode(e, 1),
        this.bytes.subarray(0, this.pos)
      );
    } finally {
      this.entered = !1;
    }
  }
  encode(e) {
    if (this.entered) return this.clone().encode(e);
    try {
      return (
        (this.entered = !0),
        this.reinitializeState(),
        this.doEncode(e, 1),
        this.bytes.slice(0, this.pos)
      );
    } finally {
      this.entered = !1;
    }
  }
  doEncode(e, t) {
    if (t > this.maxDepth) throw new Error(`Too deep objects in depth ${t}`);
    e == null
      ? this.encodeNil()
      : typeof e == "boolean"
      ? this.encodeBoolean(e)
      : typeof e == "number"
      ? this.forceIntegerToFloat
        ? this.encodeNumberAsFloat(e)
        : this.encodeNumber(e)
      : typeof e == "string"
      ? this.encodeString(e)
      : this.useBigInt64 && typeof e == "bigint"
      ? this.encodeBigInt64(e)
      : this.encodeObject(e, t);
  }
  ensureBufferSizeToWrite(e) {
    const t = this.pos + e;
    this.view.byteLength < t && this.resizeBuffer(t * 2);
  }
  resizeBuffer(e) {
    const t = new ArrayBuffer(e),
      n = new Uint8Array(t),
      r = new DataView(t);
    n.set(this.bytes), (this.view = r), (this.bytes = n);
  }
  encodeNil() {
    this.writeU8(192);
  }
  encodeBoolean(e) {
    e === !1 ? this.writeU8(194) : this.writeU8(195);
  }
  encodeNumber(e) {
    !this.forceIntegerToFloat && Number.isSafeInteger(e)
      ? e >= 0
        ? e < 128
          ? this.writeU8(e)
          : e < 256
          ? (this.writeU8(204), this.writeU8(e))
          : e < 65536
          ? (this.writeU8(205), this.writeU16(e))
          : e < 4294967296
          ? (this.writeU8(206), this.writeU32(e))
          : this.useBigInt64
          ? this.encodeNumberAsFloat(e)
          : (this.writeU8(207), this.writeU64(e))
        : e >= -32
        ? this.writeU8(224 | (e + 32))
        : e >= -128
        ? (this.writeU8(208), this.writeI8(e))
        : e >= -32768
        ? (this.writeU8(209), this.writeI16(e))
        : e >= -2147483648
        ? (this.writeU8(210), this.writeI32(e))
        : this.useBigInt64
        ? this.encodeNumberAsFloat(e)
        : (this.writeU8(211), this.writeI64(e))
      : this.encodeNumberAsFloat(e);
  }
  encodeNumberAsFloat(e) {
    this.forceFloat32
      ? (this.writeU8(202), this.writeF32(e))
      : (this.writeU8(203), this.writeF64(e));
  }
  encodeBigInt64(e) {
    e >= BigInt(0)
      ? (this.writeU8(207), this.writeBigUint64(e))
      : (this.writeU8(211), this.writeBigInt64(e));
  }
  writeStringHeader(e) {
    if (e < 32) this.writeU8(160 + e);
    else if (e < 256) this.writeU8(217), this.writeU8(e);
    else if (e < 65536) this.writeU8(218), this.writeU16(e);
    else if (e < 4294967296) this.writeU8(219), this.writeU32(e);
    else throw new Error(`Too long string: ${e} bytes in UTF-8`);
  }
  encodeString(e) {
    const n = Iy(e);
    this.ensureBufferSizeToWrite(5 + n),
      this.writeStringHeader(n),
      xy(e, this.bytes, this.pos),
      (this.pos += n);
  }
  encodeObject(e, t) {
    const n = this.extensionCodec.tryToEncode(e, this.context);
    if (n != null) this.encodeExtension(n);
    else if (Array.isArray(e)) this.encodeArray(e, t);
    else if (ArrayBuffer.isView(e)) this.encodeBinary(e);
    else if (typeof e == "object") this.encodeMap(e, t);
    else
      throw new Error(
        `Unrecognized object: ${Object.prototype.toString.apply(e)}`
      );
  }
  encodeBinary(e) {
    const t = e.byteLength;
    if (t < 256) this.writeU8(196), this.writeU8(t);
    else if (t < 65536) this.writeU8(197), this.writeU16(t);
    else if (t < 4294967296) this.writeU8(198), this.writeU32(t);
    else throw new Error(`Too large binary: ${t}`);
    const n = Zc(e);
    this.writeU8a(n);
  }
  encodeArray(e, t) {
    const n = e.length;
    if (n < 16) this.writeU8(144 + n);
    else if (n < 65536) this.writeU8(220), this.writeU16(n);
    else if (n < 4294967296) this.writeU8(221), this.writeU32(n);
    else throw new Error(`Too large array: ${n}`);
    for (const r of e) this.doEncode(r, t + 1);
  }
  countWithoutUndefined(e, t) {
    let n = 0;
    for (const r of t) e[r] !== void 0 && n++;
    return n;
  }
  encodeMap(e, t) {
    const n = Object.keys(e);
    this.sortKeys && n.sort();
    const r = this.ignoreUndefined
      ? this.countWithoutUndefined(e, n)
      : n.length;
    if (r < 16) this.writeU8(128 + r);
    else if (r < 65536) this.writeU8(222), this.writeU16(r);
    else if (r < 4294967296) this.writeU8(223), this.writeU32(r);
    else throw new Error(`Too large map object: ${r}`);
    for (const i of n) {
      const o = e[i];
      (this.ignoreUndefined && o === void 0) ||
        (this.encodeString(i), this.doEncode(o, t + 1));
    }
  }
  encodeExtension(e) {
    if (typeof e.data == "function") {
      const n = e.data(this.pos + 6),
        r = n.length;
      if (r >= 4294967296) throw new Error(`Too large extension object: ${r}`);
      this.writeU8(201),
        this.writeU32(r),
        this.writeI8(e.type),
        this.writeU8a(n);
      return;
    }
    const t = e.data.length;
    if (t === 1) this.writeU8(212);
    else if (t === 2) this.writeU8(213);
    else if (t === 4) this.writeU8(214);
    else if (t === 8) this.writeU8(215);
    else if (t === 16) this.writeU8(216);
    else if (t < 256) this.writeU8(199), this.writeU8(t);
    else if (t < 65536) this.writeU8(200), this.writeU16(t);
    else if (t < 4294967296) this.writeU8(201), this.writeU32(t);
    else throw new Error(`Too large extension object: ${t}`);
    this.writeI8(e.type), this.writeU8a(e.data);
  }
  writeU8(e) {
    this.ensureBufferSizeToWrite(1),
      this.view.setUint8(this.pos, e),
      this.pos++;
  }
  writeU8a(e) {
    const t = e.length;
    this.ensureBufferSizeToWrite(t),
      this.bytes.set(e, this.pos),
      (this.pos += t);
  }
  writeI8(e) {
    this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, e), this.pos++;
  }
  writeU16(e) {
    this.ensureBufferSizeToWrite(2),
      this.view.setUint16(this.pos, e),
      (this.pos += 2);
  }
  writeI16(e) {
    this.ensureBufferSizeToWrite(2),
      this.view.setInt16(this.pos, e),
      (this.pos += 2);
  }
  writeU32(e) {
    this.ensureBufferSizeToWrite(4),
      this.view.setUint32(this.pos, e),
      (this.pos += 4);
  }
  writeI32(e) {
    this.ensureBufferSizeToWrite(4),
      this.view.setInt32(this.pos, e),
      (this.pos += 4);
  }
  writeF32(e) {
    this.ensureBufferSizeToWrite(4),
      this.view.setFloat32(this.pos, e),
      (this.pos += 4);
  }
  writeF64(e) {
    this.ensureBufferSizeToWrite(8),
      this.view.setFloat64(this.pos, e),
      (this.pos += 8);
  }
  writeU64(e) {
    this.ensureBufferSizeToWrite(8),
      Dy(this.view, this.pos, e),
      (this.pos += 8);
  }
  writeI64(e) {
    this.ensureBufferSizeToWrite(8),
      Tp(this.view, this.pos, e),
      (this.pos += 8);
  }
  writeBigUint64(e) {
    this.ensureBufferSizeToWrite(8),
      this.view.setBigUint64(this.pos, e),
      (this.pos += 8);
  }
  writeBigInt64(e) {
    this.ensureBufferSizeToWrite(8),
      this.view.setBigInt64(this.pos, e),
      (this.pos += 8);
  }
}
function Zy(s, e) {
  return new Hl(e).encodeSharedRef(s);
}
function rc(s) {
  return `${s < 0 ? "-" : ""}0x${Math.abs(s).toString(16).padStart(2, "0")}`;
}
const Jy = 16,
  Xy = 16;
class Qy {
  constructor(e = Jy, t = Xy) {
    (this.hit = 0),
      (this.miss = 0),
      (this.maxKeyLength = e),
      (this.maxLengthPerKey = t),
      (this.caches = []);
    for (let n = 0; n < this.maxKeyLength; n++) this.caches.push([]);
  }
  canBeCached(e) {
    return e > 0 && e <= this.maxKeyLength;
  }
  find(e, t, n) {
    const r = this.caches[n - 1];
    e: for (const i of r) {
      const o = i.bytes;
      for (let a = 0; a < n; a++) if (o[a] !== e[t + a]) continue e;
      return i.str;
    }
    return null;
  }
  store(e, t) {
    const n = this.caches[e.length - 1],
      r = { bytes: e, str: t };
    n.length >= this.maxLengthPerKey
      ? (n[(Math.random() * n.length) | 0] = r)
      : n.push(r);
  }
  decode(e, t, n) {
    const r = this.find(e, t, n);
    if (r != null) return this.hit++, r;
    this.miss++;
    const i = Np(e, t, n),
      o = Uint8Array.prototype.slice.call(e, t, t + n);
    return this.store(o, i), i;
  }
}
const Jc = "array",
  Li = "map_key",
  xp = "map_value",
  eE = (s) => {
    if (typeof s == "string" || typeof s == "number") return s;
    throw new Wt("The type of key must be string or number but " + typeof s);
  };
class tE {
  constructor() {
    (this.stack = []), (this.stackHeadPosition = -1);
  }
  get length() {
    return this.stackHeadPosition + 1;
  }
  top() {
    return this.stack[this.stackHeadPosition];
  }
  pushArrayState(e) {
    const t = this.getUninitializedStateFromPool();
    (t.type = Jc), (t.position = 0), (t.size = e), (t.array = new Array(e));
  }
  pushMapState(e) {
    const t = this.getUninitializedStateFromPool();
    (t.type = Li), (t.readCount = 0), (t.size = e), (t.map = {});
  }
  getUninitializedStateFromPool() {
    if (
      (this.stackHeadPosition++, this.stackHeadPosition === this.stack.length)
    ) {
      const e = {
        type: void 0,
        size: 0,
        array: void 0,
        position: 0,
        readCount: 0,
        map: void 0,
        key: null,
      };
      this.stack.push(e);
    }
    return this.stack[this.stackHeadPosition];
  }
  release(e) {
    if (this.stack[this.stackHeadPosition] !== e)
      throw new Error(
        "Invalid stack state. Released state is not on top of the stack."
      );
    if (e.type === Jc) {
      const n = e;
      (n.size = 0), (n.array = void 0), (n.position = 0), (n.type = void 0);
    }
    if (e.type === Li || e.type === xp) {
      const n = e;
      (n.size = 0), (n.map = void 0), (n.readCount = 0), (n.type = void 0);
    }
    this.stackHeadPosition--;
  }
  reset() {
    (this.stack.length = 0), (this.stackHeadPosition = -1);
  }
}
const mi = -1,
  Wl = new DataView(new ArrayBuffer(0)),
  sE = new Uint8Array(Wl.buffer);
try {
  Wl.getInt8(0);
} catch (s) {
  if (!(s instanceof RangeError))
    throw new Error(
      "This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access"
    );
}
const Bd = new RangeError("Insufficient data"),
  nE = new Qy();
class zl {
  constructor(e) {
    (this.totalPos = 0),
      (this.pos = 0),
      (this.view = Wl),
      (this.bytes = sE),
      (this.headByte = mi),
      (this.stack = new tE()),
      (this.entered = !1),
      (this.extensionCodec =
        (e == null ? void 0 : e.extensionCodec) ?? ha.defaultCodec),
      (this.context = e == null ? void 0 : e.context),
      (this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ?? !1),
      (this.rawStrings = (e == null ? void 0 : e.rawStrings) ?? !1),
      (this.maxStrLength = (e == null ? void 0 : e.maxStrLength) ?? gi),
      (this.maxBinLength = (e == null ? void 0 : e.maxBinLength) ?? gi),
      (this.maxArrayLength = (e == null ? void 0 : e.maxArrayLength) ?? gi),
      (this.maxMapLength = (e == null ? void 0 : e.maxMapLength) ?? gi),
      (this.maxExtLength = (e == null ? void 0 : e.maxExtLength) ?? gi),
      (this.keyDecoder =
        (e == null ? void 0 : e.keyDecoder) !== void 0 ? e.keyDecoder : nE),
      (this.mapKeyConverter = (e == null ? void 0 : e.mapKeyConverter) ?? eE);
  }
  clone() {
    return new zl({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      rawStrings: this.rawStrings,
      maxStrLength: this.maxStrLength,
      maxBinLength: this.maxBinLength,
      maxArrayLength: this.maxArrayLength,
      maxMapLength: this.maxMapLength,
      maxExtLength: this.maxExtLength,
      keyDecoder: this.keyDecoder,
    });
  }
  reinitializeState() {
    (this.totalPos = 0), (this.headByte = mi), this.stack.reset();
  }
  setBuffer(e) {
    const t = Zc(e);
    (this.bytes = t),
      (this.view = new DataView(t.buffer, t.byteOffset, t.byteLength)),
      (this.pos = 0);
  }
  appendBuffer(e) {
    if (this.headByte === mi && !this.hasRemaining(1)) this.setBuffer(e);
    else {
      const t = this.bytes.subarray(this.pos),
        n = Zc(e),
        r = new Uint8Array(t.length + n.length);
      r.set(t), r.set(n, t.length), this.setBuffer(r);
    }
  }
  hasRemaining(e) {
    return this.view.byteLength - this.pos >= e;
  }
  createExtraByteError(e) {
    const { view: t, pos: n } = this;
    return new RangeError(
      `Extra ${t.byteLength - n} of ${
        t.byteLength
      } byte(s) found at buffer[${e}]`
    );
  }
  decode(e) {
    if (this.entered) return this.clone().decode(e);
    try {
      (this.entered = !0), this.reinitializeState(), this.setBuffer(e);
      const t = this.doDecodeSync();
      if (this.hasRemaining(1)) throw this.createExtraByteError(this.pos);
      return t;
    } finally {
      this.entered = !1;
    }
  }
  *decodeMulti(e) {
    if (this.entered) {
      yield* this.clone().decodeMulti(e);
      return;
    }
    try {
      for (
        this.entered = !0, this.reinitializeState(), this.setBuffer(e);
        this.hasRemaining(1);

      )
        yield this.doDecodeSync();
    } finally {
      this.entered = !1;
    }
  }
  async decodeAsync(e) {
    if (this.entered) return this.clone().decodeAsync(e);
    try {
      this.entered = !0;
      let t = !1,
        n;
      for await (const a of e) {
        if (t)
          throw ((this.entered = !1), this.createExtraByteError(this.totalPos));
        this.appendBuffer(a);
        try {
          (n = this.doDecodeSync()), (t = !0);
        } catch (c) {
          if (!(c instanceof RangeError)) throw c;
        }
        this.totalPos += this.pos;
      }
      if (t) {
        if (this.hasRemaining(1))
          throw this.createExtraByteError(this.totalPos);
        return n;
      }
      const { headByte: r, pos: i, totalPos: o } = this;
      throw new RangeError(
        `Insufficient data in parsing ${rc(
          r
        )} at ${o} (${i} in the current buffer)`
      );
    } finally {
      this.entered = !1;
    }
  }
  decodeArrayStream(e) {
    return this.decodeMultiAsync(e, !0);
  }
  decodeStream(e) {
    return this.decodeMultiAsync(e, !1);
  }
  async *decodeMultiAsync(e, t) {
    if (this.entered) {
      yield* this.clone().decodeMultiAsync(e, t);
      return;
    }
    try {
      this.entered = !0;
      let n = t,
        r = -1;
      for await (const i of e) {
        if (t && r === 0) throw this.createExtraByteError(this.totalPos);
        this.appendBuffer(i),
          n && ((r = this.readArraySize()), (n = !1), this.complete());
        try {
          for (; yield this.doDecodeSync(), --r !== 0; );
        } catch (o) {
          if (!(o instanceof RangeError)) throw o;
        }
        this.totalPos += this.pos;
      }
    } finally {
      this.entered = !1;
    }
  }
  doDecodeSync() {
    e: for (;;) {
      const e = this.readHeadByte();
      let t;
      if (e >= 224) t = e - 256;
      else if (e < 192)
        if (e < 128) t = e;
        else if (e < 144) {
          const r = e - 128;
          if (r !== 0) {
            this.pushMapState(r), this.complete();
            continue e;
          } else t = {};
        } else if (e < 160) {
          const r = e - 144;
          if (r !== 0) {
            this.pushArrayState(r), this.complete();
            continue e;
          } else t = [];
        } else {
          const r = e - 160;
          t = this.decodeString(r, 0);
        }
      else if (e === 192) t = null;
      else if (e === 194) t = !1;
      else if (e === 195) t = !0;
      else if (e === 202) t = this.readF32();
      else if (e === 203) t = this.readF64();
      else if (e === 204) t = this.readU8();
      else if (e === 205) t = this.readU16();
      else if (e === 206) t = this.readU32();
      else if (e === 207)
        this.useBigInt64 ? (t = this.readU64AsBigInt()) : (t = this.readU64());
      else if (e === 208) t = this.readI8();
      else if (e === 209) t = this.readI16();
      else if (e === 210) t = this.readI32();
      else if (e === 211)
        this.useBigInt64 ? (t = this.readI64AsBigInt()) : (t = this.readI64());
      else if (e === 217) {
        const r = this.lookU8();
        t = this.decodeString(r, 1);
      } else if (e === 218) {
        const r = this.lookU16();
        t = this.decodeString(r, 2);
      } else if (e === 219) {
        const r = this.lookU32();
        t = this.decodeString(r, 4);
      } else if (e === 220) {
        const r = this.readU16();
        if (r !== 0) {
          this.pushArrayState(r), this.complete();
          continue e;
        } else t = [];
      } else if (e === 221) {
        const r = this.readU32();
        if (r !== 0) {
          this.pushArrayState(r), this.complete();
          continue e;
        } else t = [];
      } else if (e === 222) {
        const r = this.readU16();
        if (r !== 0) {
          this.pushMapState(r), this.complete();
          continue e;
        } else t = {};
      } else if (e === 223) {
        const r = this.readU32();
        if (r !== 0) {
          this.pushMapState(r), this.complete();
          continue e;
        } else t = {};
      } else if (e === 196) {
        const r = this.lookU8();
        t = this.decodeBinary(r, 1);
      } else if (e === 197) {
        const r = this.lookU16();
        t = this.decodeBinary(r, 2);
      } else if (e === 198) {
        const r = this.lookU32();
        t = this.decodeBinary(r, 4);
      } else if (e === 212) t = this.decodeExtension(1, 0);
      else if (e === 213) t = this.decodeExtension(2, 0);
      else if (e === 214) t = this.decodeExtension(4, 0);
      else if (e === 215) t = this.decodeExtension(8, 0);
      else if (e === 216) t = this.decodeExtension(16, 0);
      else if (e === 199) {
        const r = this.lookU8();
        t = this.decodeExtension(r, 1);
      } else if (e === 200) {
        const r = this.lookU16();
        t = this.decodeExtension(r, 2);
      } else if (e === 201) {
        const r = this.lookU32();
        t = this.decodeExtension(r, 4);
      } else throw new Wt(`Unrecognized type byte: ${rc(e)}`);
      this.complete();
      const n = this.stack;
      for (; n.length > 0; ) {
        const r = n.top();
        if (r.type === Jc)
          if (((r.array[r.position] = t), r.position++, r.position === r.size))
            (t = r.array), n.release(r);
          else continue e;
        else if (r.type === Li) {
          if (t === "__proto__")
            throw new Wt("The key __proto__ is not allowed");
          (r.key = this.mapKeyConverter(t)), (r.type = xp);
          continue e;
        } else if (((r.map[r.key] = t), r.readCount++, r.readCount === r.size))
          (t = r.map), n.release(r);
        else {
          (r.key = null), (r.type = Li);
          continue e;
        }
      }
      return t;
    }
  }
  readHeadByte() {
    return (
      this.headByte === mi && (this.headByte = this.readU8()), this.headByte
    );
  }
  complete() {
    this.headByte = mi;
  }
  readArraySize() {
    const e = this.readHeadByte();
    switch (e) {
      case 220:
        return this.readU16();
      case 221:
        return this.readU32();
      default: {
        if (e < 160) return e - 144;
        throw new Wt(`Unrecognized array type byte: ${rc(e)}`);
      }
    }
  }
  pushMapState(e) {
    if (e > this.maxMapLength)
      throw new Wt(
        `Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`
      );
    this.stack.pushMapState(e);
  }
  pushArrayState(e) {
    if (e > this.maxArrayLength)
      throw new Wt(
        `Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`
      );
    this.stack.pushArrayState(e);
  }
  decodeString(e, t) {
    return !this.rawStrings || this.stateIsMapKey()
      ? this.decodeUtf8String(e, t)
      : this.decodeBinary(e, t);
  }
  decodeUtf8String(e, t) {
    var i;
    if (e > this.maxStrLength)
      throw new Wt(
        `Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`
      );
    if (this.bytes.byteLength < this.pos + t + e) throw Bd;
    const n = this.pos + t;
    let r;
    return (
      this.stateIsMapKey() && (i = this.keyDecoder) != null && i.canBeCached(e)
        ? (r = this.keyDecoder.decode(this.bytes, n, e))
        : (r = $y(this.bytes, n, e)),
      (this.pos += t + e),
      r
    );
  }
  stateIsMapKey() {
    return this.stack.length > 0 ? this.stack.top().type === Li : !1;
  }
  decodeBinary(e, t) {
    if (e > this.maxBinLength)
      throw new Wt(
        `Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`
      );
    if (!this.hasRemaining(e + t)) throw Bd;
    const n = this.pos + t,
      r = this.bytes.subarray(n, n + e);
    return (this.pos += t + e), r;
  }
  decodeExtension(e, t) {
    if (e > this.maxExtLength)
      throw new Wt(
        `Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`
      );
    const n = this.view.getInt8(this.pos + t),
      r = this.decodeBinary(e, t + 1);
    return this.extensionCodec.decode(r, n, this.context);
  }
  lookU8() {
    return this.view.getUint8(this.pos);
  }
  lookU16() {
    return this.view.getUint16(this.pos);
  }
  lookU32() {
    return this.view.getUint32(this.pos);
  }
  readU8() {
    const e = this.view.getUint8(this.pos);
    return this.pos++, e;
  }
  readI8() {
    const e = this.view.getInt8(this.pos);
    return this.pos++, e;
  }
  readU16() {
    const e = this.view.getUint16(this.pos);
    return (this.pos += 2), e;
  }
  readI16() {
    const e = this.view.getInt16(this.pos);
    return (this.pos += 2), e;
  }
  readU32() {
    const e = this.view.getUint32(this.pos);
    return (this.pos += 4), e;
  }
  readI32() {
    const e = this.view.getInt32(this.pos);
    return (this.pos += 4), e;
  }
  readU64() {
    const e = Ly(this.view, this.pos);
    return (this.pos += 8), e;
  }
  readI64() {
    const e = Rp(this.view, this.pos);
    return (this.pos += 8), e;
  }
  readU64AsBigInt() {
    const e = this.view.getBigUint64(this.pos);
    return (this.pos += 8), e;
  }
  readI64AsBigInt() {
    const e = this.view.getBigInt64(this.pos);
    return (this.pos += 8), e;
  }
  readF32() {
    const e = this.view.getFloat32(this.pos);
    return (this.pos += 4), e;
  }
  readF64() {
    const e = this.view.getFloat64(this.pos);
    return (this.pos += 8), e;
  }
}
function rE(s, e) {
  return new zl(e).decode(s);
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function iE(
  s
) {
  return (
    s instanceof Uint8Array ||
    (ArrayBuffer.isView(s) && s.constructor.name === "Uint8Array")
  );
}
function Pp(s, e) {
  return Array.isArray(e)
    ? e.length === 0
      ? !0
      : s
      ? e.every((t) => typeof t == "string")
      : e.every((t) => Number.isSafeInteger(t))
    : !1;
}
function pa(s, e) {
  if (typeof e != "string") throw new Error(`${s}: string expected`);
  return !0;
}
function Vl(s) {
  if (!Number.isSafeInteger(s)) throw new Error(`invalid integer: ${s}`);
}
function Xc(s) {
  if (!Array.isArray(s)) throw new Error("array expected");
}
function fa(s, e) {
  if (!Pp(!0, e)) throw new Error(`${s}: array of strings expected`);
}
function oE(s, e) {
  if (!Pp(!1, e)) throw new Error(`${s}: array of numbers expected`);
}
function aE(...s) {
  const e = (i) => i,
    t = (i, o) => (a) => i(o(a)),
    n = s.map((i) => i.encode).reduceRight(t, e),
    r = s.map((i) => i.decode).reduce(t, e);
  return { encode: n, decode: r };
}
function cE(s) {
  const e = typeof s == "string" ? s.split("") : s,
    t = e.length;
  fa("alphabet", e);
  const n = new Map(e.map((r, i) => [r, i]));
  return {
    encode: (r) => (
      Xc(r),
      r.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= t)
          throw new Error(
            `alphabet.encode: digit index outside alphabet "${i}". Allowed: ${s}`
          );
        return e[i];
      })
    ),
    decode: (r) => (
      Xc(r),
      r.map((i) => {
        pa("alphabet.decode", i);
        const o = n.get(i);
        if (o === void 0)
          throw new Error(`Unknown letter: "${i}". Allowed: ${s}`);
        return o;
      })
    ),
  };
}
function lE(s = "") {
  return (
    pa("join", s),
    {
      encode: (e) => (fa("join.decode", e), e.join(s)),
      decode: (e) => (pa("join.decode", e), e.split(s)),
    }
  );
}
function dE(s, e = "=") {
  return (
    Vl(s),
    pa("padding", e),
    {
      encode(t) {
        for (fa("padding.encode", t); (t.length * s) % 8; ) t.push(e);
        return t;
      },
      decode(t) {
        fa("padding.decode", t);
        let n = t.length;
        if ((n * s) % 8)
          throw new Error(
            "padding: invalid, string should have whole number of bytes"
          );
        for (; n > 0 && t[n - 1] === e; n--)
          if (((n - 1) * s) % 8 === 0)
            throw new Error("padding: invalid, string has too much padding");
        return t.slice(0, n);
      },
    }
  );
}
const Op = (s, e) => (e === 0 ? s : Op(e, s % e)),
  ga = (s, e) => s + (e - Op(s, e)),
  ic = (() => {
    let s = [];
    for (let e = 0; e < 40; e++) s.push(2 ** e);
    return s;
  })();
function Fd(s, e, t, n) {
  if ((Xc(s), e <= 0 || e > 32))
    throw new Error(`convertRadix2: wrong from=${e}`);
  if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong to=${t}`);
  if (ga(e, t) > 32)
    throw new Error(
      `convertRadix2: carry overflow from=${e} to=${t} carryBits=${ga(e, t)}`
    );
  let r = 0,
    i = 0;
  const o = ic[e],
    a = ic[t] - 1,
    c = [];
  for (const l of s) {
    if ((Vl(l), l >= o))
      throw new Error(`convertRadix2: invalid data word=${l} from=${e}`);
    if (((r = (r << e) | l), i + e > 32))
      throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);
    for (i += e; i >= t; i -= t) c.push(((r >> (i - t)) & a) >>> 0);
    const d = ic[i];
    if (d === void 0) throw new Error("invalid carry");
    r &= d - 1;
  }
  if (((r = (r << (t - i)) & a), !n && i >= e))
    throw new Error("Excess padding");
  if (!n && r > 0) throw new Error(`Non-zero padding: ${r}`);
  return n && i > 0 && c.push(r >>> 0), c;
}
function uE(s, e = !1) {
  if ((Vl(s), s <= 0 || s > 32))
    throw new Error("radix2: bits should be in (0..32]");
  if (ga(8, s) > 32 || ga(s, 8) > 32) throw new Error("radix2: carry overflow");
  return {
    encode: (t) => {
      if (!iE(t)) throw new Error("radix2.encode input should be Uint8Array");
      return Fd(Array.from(t), 8, s, !e);
    },
    decode: (t) => (oE("radix2.decode", t), Uint8Array.from(Fd(t, s, 8, e))),
  };
}
const hE = aE(uE(5), cE("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), dE(5), lE(""));
function Kl(s) {
  return globalThis.Buffer != null
    ? new Uint8Array(s.buffer, s.byteOffset, s.byteLength)
    : s;
}
function kp(s = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? Kl(globalThis.Buffer.allocUnsafe(s))
    : new Uint8Array(s);
}
function Mi(s, e) {
  e || (e = s.reduce((r, i) => r + i.length, 0));
  const t = kp(e);
  let n = 0;
  for (const r of s) t.set(r, n), (n += r.length);
  return Kl(t);
}
function Up(s, e, t, n) {
  return {
    name: s,
    prefix: e,
    encoder: { name: s, prefix: e, encode: t },
    decoder: { decode: n },
  };
}
const jd = Up(
    "utf8",
    "u",
    (s) => "u" + new TextDecoder("utf8").decode(s),
    (s) => new TextEncoder().encode(s.substring(1))
  ),
  oc = Up(
    "ascii",
    "a",
    (s) => {
      let e = "a";
      for (let t = 0; t < s.length; t++) e += String.fromCharCode(s[t]);
      return e;
    },
    (s) => {
      s = s.substring(1);
      const e = kp(s.length);
      for (let t = 0; t < s.length; t++) e[t] = s.charCodeAt(t);
      return e;
    }
  ),
  $p = {
    utf8: jd,
    "utf-8": jd,
    hex: wd.base16,
    latin1: oc,
    ascii: oc,
    binary: oc,
    ...wd,
  };
function is(s, e = "utf8") {
  const t = $p[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? Kl(globalThis.Buffer.from(s, "utf-8"))
    : t.decoder.decode(`${t.prefix}${s}`);
}
function Ft(s, e = "utf8") {
  const t = $p[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(s.buffer, s.byteOffset, s.byteLength).toString(
        "utf8"
      )
    : t.encoder.encode(s).substring(1);
}
var ac, qd;
function Dp() {
  if (qd) return ac;
  qd = 1;
  const s = "Input must be an string, Buffer or Uint8Array";
  function e(o) {
    let a;
    if (o instanceof Uint8Array) a = o;
    else if (typeof o == "string") a = new TextEncoder().encode(o);
    else throw new Error(s);
    return a;
  }
  function t(o) {
    return Array.prototype.map
      .call(o, function (a) {
        return (a < 16 ? "0" : "") + a.toString(16);
      })
      .join("");
  }
  function n(o) {
    return (4294967296 + o).toString(16).substring(1);
  }
  function r(o, a, c) {
    let l =
      `
` +
      o +
      " = ";
    for (let d = 0; d < a.length; d += 2) {
      if (c === 32)
        (l += n(a[d]).toUpperCase()),
          (l += " "),
          (l += n(a[d + 1]).toUpperCase());
      else if (c === 64)
        (l += n(a[d + 1]).toUpperCase()), (l += n(a[d]).toUpperCase());
      else throw new Error("Invalid size " + c);
      d % 6 === 4
        ? (l +=
            `
` + new Array(o.length + 4).join(" "))
        : d < a.length - 2 && (l += " ");
    }
    console.log(l);
  }
  function i(o, a, c) {
    let l = new Date().getTime();
    const d = new Uint8Array(a);
    for (let p = 0; p < a; p++) d[p] = p % 256;
    const u = new Date().getTime();
    console.log("Generated random input in " + (u - l) + "ms"), (l = u);
    for (let p = 0; p < c; p++) {
      const w = o(d),
        g = new Date().getTime(),
        m = g - l;
      (l = g),
        console.log("Hashed in " + m + "ms: " + w.substring(0, 20) + "..."),
        console.log(
          Math.round((a / (1 << 20) / (m / 1e3)) * 100) / 100 + " MB PER SECOND"
        );
    }
  }
  return (
    (ac = { normalizeInput: e, toHex: t, debugPrint: r, testSpeed: i }), ac
  );
}
var cc, Hd;
function pE() {
  if (Hd) return cc;
  Hd = 1;
  const s = Dp();
  function e(E, b, _) {
    const N = E[b] + E[_];
    let A = E[b + 1] + E[_ + 1];
    N >= 4294967296 && A++, (E[b] = N), (E[b + 1] = A);
  }
  function t(E, b, _, N) {
    let A = E[b] + _;
    _ < 0 && (A += 4294967296);
    let L = E[b + 1] + N;
    A >= 4294967296 && L++, (E[b] = A), (E[b + 1] = L);
  }
  function n(E, b) {
    return E[b] ^ (E[b + 1] << 8) ^ (E[b + 2] << 16) ^ (E[b + 3] << 24);
  }
  function r(E, b, _, N, A, L) {
    const Q = l[A],
      K = l[A + 1],
      C = l[L],
      T = l[L + 1];
    e(c, E, b), t(c, E, Q, K);
    let v = c[N] ^ c[E],
      I = c[N + 1] ^ c[E + 1];
    (c[N] = I),
      (c[N + 1] = v),
      e(c, _, N),
      (v = c[b] ^ c[_]),
      (I = c[b + 1] ^ c[_ + 1]),
      (c[b] = (v >>> 24) ^ (I << 8)),
      (c[b + 1] = (I >>> 24) ^ (v << 8)),
      e(c, E, b),
      t(c, E, C, T),
      (v = c[N] ^ c[E]),
      (I = c[N + 1] ^ c[E + 1]),
      (c[N] = (v >>> 16) ^ (I << 16)),
      (c[N + 1] = (I >>> 16) ^ (v << 16)),
      e(c, _, N),
      (v = c[b] ^ c[_]),
      (I = c[b + 1] ^ c[_ + 1]),
      (c[b] = (I >>> 31) ^ (v << 1)),
      (c[b + 1] = (v >>> 31) ^ (I << 1));
  }
  const i = new Uint32Array([
      4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242,
      1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924,
      4215389547, 528734635, 327033209, 1541459225,
    ]),
    o = [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15,
      13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6,
      7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5,
      7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4,
      13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8,
      11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9,
      11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11,
      9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
      14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
    ],
    a = new Uint8Array(
      o.map(function (E) {
        return E * 2;
      })
    ),
    c = new Uint32Array(32),
    l = new Uint32Array(32);
  function d(E, b) {
    let _ = 0;
    for (_ = 0; _ < 16; _++) (c[_] = E.h[_]), (c[_ + 16] = i[_]);
    for (
      c[24] = c[24] ^ E.t,
        c[25] = c[25] ^ (E.t / 4294967296),
        b && ((c[28] = ~c[28]), (c[29] = ~c[29])),
        _ = 0;
      _ < 32;
      _++
    )
      l[_] = n(E.b, 4 * _);
    for (_ = 0; _ < 12; _++)
      r(0, 8, 16, 24, a[_ * 16 + 0], a[_ * 16 + 1]),
        r(2, 10, 18, 26, a[_ * 16 + 2], a[_ * 16 + 3]),
        r(4, 12, 20, 28, a[_ * 16 + 4], a[_ * 16 + 5]),
        r(6, 14, 22, 30, a[_ * 16 + 6], a[_ * 16 + 7]),
        r(0, 10, 20, 30, a[_ * 16 + 8], a[_ * 16 + 9]),
        r(2, 12, 22, 24, a[_ * 16 + 10], a[_ * 16 + 11]),
        r(4, 14, 16, 26, a[_ * 16 + 12], a[_ * 16 + 13]),
        r(6, 8, 18, 28, a[_ * 16 + 14], a[_ * 16 + 15]);
    for (_ = 0; _ < 16; _++) E.h[_] = E.h[_] ^ c[_] ^ c[_ + 16];
  }
  const u = new Uint8Array([
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  ]);
  function p(E, b, _, N) {
    if (E === 0 || E > 64)
      throw new Error("Illegal output length, expected 0 < length <= 64");
    if (b && b.length > 64)
      throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
    if (_ && _.length !== 16)
      throw new Error("Illegal salt, expected Uint8Array with length is 16");
    if (N && N.length !== 16)
      throw new Error(
        "Illegal personal, expected Uint8Array with length is 16"
      );
    const A = {
      b: new Uint8Array(128),
      h: new Uint32Array(16),
      t: 0,
      c: 0,
      outlen: E,
    };
    u.fill(0),
      (u[0] = E),
      b && (u[1] = b.length),
      (u[2] = 1),
      (u[3] = 1),
      _ && u.set(_, 32),
      N && u.set(N, 48);
    for (let L = 0; L < 16; L++) A.h[L] = i[L] ^ n(u, L * 4);
    return b && (w(A, b), (A.c = 128)), A;
  }
  function w(E, b) {
    for (let _ = 0; _ < b.length; _++)
      E.c === 128 && ((E.t += E.c), d(E, !1), (E.c = 0)), (E.b[E.c++] = b[_]);
  }
  function g(E) {
    for (E.t += E.c; E.c < 128; ) E.b[E.c++] = 0;
    d(E, !0);
    const b = new Uint8Array(E.outlen);
    for (let _ = 0; _ < E.outlen; _++) b[_] = E.h[_ >> 2] >> (8 * (_ & 3));
    return b;
  }
  function m(E, b, _, N, A) {
    (_ = _ || 64),
      (E = s.normalizeInput(E)),
      N && (N = s.normalizeInput(N)),
      A && (A = s.normalizeInput(A));
    const L = p(_, b, N, A);
    return w(L, E), g(L);
  }
  function f(E, b, _, N, A) {
    const L = m(E, b, _, N, A);
    return s.toHex(L);
  }
  return (
    (cc = {
      blake2b: m,
      blake2bHex: f,
      blake2bInit: p,
      blake2bUpdate: w,
      blake2bFinal: g,
    }),
    cc
  );
}
var lc, Wd;
function fE() {
  if (Wd) return lc;
  Wd = 1;
  const s = Dp();
  function e(g, m) {
    return g[m] ^ (g[m + 1] << 8) ^ (g[m + 2] << 16) ^ (g[m + 3] << 24);
  }
  function t(g, m, f, E, b, _) {
    (o[g] = o[g] + o[m] + b),
      (o[E] = n(o[E] ^ o[g], 16)),
      (o[f] = o[f] + o[E]),
      (o[m] = n(o[m] ^ o[f], 12)),
      (o[g] = o[g] + o[m] + _),
      (o[E] = n(o[E] ^ o[g], 8)),
      (o[f] = o[f] + o[E]),
      (o[m] = n(o[m] ^ o[f], 7));
  }
  function n(g, m) {
    return (g >>> m) ^ (g << (32 - m));
  }
  const r = new Uint32Array([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    i = new Uint8Array([
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15,
      13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6,
      7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5,
      7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4,
      13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8,
      11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9,
      11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11,
      9, 14, 3, 12, 13, 0,
    ]),
    o = new Uint32Array(16),
    a = new Uint32Array(16);
  function c(g, m) {
    let f = 0;
    for (f = 0; f < 8; f++) (o[f] = g.h[f]), (o[f + 8] = r[f]);
    for (
      o[12] ^= g.t, o[13] ^= g.t / 4294967296, m && (o[14] = ~o[14]), f = 0;
      f < 16;
      f++
    )
      a[f] = e(g.b, 4 * f);
    for (f = 0; f < 10; f++)
      t(0, 4, 8, 12, a[i[f * 16 + 0]], a[i[f * 16 + 1]]),
        t(1, 5, 9, 13, a[i[f * 16 + 2]], a[i[f * 16 + 3]]),
        t(2, 6, 10, 14, a[i[f * 16 + 4]], a[i[f * 16 + 5]]),
        t(3, 7, 11, 15, a[i[f * 16 + 6]], a[i[f * 16 + 7]]),
        t(0, 5, 10, 15, a[i[f * 16 + 8]], a[i[f * 16 + 9]]),
        t(1, 6, 11, 12, a[i[f * 16 + 10]], a[i[f * 16 + 11]]),
        t(2, 7, 8, 13, a[i[f * 16 + 12]], a[i[f * 16 + 13]]),
        t(3, 4, 9, 14, a[i[f * 16 + 14]], a[i[f * 16 + 15]]);
    for (f = 0; f < 8; f++) g.h[f] ^= o[f] ^ o[f + 8];
  }
  function l(g, m) {
    if (!(g > 0 && g <= 32))
      throw new Error("Incorrect output length, should be in [1, 32]");
    const f = m ? m.length : 0;
    if (m && !(f > 0 && f <= 32))
      throw new Error("Incorrect key length, should be in [1, 32]");
    const E = {
      h: new Uint32Array(r),
      b: new Uint8Array(64),
      c: 0,
      t: 0,
      outlen: g,
    };
    return (
      (E.h[0] ^= 16842752 ^ (f << 8) ^ g), f > 0 && (d(E, m), (E.c = 64)), E
    );
  }
  function d(g, m) {
    for (let f = 0; f < m.length; f++)
      g.c === 64 && ((g.t += g.c), c(g, !1), (g.c = 0)), (g.b[g.c++] = m[f]);
  }
  function u(g) {
    for (g.t += g.c; g.c < 64; ) g.b[g.c++] = 0;
    c(g, !0);
    const m = new Uint8Array(g.outlen);
    for (let f = 0; f < g.outlen; f++)
      m[f] = (g.h[f >> 2] >> (8 * (f & 3))) & 255;
    return m;
  }
  function p(g, m, f) {
    (f = f || 32), (g = s.normalizeInput(g));
    const E = l(f, m);
    return d(E, g), u(E);
  }
  function w(g, m, f) {
    const E = p(g, m, f);
    return s.toHex(E);
  }
  return (
    (lc = {
      blake2s: p,
      blake2sHex: w,
      blake2sInit: l,
      blake2sUpdate: d,
      blake2sFinal: u,
    }),
    lc
  );
}
var dc, zd;
function gE() {
  if (zd) return dc;
  zd = 1;
  const s = pE(),
    e = fE();
  return (
    (dc = {
      blake2b: s.blake2b,
      blake2bHex: s.blake2bHex,
      blake2bInit: s.blake2bInit,
      blake2bUpdate: s.blake2bUpdate,
      blake2bFinal: s.blake2bFinal,
      blake2s: e.blake2s,
      blake2sHex: e.blake2sHex,
      blake2sInit: e.blake2sInit,
      blake2sUpdate: e.blake2sUpdate,
      blake2sFinal: e.blake2sFinal,
    }),
    dc
  );
}
var mE = gE(),
  wE = {};
const yE = ":";
function Fr(s) {
  const [e, t] = s.split(yE);
  return { namespace: e, reference: t };
}
function Lp(s, e) {
  return s.includes(":") ? [s] : e.chains || [];
}
var EE = Object.defineProperty,
  bE = Object.defineProperties,
  _E = Object.getOwnPropertyDescriptors,
  Vd = Object.getOwnPropertySymbols,
  CE = Object.prototype.hasOwnProperty,
  vE = Object.prototype.propertyIsEnumerable,
  Kd = (s, e, t) =>
    e in s
      ? EE(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Gd = (s, e) => {
    for (var t in e || (e = {})) CE.call(e, t) && Kd(s, t, e[t]);
    if (Vd) for (var t of Vd(e)) vE.call(e, t) && Kd(s, t, e[t]);
    return s;
  },
  AE = (s, e) => bE(s, _E(e));
const IE = "ReactNative",
  Kt = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown",
  },
  SE = "js";
function ma() {
  return (
    typeof process < "u" &&
    typeof process.versions < "u" &&
    typeof process.versions.node < "u"
  );
}
function kn() {
  return !en.getDocument() && !!en.getNavigator() && navigator.product === IE;
}
function NE() {
  return (
    kn() &&
    typeof global < "u" &&
    typeof (global == null ? void 0 : global.Platform) < "u" &&
    (global == null ? void 0 : global.Platform.OS) === "android"
  );
}
function TE() {
  return (
    kn() &&
    typeof global < "u" &&
    typeof (global == null ? void 0 : global.Platform) < "u" &&
    (global == null ? void 0 : global.Platform.OS) === "ios"
  );
}
function oi() {
  return !ma() && !!en.getNavigator() && !!en.getDocument();
}
function No() {
  return kn()
    ? Kt.reactNative
    : ma()
    ? Kt.node
    : oi()
    ? Kt.browser
    : Kt.unknown;
}
function Yd() {
  var s;
  try {
    return kn() &&
      typeof global < "u" &&
      typeof (global == null ? void 0 : global.Application) < "u"
      ? (s = global.Application) == null
        ? void 0
        : s.applicationId
      : void 0;
  } catch {
    return;
  }
}
function RE(s, e) {
  const t = new URLSearchParams(s);
  for (const n of Object.keys(e).sort())
    if (e.hasOwnProperty(n)) {
      const r = e[n];
      r !== void 0 && t.set(n, r);
    }
  return t.toString();
}
function xE(s) {
  var e, t;
  const n = Mp();
  try {
    return (
      s != null &&
        s.url &&
        n.url &&
        new URL(s.url).host !== new URL(n.url).host &&
        (console.warn(
          `The configured WalletConnect 'metadata.url':${s.url} differs from the actual page url:${n.url}. This is probably unintended and can lead to issues.`
        ),
        (s.url = n.url)),
      (e = s == null ? void 0 : s.icons) != null &&
        e.length &&
        s.icons.length > 0 &&
        (s.icons = s.icons.filter((r) => r !== "")),
      AE(Gd(Gd({}, n), s), {
        url: (s == null ? void 0 : s.url) || n.url,
        name: (s == null ? void 0 : s.name) || n.name,
        description: (s == null ? void 0 : s.description) || n.description,
        icons:
          (t = s == null ? void 0 : s.icons) != null &&
          t.length &&
          s.icons.length > 0
            ? s.icons
            : n.icons,
      })
    );
  } catch (r) {
    return console.warn("Error populating app metadata", r), s || n;
  }
}
function Mp() {
  return (
    Gg.getWindowMetadata() || {
      name: "",
      description: "",
      url: "",
      icons: [""],
    }
  );
}
function PE() {
  if (
    No() === Kt.reactNative &&
    typeof global < "u" &&
    typeof (global == null ? void 0 : global.Platform) < "u"
  ) {
    const { OS: t, Version: n } = global.Platform;
    return [t, n].join("-");
  }
  const s = Zg();
  if (s === null) return "unknown";
  const e = s.os ? s.os.replace(" ", "").toLowerCase() : "unknown";
  return s.type === "browser"
    ? [e, s.name, s.version].join("-")
    : [e, s.version].join("-");
}
function OE() {
  var s;
  const e = No();
  return e === Kt.browser
    ? [e, ((s = en.getLocation()) == null ? void 0 : s.host) || "unknown"].join(
        ":"
      )
    : e;
}
function Bp(s, e, t) {
  const n = PE(),
    r = OE();
  return [[s, e].join("-"), [SE, t].join("-"), n, r].join("/");
}
function kE({
  protocol: s,
  version: e,
  relayUrl: t,
  sdkVersion: n,
  auth: r,
  projectId: i,
  useOnCloseEvent: o,
  bundleId: a,
  packageName: c,
}) {
  const l = t.split("?"),
    d = Bp(s, e, n),
    u = {
      auth: r,
      ua: d,
      projectId: i,
      useOnCloseEvent: o,
      packageName: c || void 0,
      bundleId: a || void 0,
    },
    p = RE(l[1] || "", u);
  return l[0] + "?" + p;
}
function zn(s, e) {
  return s.filter((t) => e.includes(t)).length === s.length;
}
function Qc(s) {
  return Object.fromEntries(s.entries());
}
function el(s) {
  return new Map(Object.entries(s));
}
function jn(s = j.FIVE_MINUTES, e) {
  const t = j.toMiliseconds(s || j.FIVE_MINUTES);
  let n, r, i, o;
  return {
    resolve: (a) => {
      i && n && (clearTimeout(i), n(a), (o = Promise.resolve(a)));
    },
    reject: (a) => {
      i && r && (clearTimeout(i), r(a));
    },
    done: () =>
      new Promise((a, c) => {
        if (o) return a(o);
        (i = setTimeout(() => {
          const l = new Error(e);
          (o = Promise.reject(l)), c(l);
        }, t)),
          (n = a),
          (r = c);
      }),
  };
}
function _n(s, e, t) {
  return new Promise(async (n, r) => {
    const i = setTimeout(() => r(new Error(t)), e);
    try {
      const o = await s;
      n(o);
    } catch (o) {
      r(o);
    }
    clearTimeout(i);
  });
}
function Fp(s, e) {
  if (typeof e == "string" && e.startsWith(`${s}:`)) return e;
  if (s.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (s.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${s}`);
}
function UE(s) {
  return Fp("topic", s);
}
function $E(s) {
  return Fp("id", s);
}
function jp(s) {
  const [e, t] = s.split(":"),
    n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof t == "string") n.topic = t;
  else if (e === "id" && Number.isInteger(Number(t))) n.id = Number(t);
  else
    throw new Error(
      `Invalid target, expected id:number or topic:string, got ${e}:${t}`
    );
  return n;
}
function st(s, e) {
  return j.fromMiliseconds(Date.now() + j.toMiliseconds(s));
}
function pn(s) {
  return Date.now() >= j.toMiliseconds(s);
}
function Oe(s, e) {
  return `${s}${e ? `:${e}` : ""}`;
}
function Ds(s = [], e = []) {
  return [...new Set([...s, ...e])];
}
async function DE({ id: s, topic: e, wcDeepLink: t }) {
  var n;
  try {
    if (!t) return;
    const r = typeof t == "string" ? JSON.parse(t) : t,
      i = r == null ? void 0 : r.href;
    if (typeof i != "string") return;
    const o = LE(i, s, e),
      a = No();
    if (a === Kt.browser) {
      if (!((n = en.getDocument()) != null && n.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      ME(o);
    } else
      a === Kt.reactNative &&
        typeof (global == null ? void 0 : global.Linking) < "u" &&
        (await global.Linking.openURL(o));
  } catch (r) {
    console.error(r);
  }
}
function LE(s, e, t) {
  const n = `requestId=${e}&sessionTopic=${t}`;
  s.endsWith("/") && (s = s.slice(0, -1));
  let r = `${s}`;
  if (s.startsWith("https://t.me")) {
    const i = s.includes("?") ? "&startapp=" : "?startapp=";
    r = `${r}${i}${qE(n, !0)}`;
  } else r = `${r}/wc?${n}`;
  return r;
}
function ME(s) {
  let e = "_self";
  jE()
    ? (e = "_top")
    : (FE() || s.startsWith("https://") || s.startsWith("http://")) &&
      (e = "_blank"),
    window.open(s, e, "noreferrer noopener");
}
async function BE(s, e) {
  let t = "";
  try {
    if (oi() && ((t = localStorage.getItem(e)), t)) return t;
    t = await s.getItem(e);
  } catch (n) {
    console.error(n);
  }
  return t;
}
function Zd(s, e) {
  if (!s.includes(e)) return null;
  const t = s.split(/([&,?,=])/),
    n = t.indexOf(e);
  return t[n + 2];
}
function Jd() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID
    ? crypto.randomUUID()
    : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (s) => {
        const e = (Math.random() * 16) | 0;
        return (s === "x" ? e : (e & 3) | 8).toString(16);
      });
}
function Gl() {
  return typeof process < "u" && wE.IS_VITEST === "true";
}
function FE() {
  return (
    typeof window < "u" &&
    (!!window.TelegramWebviewProxy ||
      !!window.Telegram ||
      !!window.TelegramWebviewProxyProto)
  );
}
function jE() {
  try {
    return window.self !== window.top;
  } catch {
    return !1;
  }
}
function qE(s, e = !1) {
  const t = Buffer.from(s).toString("base64");
  return e ? t.replace(/[=]/g, "") : t;
}
function qp(s) {
  return Buffer.from(s, "base64").toString("utf-8");
}
function HE(s) {
  return new Promise((e) => setTimeout(e, s));
}
const Fo = BigInt(2 ** 32 - 1),
  Xd = BigInt(32);
function Hp(s, e = !1) {
  return e
    ? { h: Number(s & Fo), l: Number((s >> Xd) & Fo) }
    : { h: Number((s >> Xd) & Fo) | 0, l: Number(s & Fo) | 0 };
}
function Wp(s, e = !1) {
  const t = s.length;
  let n = new Uint32Array(t),
    r = new Uint32Array(t);
  for (let i = 0; i < t; i++) {
    const { h: o, l: a } = Hp(s[i], e);
    [n[i], r[i]] = [o, a];
  }
  return [n, r];
}
const Qd = (s, e, t) => s >>> t,
  eu = (s, e, t) => (s << (32 - t)) | (e >>> t),
  fn = (s, e, t) => (s >>> t) | (e << (32 - t)),
  gn = (s, e, t) => (s << (32 - t)) | (e >>> t),
  Pi = (s, e, t) => (s << (64 - t)) | (e >>> (t - 32)),
  Oi = (s, e, t) => (s >>> (t - 32)) | (e << (64 - t)),
  WE = (s, e) => e,
  zE = (s, e) => s,
  VE = (s, e, t) => (s << t) | (e >>> (32 - t)),
  KE = (s, e, t) => (e << t) | (s >>> (32 - t)),
  GE = (s, e, t) => (e << (t - 32)) | (s >>> (64 - t)),
  YE = (s, e, t) => (s << (t - 32)) | (e >>> (64 - t));
function fs(s, e, t, n) {
  const r = (e >>> 0) + (n >>> 0);
  return { h: (s + t + ((r / 2 ** 32) | 0)) | 0, l: r | 0 };
}
const Yl = (s, e, t) => (s >>> 0) + (e >>> 0) + (t >>> 0),
  Zl = (s, e, t, n) => (e + t + n + ((s / 2 ** 32) | 0)) | 0,
  ZE = (s, e, t, n) => (s >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0),
  JE = (s, e, t, n, r) => (e + t + n + r + ((s / 2 ** 32) | 0)) | 0,
  XE = (s, e, t, n, r) =>
    (s >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
  QE = (s, e, t, n, r, i) => (e + t + n + r + i + ((s / 2 ** 32) | 0)) | 0,
  mr =
    typeof globalThis == "object" && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
function Jl(s) {
  return (
    s instanceof Uint8Array ||
    (ArrayBuffer.isView(s) && s.constructor.name === "Uint8Array")
  );
}
function tn(s) {
  if (!Number.isSafeInteger(s) || s < 0)
    throw new Error("positive integer expected, got " + s);
}
function os(s, ...e) {
  if (!Jl(s)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(s.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + s.length
    );
}
function Xl(s) {
  if (typeof s != "function" || typeof s.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  tn(s.outputLen), tn(s.blockLen);
}
function Rn(s, e = !0) {
  if (s.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && s.finished) throw new Error("Hash#digest() has already been called");
}
function Ql(s, e) {
  os(s);
  const t = e.outputLen;
  if (s.length < t)
    throw new Error(
      "digestInto() expects output buffer of length at least " + t
    );
}
function to(s) {
  return new Uint32Array(s.buffer, s.byteOffset, Math.floor(s.byteLength / 4));
}
function as(...s) {
  for (let e = 0; e < s.length; e++) s[e].fill(0);
}
function uc(s) {
  return new DataView(s.buffer, s.byteOffset, s.byteLength);
}
function Ss(s, e) {
  return (s << (32 - e)) | (s >>> e);
}
const zp = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Vp(s) {
  return (
    ((s << 24) & 4278190080) |
    ((s << 8) & 16711680) |
    ((s >>> 8) & 65280) |
    ((s >>> 24) & 255)
  );
}
const Ks = zp ? (s) => s : (s) => Vp(s);
function eb(s) {
  for (let e = 0; e < s.length; e++) s[e] = Vp(s[e]);
  return s;
}
const mn = zp ? (s) => s : eb,
  Kp =
    typeof Uint8Array.from([]).toHex == "function" &&
    typeof Uint8Array.fromHex == "function",
  tb = Array.from({ length: 256 }, (s, e) => e.toString(16).padStart(2, "0"));
function so(s) {
  if ((os(s), Kp)) return s.toHex();
  let e = "";
  for (let t = 0; t < s.length; t++) e += tb[s[t]];
  return e;
}
const zs = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function tu(s) {
  if (s >= zs._0 && s <= zs._9) return s - zs._0;
  if (s >= zs.A && s <= zs.F) return s - (zs.A - 10);
  if (s >= zs.a && s <= zs.f) return s - (zs.a - 10);
}
function ed(s) {
  if (typeof s != "string")
    throw new Error("hex string expected, got " + typeof s);
  if (Kp) return Uint8Array.fromHex(s);
  const e = s.length,
    t = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < t; r++, i += 2) {
    const o = tu(s.charCodeAt(i)),
      a = tu(s.charCodeAt(i + 1));
    if (o === void 0 || a === void 0) {
      const c = s[i] + s[i + 1];
      throw new Error(
        'hex string expected, got non-hex character "' + c + '" at index ' + i
      );
    }
    n[r] = o * 16 + a;
  }
  return n;
}
function sb(s) {
  if (typeof s != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(s));
}
function Es(s) {
  return typeof s == "string" && (s = sb(s)), os(s), s;
}
function Vn(...s) {
  let e = 0;
  for (let n = 0; n < s.length; n++) {
    const r = s[n];
    os(r), (e += r.length);
  }
  const t = new Uint8Array(e);
  for (let n = 0, r = 0; n < s.length; n++) {
    const i = s[n];
    t.set(i, r), (r += i.length);
  }
  return t;
}
let La = class {};
function To(s) {
  const e = (n) => s().update(Es(n)).digest(),
    t = s();
  return (
    (e.outputLen = t.outputLen),
    (e.blockLen = t.blockLen),
    (e.create = () => s()),
    e
  );
}
function nb(s) {
  const e = (n, r) => s(r).update(Es(n)).digest(),
    t = s({});
  return (
    (e.outputLen = t.outputLen),
    (e.blockLen = t.blockLen),
    (e.create = (n) => s(n)),
    e
  );
}
function ai(s = 32) {
  if (mr && typeof mr.getRandomValues == "function")
    return mr.getRandomValues(new Uint8Array(s));
  if (mr && typeof mr.randomBytes == "function")
    return Uint8Array.from(mr.randomBytes(s));
  throw new Error("crypto.getRandomValues must be defined");
}
const rb = BigInt(0),
  wi = BigInt(1),
  ib = BigInt(2),
  ob = BigInt(7),
  ab = BigInt(256),
  cb = BigInt(113),
  Gp = [],
  Yp = [],
  Zp = [];
for (let s = 0, e = wi, t = 1, n = 0; s < 24; s++) {
  ([t, n] = [n, (2 * t + 3 * n) % 5]),
    Gp.push(2 * (5 * n + t)),
    Yp.push((((s + 1) * (s + 2)) / 2) % 64);
  let r = rb;
  for (let i = 0; i < 7; i++)
    (e = ((e << wi) ^ ((e >> ob) * cb)) % ab),
      e & ib && (r ^= wi << ((wi << BigInt(i)) - wi));
  Zp.push(r);
}
const Jp = Wp(Zp, !0),
  lb = Jp[0],
  db = Jp[1],
  su = (s, e, t) => (t > 32 ? GE(s, e, t) : VE(s, e, t)),
  nu = (s, e, t) => (t > 32 ? YE(s, e, t) : KE(s, e, t));
function ub(s, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      t[o] = s[o] ^ s[o + 10] ^ s[o + 20] ^ s[o + 30] ^ s[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        c = (o + 2) % 10,
        l = t[c],
        d = t[c + 1],
        u = su(l, d, 1) ^ t[a],
        p = nu(l, d, 1) ^ t[a + 1];
      for (let w = 0; w < 50; w += 10) (s[o + w] ^= u), (s[o + w + 1] ^= p);
    }
    let r = s[2],
      i = s[3];
    for (let o = 0; o < 24; o++) {
      const a = Yp[o],
        c = su(r, i, a),
        l = nu(r, i, a),
        d = Gp[o];
      (r = s[d]), (i = s[d + 1]), (s[d] = c), (s[d + 1] = l);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) t[a] = s[o + a];
      for (let a = 0; a < 10; a++)
        s[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    (s[0] ^= lb[n]), (s[1] ^= db[n]);
  }
  as(t);
}
let hb = class Xp extends La {
  constructor(e, t, n, r = !1, i = 24) {
    if (
      (super(),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      (this.enableXOF = !1),
      (this.blockLen = e),
      (this.suffix = t),
      (this.outputLen = n),
      (this.enableXOF = r),
      (this.rounds = i),
      tn(n),
      !(0 < e && e < 200))
    )
      throw new Error("only keccak-f1600 function is supported");
    (this.state = new Uint8Array(200)), (this.state32 = to(this.state));
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    mn(this.state32),
      ub(this.state32, this.rounds),
      mn(this.state32),
      (this.posOut = 0),
      (this.pos = 0);
  }
  update(e) {
    Rn(this), (e = Es(e)), os(e);
    const { blockLen: t, state: n } = this,
      r = e.length;
    for (let i = 0; i < r; ) {
      const o = Math.min(t - this.pos, r - i);
      for (let a = 0; a < o; a++) n[this.pos++] ^= e[i++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: t, pos: n, blockLen: r } = this;
    (e[n] ^= t),
      t & 128 && n === r - 1 && this.keccak(),
      (e[r - 1] ^= 128),
      this.keccak();
  }
  writeInto(e) {
    Rn(this, !1), os(e), this.finish();
    const t = this.state,
      { blockLen: n } = this;
    for (let r = 0, i = e.length; r < i; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, i - r);
      e.set(t.subarray(this.posOut, this.posOut + o), r),
        (this.posOut += o),
        (r += o);
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return tn(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if ((Ql(e, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), as(this.state);
  }
  _cloneInto(e) {
    const {
      blockLen: t,
      suffix: n,
      outputLen: r,
      rounds: i,
      enableXOF: o,
    } = this;
    return (
      e || (e = new Xp(t, n, r, o, i)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = i),
      (e.suffix = n),
      (e.outputLen = r),
      (e.enableXOF = o),
      (e.destroyed = this.destroyed),
      e
    );
  }
};
const pb = (s, e, t) => To(() => new hb(e, s, t)),
  fb = pb(1, 136, 256 / 8);
function gb(s, e, t, n) {
  if (typeof s.setBigUint64 == "function") return s.setBigUint64(e, t, n);
  const r = BigInt(32),
    i = BigInt(4294967295),
    o = Number((t >> r) & i),
    a = Number(t & i),
    c = n ? 4 : 0,
    l = n ? 0 : 4;
  s.setUint32(e + c, o, n), s.setUint32(e + l, a, n);
}
function mb(s, e, t) {
  return (s & e) ^ (~s & t);
}
function wb(s, e, t) {
  return (s & e) ^ (s & t) ^ (e & t);
}
let Qp = class extends La {
  constructor(e, t, n, r) {
    super(),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.blockLen = e),
      (this.outputLen = t),
      (this.padOffset = n),
      (this.isLE = r),
      (this.buffer = new Uint8Array(e)),
      (this.view = uc(this.buffer));
  }
  update(e) {
    Rn(this), (e = Es(e)), os(e);
    const { view: t, buffer: n, blockLen: r } = this,
      i = e.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(r - this.pos, i - o);
      if (a === r) {
        const c = uc(e);
        for (; r <= i - o; o += r) this.process(c, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === r && (this.process(t, 0), (this.pos = 0));
    }
    return (this.length += e.length), this.roundClean(), this;
  }
  digestInto(e) {
    Rn(this), Ql(e, this), (this.finished = !0);
    const { buffer: t, view: n, blockLen: r, isLE: i } = this;
    let { pos: o } = this;
    (t[o++] = 128),
      as(this.buffer.subarray(o)),
      this.padOffset > r - o && (this.process(n, 0), (o = 0));
    for (let u = o; u < r; u++) t[u] = 0;
    gb(n, r - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = uc(e),
      c = this.outputLen;
    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = c / 4,
      d = this.get();
    if (l > d.length) throw new Error("_sha2: outputLen bigger than state");
    for (let u = 0; u < l; u++) a.setUint32(4 * u, d[u], i);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const {
      blockLen: t,
      buffer: n,
      length: r,
      finished: i,
      destroyed: o,
      pos: a,
    } = this;
    return (
      (e.destroyed = o),
      (e.finished = i),
      (e.length = r),
      (e.pos = a),
      r % t && e.buffer.set(n),
      e
    );
  }
  clone() {
    return this._cloneInto();
  }
};
const an = Uint32Array.from([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ]),
  mt = Uint32Array.from([
    3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999,
    355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025,
    3675008525, 1694076839, 1203062813, 3204075428,
  ]),
  wt = Uint32Array.from([
    1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
    2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199,
    528734635, 4215389547, 1541459225, 327033209,
  ]),
  yb = Uint32Array.from([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  cn = new Uint32Array(64);
let Eb = class extends Qp {
  constructor(e = 32) {
    super(64, e, 8, !1),
      (this.A = an[0] | 0),
      (this.B = an[1] | 0),
      (this.C = an[2] | 0),
      (this.D = an[3] | 0),
      (this.E = an[4] | 0),
      (this.F = an[5] | 0),
      (this.G = an[6] | 0),
      (this.H = an[7] | 0);
  }
  get() {
    const { A: e, B: t, C: n, D: r, E: i, F: o, G: a, H: c } = this;
    return [e, t, n, r, i, o, a, c];
  }
  set(e, t, n, r, i, o, a, c) {
    (this.A = e | 0),
      (this.B = t | 0),
      (this.C = n | 0),
      (this.D = r | 0),
      (this.E = i | 0),
      (this.F = o | 0),
      (this.G = a | 0),
      (this.H = c | 0);
  }
  process(e, t) {
    for (let u = 0; u < 16; u++, t += 4) cn[u] = e.getUint32(t, !1);
    for (let u = 16; u < 64; u++) {
      const p = cn[u - 15],
        w = cn[u - 2],
        g = Ss(p, 7) ^ Ss(p, 18) ^ (p >>> 3),
        m = Ss(w, 17) ^ Ss(w, 19) ^ (w >>> 10);
      cn[u] = (m + cn[u - 7] + g + cn[u - 16]) | 0;
    }
    let { A: n, B: r, C: i, D: o, E: a, F: c, G: l, H: d } = this;
    for (let u = 0; u < 64; u++) {
      const p = Ss(a, 6) ^ Ss(a, 11) ^ Ss(a, 25),
        w = (d + p + mb(a, c, l) + yb[u] + cn[u]) | 0,
        g = ((Ss(n, 2) ^ Ss(n, 13) ^ Ss(n, 22)) + wb(n, r, i)) | 0;
      (d = l),
        (l = c),
        (c = a),
        (a = (o + w) | 0),
        (o = i),
        (i = r),
        (r = n),
        (n = (w + g) | 0);
    }
    (n = (n + this.A) | 0),
      (r = (r + this.B) | 0),
      (i = (i + this.C) | 0),
      (o = (o + this.D) | 0),
      (a = (a + this.E) | 0),
      (c = (c + this.F) | 0),
      (l = (l + this.G) | 0),
      (d = (d + this.H) | 0),
      this.set(n, r, i, o, a, c, l, d);
  }
  roundClean() {
    as(cn);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), as(this.buffer);
  }
};
const ef = Wp(
    [
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817",
    ].map((s) => BigInt(s))
  ),
  bb = ef[0],
  _b = ef[1],
  ln = new Uint32Array(80),
  dn = new Uint32Array(80);
let td = class extends Qp {
    constructor(e = 64) {
      super(128, e, 16, !1),
        (this.Ah = wt[0] | 0),
        (this.Al = wt[1] | 0),
        (this.Bh = wt[2] | 0),
        (this.Bl = wt[3] | 0),
        (this.Ch = wt[4] | 0),
        (this.Cl = wt[5] | 0),
        (this.Dh = wt[6] | 0),
        (this.Dl = wt[7] | 0),
        (this.Eh = wt[8] | 0),
        (this.El = wt[9] | 0),
        (this.Fh = wt[10] | 0),
        (this.Fl = wt[11] | 0),
        (this.Gh = wt[12] | 0),
        (this.Gl = wt[13] | 0),
        (this.Hh = wt[14] | 0),
        (this.Hl = wt[15] | 0);
    }
    get() {
      const {
        Ah: e,
        Al: t,
        Bh: n,
        Bl: r,
        Ch: i,
        Cl: o,
        Dh: a,
        Dl: c,
        Eh: l,
        El: d,
        Fh: u,
        Fl: p,
        Gh: w,
        Gl: g,
        Hh: m,
        Hl: f,
      } = this;
      return [e, t, n, r, i, o, a, c, l, d, u, p, w, g, m, f];
    }
    set(e, t, n, r, i, o, a, c, l, d, u, p, w, g, m, f) {
      (this.Ah = e | 0),
        (this.Al = t | 0),
        (this.Bh = n | 0),
        (this.Bl = r | 0),
        (this.Ch = i | 0),
        (this.Cl = o | 0),
        (this.Dh = a | 0),
        (this.Dl = c | 0),
        (this.Eh = l | 0),
        (this.El = d | 0),
        (this.Fh = u | 0),
        (this.Fl = p | 0),
        (this.Gh = w | 0),
        (this.Gl = g | 0),
        (this.Hh = m | 0),
        (this.Hl = f | 0);
    }
    process(e, t) {
      for (let _ = 0; _ < 16; _++, t += 4)
        (ln[_] = e.getUint32(t)), (dn[_] = e.getUint32((t += 4)));
      for (let _ = 16; _ < 80; _++) {
        const N = ln[_ - 15] | 0,
          A = dn[_ - 15] | 0,
          L = fn(N, A, 1) ^ fn(N, A, 8) ^ Qd(N, A, 7),
          Q = gn(N, A, 1) ^ gn(N, A, 8) ^ eu(N, A, 7),
          K = ln[_ - 2] | 0,
          C = dn[_ - 2] | 0,
          T = fn(K, C, 19) ^ Pi(K, C, 61) ^ Qd(K, C, 6),
          v = gn(K, C, 19) ^ Oi(K, C, 61) ^ eu(K, C, 6),
          I = ZE(Q, v, dn[_ - 7], dn[_ - 16]),
          x = JE(I, L, T, ln[_ - 7], ln[_ - 16]);
        (ln[_] = x | 0), (dn[_] = I | 0);
      }
      let {
        Ah: n,
        Al: r,
        Bh: i,
        Bl: o,
        Ch: a,
        Cl: c,
        Dh: l,
        Dl: d,
        Eh: u,
        El: p,
        Fh: w,
        Fl: g,
        Gh: m,
        Gl: f,
        Hh: E,
        Hl: b,
      } = this;
      for (let _ = 0; _ < 80; _++) {
        const N = fn(u, p, 14) ^ fn(u, p, 18) ^ Pi(u, p, 41),
          A = gn(u, p, 14) ^ gn(u, p, 18) ^ Oi(u, p, 41),
          L = (u & w) ^ (~u & m),
          Q = (p & g) ^ (~p & f),
          K = XE(b, A, Q, _b[_], dn[_]),
          C = QE(K, E, N, L, bb[_], ln[_]),
          T = K | 0,
          v = fn(n, r, 28) ^ Pi(n, r, 34) ^ Pi(n, r, 39),
          I = gn(n, r, 28) ^ Oi(n, r, 34) ^ Oi(n, r, 39),
          x = (n & i) ^ (n & a) ^ (i & a),
          U = (r & o) ^ (r & c) ^ (o & c);
        (E = m | 0),
          (b = f | 0),
          (m = w | 0),
          (f = g | 0),
          (w = u | 0),
          (g = p | 0),
          ({ h: u, l: p } = fs(l | 0, d | 0, C | 0, T | 0)),
          (l = a | 0),
          (d = c | 0),
          (a = i | 0),
          (c = o | 0),
          (i = n | 0),
          (o = r | 0);
        const k = Yl(T, I, U);
        (n = Zl(k, C, v, x)), (r = k | 0);
      }
      ({ h: n, l: r } = fs(this.Ah | 0, this.Al | 0, n | 0, r | 0)),
        ({ h: i, l: o } = fs(this.Bh | 0, this.Bl | 0, i | 0, o | 0)),
        ({ h: a, l: c } = fs(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
        ({ h: l, l: d } = fs(this.Dh | 0, this.Dl | 0, l | 0, d | 0)),
        ({ h: u, l: p } = fs(this.Eh | 0, this.El | 0, u | 0, p | 0)),
        ({ h: w, l: g } = fs(this.Fh | 0, this.Fl | 0, w | 0, g | 0)),
        ({ h: m, l: f } = fs(this.Gh | 0, this.Gl | 0, m | 0, f | 0)),
        ({ h: E, l: b } = fs(this.Hh | 0, this.Hl | 0, E | 0, b | 0)),
        this.set(n, r, i, o, a, c, l, d, u, p, w, g, m, f, E, b);
    }
    roundClean() {
      as(ln, dn);
    }
    destroy() {
      as(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  },
  Cb = class extends td {
    constructor() {
      super(48),
        (this.Ah = mt[0] | 0),
        (this.Al = mt[1] | 0),
        (this.Bh = mt[2] | 0),
        (this.Bl = mt[3] | 0),
        (this.Ch = mt[4] | 0),
        (this.Cl = mt[5] | 0),
        (this.Dh = mt[6] | 0),
        (this.Dl = mt[7] | 0),
        (this.Eh = mt[8] | 0),
        (this.El = mt[9] | 0),
        (this.Fh = mt[10] | 0),
        (this.Fl = mt[11] | 0),
        (this.Gh = mt[12] | 0),
        (this.Gl = mt[13] | 0),
        (this.Hh = mt[14] | 0),
        (this.Hl = mt[15] | 0);
    }
  };
const yt = Uint32Array.from([
  573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857,
  2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490,
  721525244, 746961066, 246885852, 2177182882,
]);
let vb = class extends td {
  constructor() {
    super(32),
      (this.Ah = yt[0] | 0),
      (this.Al = yt[1] | 0),
      (this.Bh = yt[2] | 0),
      (this.Bl = yt[3] | 0),
      (this.Ch = yt[4] | 0),
      (this.Cl = yt[5] | 0),
      (this.Dh = yt[6] | 0),
      (this.Dl = yt[7] | 0),
      (this.Eh = yt[8] | 0),
      (this.El = yt[9] | 0),
      (this.Fh = yt[10] | 0),
      (this.Fl = yt[11] | 0),
      (this.Gh = yt[12] | 0),
      (this.Gl = yt[13] | 0),
      (this.Hh = yt[14] | 0),
      (this.Hl = yt[15] | 0);
  }
};
const Ma = To(() => new Eb()),
  Ab = To(() => new td()),
  Ib = To(() => new Cb()),
  Sb = To(() => new vb()),
  Nb = Uint8Array.from([
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15,
    13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6,
    7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5,
    7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4,
    13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8,
    11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11,
    3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14,
    3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10,
    4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13,
    10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15,
    8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0,
    11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
  ]),
  et = Uint32Array.from([
    4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242,
    1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924,
    4215389547, 528734635, 327033209, 1541459225,
  ]),
  z = new Uint32Array(32);
function un(s, e, t, n, r, i) {
  const o = r[i],
    a = r[i + 1];
  let c = z[2 * s],
    l = z[2 * s + 1],
    d = z[2 * e],
    u = z[2 * e + 1],
    p = z[2 * t],
    w = z[2 * t + 1],
    g = z[2 * n],
    m = z[2 * n + 1],
    f = Yl(c, d, o);
  (l = Zl(f, l, u, a)),
    (c = f | 0),
    ({ Dh: m, Dl: g } = { Dh: m ^ l, Dl: g ^ c }),
    ({ Dh: m, Dl: g } = { Dh: WE(m, g), Dl: zE(m) }),
    ({ h: w, l: p } = fs(w, p, m, g)),
    ({ Bh: u, Bl: d } = { Bh: u ^ w, Bl: d ^ p }),
    ({ Bh: u, Bl: d } = { Bh: fn(u, d, 24), Bl: gn(u, d, 24) }),
    (z[2 * s] = c),
    (z[2 * s + 1] = l),
    (z[2 * e] = d),
    (z[2 * e + 1] = u),
    (z[2 * t] = p),
    (z[2 * t + 1] = w),
    (z[2 * n] = g),
    (z[2 * n + 1] = m);
}
function hn(s, e, t, n, r, i) {
  const o = r[i],
    a = r[i + 1];
  let c = z[2 * s],
    l = z[2 * s + 1],
    d = z[2 * e],
    u = z[2 * e + 1],
    p = z[2 * t],
    w = z[2 * t + 1],
    g = z[2 * n],
    m = z[2 * n + 1],
    f = Yl(c, d, o);
  (l = Zl(f, l, u, a)),
    (c = f | 0),
    ({ Dh: m, Dl: g } = { Dh: m ^ l, Dl: g ^ c }),
    ({ Dh: m, Dl: g } = { Dh: fn(m, g, 16), Dl: gn(m, g, 16) }),
    ({ h: w, l: p } = fs(w, p, m, g)),
    ({ Bh: u, Bl: d } = { Bh: u ^ w, Bl: d ^ p }),
    ({ Bh: u, Bl: d } = { Bh: Pi(u, d, 63), Bl: Oi(u, d, 63) }),
    (z[2 * s] = c),
    (z[2 * s + 1] = l),
    (z[2 * e] = d),
    (z[2 * e + 1] = u),
    (z[2 * t] = p),
    (z[2 * t + 1] = w),
    (z[2 * n] = g),
    (z[2 * n + 1] = m);
}
function Tb(s, e = {}, t, n, r) {
  if ((tn(t), s < 0 || s > t)) throw new Error("outputLen bigger than keyLen");
  const { key: i, salt: o, personalization: a } = e;
  if (i !== void 0 && (i.length < 1 || i.length > t))
    throw new Error("key length must be undefined or 1.." + t);
  if (o !== void 0 && o.length !== n)
    throw new Error("salt must be undefined or " + n);
  if (a !== void 0 && a.length !== r)
    throw new Error("personalization must be undefined or " + r);
}
class Rb extends La {
  constructor(e, t) {
    super(),
      (this.finished = !1),
      (this.destroyed = !1),
      (this.length = 0),
      (this.pos = 0),
      tn(e),
      tn(t),
      (this.blockLen = e),
      (this.outputLen = t),
      (this.buffer = new Uint8Array(e)),
      (this.buffer32 = to(this.buffer));
  }
  update(e) {
    Rn(this), (e = Es(e)), os(e);
    const { blockLen: t, buffer: n, buffer32: r } = this,
      i = e.length,
      o = e.byteOffset,
      a = e.buffer;
    for (let c = 0; c < i; ) {
      this.pos === t && (mn(r), this.compress(r, 0, !1), mn(r), (this.pos = 0));
      const l = Math.min(t - this.pos, i - c),
        d = o + c;
      if (l === t && !(d % 4) && c + l < i) {
        const u = new Uint32Array(a, d, Math.floor((i - c) / 4));
        mn(u);
        for (let p = 0; c + t < i; p += r.length, c += t)
          (this.length += t), this.compress(u, p, !1);
        mn(u);
        continue;
      }
      n.set(e.subarray(c, c + l), this.pos),
        (this.pos += l),
        (this.length += l),
        (c += l);
    }
    return this;
  }
  digestInto(e) {
    Rn(this), Ql(e, this);
    const { pos: t, buffer32: n } = this;
    (this.finished = !0),
      as(this.buffer.subarray(t)),
      mn(n),
      this.compress(n, 0, !0),
      mn(n);
    const r = to(e);
    this.get().forEach((i, o) => (r[o] = Ks(i)));
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    const {
      buffer: t,
      length: n,
      finished: r,
      destroyed: i,
      outputLen: o,
      pos: a,
    } = this;
    return (
      e || (e = new this.constructor({ dkLen: o })),
      e.set(...this.get()),
      e.buffer.set(t),
      (e.destroyed = i),
      (e.finished = r),
      (e.length = n),
      (e.pos = a),
      (e.outputLen = o),
      e
    );
  }
  clone() {
    return this._cloneInto();
  }
}
class xb extends Rb {
  constructor(e = {}) {
    const t = e.dkLen === void 0 ? 64 : e.dkLen;
    super(128, t),
      (this.v0l = et[0] | 0),
      (this.v0h = et[1] | 0),
      (this.v1l = et[2] | 0),
      (this.v1h = et[3] | 0),
      (this.v2l = et[4] | 0),
      (this.v2h = et[5] | 0),
      (this.v3l = et[6] | 0),
      (this.v3h = et[7] | 0),
      (this.v4l = et[8] | 0),
      (this.v4h = et[9] | 0),
      (this.v5l = et[10] | 0),
      (this.v5h = et[11] | 0),
      (this.v6l = et[12] | 0),
      (this.v6h = et[13] | 0),
      (this.v7l = et[14] | 0),
      (this.v7h = et[15] | 0),
      Tb(t, e, 64, 16, 16);
    let { key: n, personalization: r, salt: i } = e,
      o = 0;
    if (
      (n !== void 0 && ((n = Es(n)), (o = n.length)),
      (this.v0l ^= this.outputLen | (o << 8) | 65536 | (1 << 24)),
      i !== void 0)
    ) {
      i = Es(i);
      const a = to(i);
      (this.v4l ^= Ks(a[0])),
        (this.v4h ^= Ks(a[1])),
        (this.v5l ^= Ks(a[2])),
        (this.v5h ^= Ks(a[3]));
    }
    if (r !== void 0) {
      r = Es(r);
      const a = to(r);
      (this.v6l ^= Ks(a[0])),
        (this.v6h ^= Ks(a[1])),
        (this.v7l ^= Ks(a[2])),
        (this.v7h ^= Ks(a[3]));
    }
    if (n !== void 0) {
      const a = new Uint8Array(this.blockLen);
      a.set(n), this.update(a);
    }
  }
  get() {
    let {
      v0l: e,
      v0h: t,
      v1l: n,
      v1h: r,
      v2l: i,
      v2h: o,
      v3l: a,
      v3h: c,
      v4l: l,
      v4h: d,
      v5l: u,
      v5h: p,
      v6l: w,
      v6h: g,
      v7l: m,
      v7h: f,
    } = this;
    return [e, t, n, r, i, o, a, c, l, d, u, p, w, g, m, f];
  }
  set(e, t, n, r, i, o, a, c, l, d, u, p, w, g, m, f) {
    (this.v0l = e | 0),
      (this.v0h = t | 0),
      (this.v1l = n | 0),
      (this.v1h = r | 0),
      (this.v2l = i | 0),
      (this.v2h = o | 0),
      (this.v3l = a | 0),
      (this.v3h = c | 0),
      (this.v4l = l | 0),
      (this.v4h = d | 0),
      (this.v5l = u | 0),
      (this.v5h = p | 0),
      (this.v6l = w | 0),
      (this.v6h = g | 0),
      (this.v7l = m | 0),
      (this.v7h = f | 0);
  }
  compress(e, t, n) {
    this.get().forEach((c, l) => (z[l] = c)), z.set(et, 16);
    let { h: r, l: i } = Hp(BigInt(this.length));
    (z[24] = et[8] ^ i),
      (z[25] = et[9] ^ r),
      n && ((z[28] = ~z[28]), (z[29] = ~z[29]));
    let o = 0;
    const a = Nb;
    for (let c = 0; c < 12; c++)
      un(0, 4, 8, 12, e, t + 2 * a[o++]),
        hn(0, 4, 8, 12, e, t + 2 * a[o++]),
        un(1, 5, 9, 13, e, t + 2 * a[o++]),
        hn(1, 5, 9, 13, e, t + 2 * a[o++]),
        un(2, 6, 10, 14, e, t + 2 * a[o++]),
        hn(2, 6, 10, 14, e, t + 2 * a[o++]),
        un(3, 7, 11, 15, e, t + 2 * a[o++]),
        hn(3, 7, 11, 15, e, t + 2 * a[o++]),
        un(0, 5, 10, 15, e, t + 2 * a[o++]),
        hn(0, 5, 10, 15, e, t + 2 * a[o++]),
        un(1, 6, 11, 12, e, t + 2 * a[o++]),
        hn(1, 6, 11, 12, e, t + 2 * a[o++]),
        un(2, 7, 8, 13, e, t + 2 * a[o++]),
        hn(2, 7, 8, 13, e, t + 2 * a[o++]),
        un(3, 4, 9, 14, e, t + 2 * a[o++]),
        hn(3, 4, 9, 14, e, t + 2 * a[o++]);
    (this.v0l ^= z[0] ^ z[16]),
      (this.v0h ^= z[1] ^ z[17]),
      (this.v1l ^= z[2] ^ z[18]),
      (this.v1h ^= z[3] ^ z[19]),
      (this.v2l ^= z[4] ^ z[20]),
      (this.v2h ^= z[5] ^ z[21]),
      (this.v3l ^= z[6] ^ z[22]),
      (this.v3h ^= z[7] ^ z[23]),
      (this.v4l ^= z[8] ^ z[24]),
      (this.v4h ^= z[9] ^ z[25]),
      (this.v5l ^= z[10] ^ z[26]),
      (this.v5h ^= z[11] ^ z[27]),
      (this.v6l ^= z[12] ^ z[28]),
      (this.v6h ^= z[13] ^ z[29]),
      (this.v7l ^= z[14] ^ z[30]),
      (this.v7h ^= z[15] ^ z[31]),
      as(z);
  }
  destroy() {
    (this.destroyed = !0),
      as(this.buffer32),
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const Pb = nb((s) => new xb(s)),
  Ob = "https://rpc.walletconnect.org/v1";
function tf(s) {
  const e = `Ethereum Signed Message:
${s.length}`,
    t = new TextEncoder().encode(e + s);
  return "0x" + Buffer.from(fb(t)).toString("hex");
}
async function kb(s, e, t, n, r, i) {
  switch (t.t) {
    case "eip191":
      return await Ub(s, e, t.s);
    case "eip1271":
      return await $b(s, e, t.s, n, r, i);
    default:
      throw new Error(
        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`
      );
  }
}
async function Ub(s, e, t) {
  return (
    (await Ay({ hash: tf(e), signature: t })).toLowerCase() === s.toLowerCase()
  );
}
async function $b(s, e, t, n, r, i) {
  const o = Fr(n);
  if (!o.namespace || !o.reference)
    throw new Error(
      `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${n}`
    );
  try {
    const a = "0x1626ba7e",
      c = "0000000000000000000000000000000000000000000000000000000000000040",
      l = t.substring(2),
      d = (l.length / 2).toString(16).padStart(64, "0"),
      u = (e.startsWith("0x") ? e : tf(e)).substring(2),
      p = a + u + c + d + l,
      w = await fetch(`${i || Ob}/?chainId=${n}&projectId=${r}`, {
        headers: { "Content-Type": "application/json" },
        method: "POST",
        body: JSON.stringify({
          id: Db(),
          jsonrpc: "2.0",
          method: "eth_call",
          params: [{ to: s, data: p }, "latest"],
        }),
      }),
      { result: g } = await w.json();
    return g ? g.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
  } catch (a) {
    return console.error("isValidEip1271Signature: ", a), !1;
  }
}
function Db() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function Lb(s) {
  const e = atob(s),
    t = new Uint8Array(e.length);
  for (let o = 0; o < e.length; o++) t[o] = e.charCodeAt(o);
  const n = t[0];
  if (n === 0) throw new Error("No signatures found");
  const r = 1 + n * 64;
  if (t.length < r)
    throw new Error("Transaction data too short for claimed signature count");
  if (t.length < 100) throw new Error("Transaction too short");
  const i = Buffer.from(s, "base64").slice(1, 65);
  return ei.encode(i);
}
function Mb(s) {
  const e = new Uint8Array(Buffer.from(s, "base64")),
    t = Array.from("TransactionData::").map((i) => i.charCodeAt(0)),
    n = new Uint8Array(t.length + e.length);
  n.set(t), n.set(e, t.length);
  const r = Pb(n, { dkLen: 32 });
  return ei.encode(r);
}
function ru(s) {
  const e = new Uint8Array(Ma(Bb(s)));
  return ei.encode(e);
}
function Bb(s) {
  if (s instanceof Uint8Array) return s;
  if (Array.isArray(s)) return new Uint8Array(s);
  if (typeof s == "object" && s != null && s.data)
    return new Uint8Array(Object.values(s.data));
  if (typeof s == "object" && s) return new Uint8Array(Object.values(s));
  throw new Error(
    "getNearUint8ArrayFromBytes: Unexpected result type from bytes array"
  );
}
function iu(s) {
  const e = Buffer.from(s, "base64"),
    t = rE(e).txn;
  if (!t) throw new Error("Invalid signed transaction: missing 'txn' field");
  const n = Zy(t),
    r = Buffer.from("TX"),
    i = Buffer.concat([r, Buffer.from(n)]),
    o = Sb(i);
  return hE.encode(o).replace(/=+$/, "");
}
function hc(s) {
  const e = [];
  let t = BigInt(s);
  for (; t >= BigInt(128); )
    e.push(Number((t & BigInt(127)) | BigInt(128))), (t >>= BigInt(7));
  return e.push(Number(t)), Buffer.from(e);
}
function Fb(s) {
  const e = Buffer.from(s.signed.bodyBytes, "base64"),
    t = Buffer.from(s.signed.authInfoBytes, "base64"),
    n = Buffer.from(s.signature.signature, "base64"),
    r = [];
  r.push(Buffer.from([10])),
    r.push(hc(e.length)),
    r.push(e),
    r.push(Buffer.from([18])),
    r.push(hc(t.length)),
    r.push(t),
    r.push(Buffer.from([26])),
    r.push(hc(n.length)),
    r.push(n);
  const i = Buffer.concat(r),
    o = Ma(i);
  return Buffer.from(o).toString("hex").toUpperCase();
}
var jb = Object.defineProperty,
  qb = Object.defineProperties,
  Hb = Object.getOwnPropertyDescriptors,
  ou = Object.getOwnPropertySymbols,
  Wb = Object.prototype.hasOwnProperty,
  zb = Object.prototype.propertyIsEnumerable,
  au = (s, e, t) =>
    e in s
      ? jb(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Vb = (s, e) => {
    for (var t in e || (e = {})) Wb.call(e, t) && au(s, t, e[t]);
    if (ou) for (var t of ou(e)) zb.call(e, t) && au(s, t, e[t]);
    return s;
  },
  Kb = (s, e) => qb(s, Hb(e));
const Gb = "did:pkh:",
  sd = (s) => (s == null ? void 0 : s.split(":")),
  Yb = (s) => {
    const e = s && sd(s);
    if (e) return s.includes(Gb) ? e[3] : e[1];
  },
  tl = (s) => {
    const e = s && sd(s);
    if (e) return e[2] + ":" + e[3];
  },
  wa = (s) => {
    const e = s && sd(s);
    if (e) return e.pop();
  };
async function cu(s) {
  const { cacao: e, projectId: t } = s,
    { s: n, p: r } = e,
    i = sf(r, r.iss),
    o = wa(r.iss);
  return await kb(o, i, n, tl(r.iss), t);
}
const sf = (s, e) => {
  const t = `${s.domain} wants you to sign in with your Ethereum account:`,
    n = wa(e);
  if (!s.aud && !s.uri)
    throw new Error(
      "Either `aud` or `uri` is required to construct the message"
    );
  let r = s.statement || void 0;
  const i = `URI: ${s.aud || s.uri}`,
    o = `Version: ${s.version}`,
    a = `Chain ID: ${Yb(e)}`,
    c = `Nonce: ${s.nonce}`,
    l = `Issued At: ${s.iat}`,
    d = s.exp ? `Expiration Time: ${s.exp}` : void 0,
    u = s.nbf ? `Not Before: ${s.nbf}` : void 0,
    p = s.requestId ? `Request ID: ${s.requestId}` : void 0,
    w = s.resources
      ? `Resources:${s.resources
          .map(
            (m) => `
- ${m}`
          )
          .join("")}`
      : void 0,
    g = Qo(s.resources);
  if (g) {
    const m = no(g);
    r = r0(r, m);
  }
  return [t, n, "", r, "", i, o, a, c, l, d, u, p, w].filter((m) => m != null)
    .join(`
`);
};
function Zb(s) {
  return Buffer.from(JSON.stringify(s)).toString("base64");
}
function Jb(s) {
  return JSON.parse(Buffer.from(s, "base64").toString("utf-8"));
}
function tr(s) {
  if (!s) throw new Error("No recap provided, value is undefined");
  if (!s.att) throw new Error("No `att` property found");
  const e = Object.keys(s.att);
  if (!(e != null && e.length))
    throw new Error("No resources found in `att` property");
  e.forEach((t) => {
    const n = s.att[t];
    if (Array.isArray(n)) throw new Error(`Resource must be an object: ${t}`);
    if (typeof n != "object")
      throw new Error(`Resource must be an object: ${t}`);
    if (!Object.keys(n).length)
      throw new Error(`Resource object is empty: ${t}`);
    Object.keys(n).forEach((r) => {
      const i = n[r];
      if (!Array.isArray(i))
        throw new Error(
          `Ability limits ${r} must be an array of objects, found: ${i}`
        );
      if (!i.length)
        throw new Error(
          `Value of ${r} is empty array, must be an array with objects`
        );
      i.forEach((o) => {
        if (typeof o != "object")
          throw new Error(
            `Ability limits (${r}) must be an array of objects, found: ${o}`
          );
      });
    });
  });
}
function Xb(s, e, t, n = {}) {
  return (
    t == null || t.sort((r, i) => r.localeCompare(i)),
    { att: { [s]: Qb(e, t, n) } }
  );
}
function Qb(s, e, t = {}) {
  e = e == null ? void 0 : e.sort((r, i) => r.localeCompare(i));
  const n = e.map((r) => ({ [`${s}/${r}`]: [t] }));
  return Object.assign({}, ...n);
}
function nf(s) {
  return tr(s), `urn:recap:${Zb(s).replace(/=/g, "")}`;
}
function no(s) {
  const e = Jb(s.replace("urn:recap:", ""));
  return tr(e), e;
}
function e0(s, e, t) {
  const n = Xb(s, e, t);
  return nf(n);
}
function t0(s) {
  return s && s.includes("urn:recap:");
}
function s0(s, e) {
  const t = no(s),
    n = no(e),
    r = n0(t, n);
  return nf(r);
}
function n0(s, e) {
  tr(s), tr(e);
  const t = Object.keys(s.att)
      .concat(Object.keys(e.att))
      .sort((r, i) => r.localeCompare(i)),
    n = { att: {} };
  return (
    t.forEach((r) => {
      var i, o;
      Object.keys(((i = s.att) == null ? void 0 : i[r]) || {})
        .concat(Object.keys(((o = e.att) == null ? void 0 : o[r]) || {}))
        .sort((a, c) => a.localeCompare(c))
        .forEach((a) => {
          var c, l;
          n.att[r] = Kb(Vb({}, n.att[r]), {
            [a]:
              ((c = s.att[r]) == null ? void 0 : c[a]) ||
              ((l = e.att[r]) == null ? void 0 : l[a]),
          });
        });
    }),
    n
  );
}
function r0(s = "", e) {
  tr(e);
  const t =
    "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (s.includes(t)) return s;
  const n = [];
  let r = 0;
  Object.keys(e.att).forEach((a) => {
    const c = Object.keys(e.att[a]).map((u) => ({
      ability: u.split("/")[0],
      action: u.split("/")[1],
    }));
    c.sort((u, p) => u.action.localeCompare(p.action));
    const l = {};
    c.forEach((u) => {
      l[u.ability] || (l[u.ability] = []), l[u.ability].push(u.action);
    });
    const d = Object.keys(l).map(
      (u) => (r++, `(${r}) '${u}': '${l[u].join("', '")}' for '${a}'.`)
    );
    n.push(d.join(", ").replace(".,", "."));
  });
  const i = n.join(" "),
    o = `${t}${i}`;
  return `${s ? s + " " : ""}${o}`;
}
function lu(s) {
  var e;
  const t = no(s);
  tr(t);
  const n = (e = t.att) == null ? void 0 : e.eip155;
  return n ? Object.keys(n).map((r) => r.split("/")[1]) : [];
}
function du(s) {
  const e = no(s);
  tr(e);
  const t = [];
  return (
    Object.values(e.att).forEach((n) => {
      Object.values(n).forEach((r) => {
        var i;
        (i = r == null ? void 0 : r[0]) != null &&
          i.chains &&
          t.push(r[0].chains);
      });
    }),
    [...new Set(t.flat())]
  );
}
function Qo(s) {
  if (!s) return;
  const e = s == null ? void 0 : s[s.length - 1];
  return t0(e) ? e : void 0;
}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */ function rf(
  s
) {
  return (
    s instanceof Uint8Array ||
    (ArrayBuffer.isView(s) && s.constructor.name === "Uint8Array")
  );
}
function sl(s) {
  if (typeof s != "boolean") throw new Error(`boolean expected, not ${s}`);
}
function pc(s) {
  if (!Number.isSafeInteger(s) || s < 0)
    throw new Error("positive integer expected, got " + s);
}
function Lt(s, ...e) {
  if (!rf(s)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(s.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + s.length
    );
}
function uu(s, e = !0) {
  if (s.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && s.finished) throw new Error("Hash#digest() has already been called");
}
function i0(s, e) {
  Lt(s);
  const t = e.outputLen;
  if (s.length < t)
    throw new Error(
      "digestInto() expects output buffer of length at least " + t
    );
}
function Cn(s) {
  return new Uint32Array(s.buffer, s.byteOffset, Math.floor(s.byteLength / 4));
}
function Vr(...s) {
  for (let e = 0; e < s.length; e++) s[e].fill(0);
}
function o0(s) {
  return new DataView(s.buffer, s.byteOffset, s.byteLength);
}
const a0 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function c0(s) {
  if (typeof s != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(s));
}
function nl(s) {
  if (typeof s == "string") s = c0(s);
  else if (rf(s)) s = rl(s);
  else throw new Error("Uint8Array expected, got " + typeof s);
  return s;
}
function l0(s, e) {
  if (e == null || typeof e != "object")
    throw new Error("options must be defined");
  return Object.assign(s, e);
}
function d0(s, e) {
  if (s.length !== e.length) return !1;
  let t = 0;
  for (let n = 0; n < s.length; n++) t |= s[n] ^ e[n];
  return t === 0;
}
const u0 = (s, e) => {
  function t(n, ...r) {
    if ((Lt(n), !a0))
      throw new Error("Non little-endian hardware is not yet supported");
    if (s.nonceLength !== void 0) {
      const l = r[0];
      if (!l) throw new Error("nonce / iv required");
      s.varSizeNonce ? Lt(l) : Lt(l, s.nonceLength);
    }
    const i = s.tagLength;
    i && r[1] !== void 0 && Lt(r[1]);
    const o = e(n, ...r),
      a = (l, d) => {
        if (d !== void 0) {
          if (l !== 2) throw new Error("cipher output not supported");
          Lt(d);
        }
      };
    let c = !1;
    return {
      encrypt(l, d) {
        if (c) throw new Error("cannot encrypt() twice with same key + nonce");
        return (c = !0), Lt(l), a(o.encrypt.length, d), o.encrypt(l, d);
      },
      decrypt(l, d) {
        if ((Lt(l), i && l.length < i))
          throw new Error(
            "invalid ciphertext length: smaller than tagLength=" + i
          );
        return a(o.decrypt.length, d), o.decrypt(l, d);
      },
    };
  }
  return Object.assign(t, s), t;
};
function hu(s, e, t = !0) {
  if (e === void 0) return new Uint8Array(s);
  if (e.length !== s)
    throw new Error(
      "invalid output length, expected " + s + ", got: " + e.length
    );
  if (t && !p0(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function pu(s, e, t, n) {
  if (typeof s.setBigUint64 == "function") return s.setBigUint64(e, t, n);
  const r = BigInt(32),
    i = BigInt(4294967295),
    o = Number((t >> r) & i),
    a = Number(t & i);
  s.setUint32(e + 4, o, n), s.setUint32(e + 0, a, n);
}
function h0(s, e, t) {
  sl(t);
  const n = new Uint8Array(16),
    r = o0(n);
  return pu(r, 0, BigInt(e), t), pu(r, 8, BigInt(s), t), n;
}
function p0(s) {
  return s.byteOffset % 4 === 0;
}
function rl(s) {
  return Uint8Array.from(s);
}
const of = (s) => Uint8Array.from(s.split("").map((e) => e.charCodeAt(0))),
  f0 = of("expand 16-byte k"),
  g0 = of("expand 32-byte k"),
  m0 = Cn(f0),
  w0 = Cn(g0);
function Ie(s, e) {
  return (s << e) | (s >>> (32 - e));
}
function il(s) {
  return s.byteOffset % 4 === 0;
}
const jo = 64,
  y0 = 16,
  af = 2 ** 32 - 1,
  fu = new Uint32Array();
function E0(s, e, t, n, r, i, o, a) {
  const c = r.length,
    l = new Uint8Array(jo),
    d = Cn(l),
    u = il(r) && il(i),
    p = u ? Cn(r) : fu,
    w = u ? Cn(i) : fu;
  for (let g = 0; g < c; o++) {
    if ((s(e, t, n, d, o, a), o >= af))
      throw new Error("arx: counter overflow");
    const m = Math.min(jo, c - g);
    if (u && m === jo) {
      const f = g / 4;
      if (g % 4 !== 0) throw new Error("arx: invalid block position");
      for (let E = 0, b; E < y0; E++) (b = f + E), (w[b] = p[b] ^ d[E]);
      g += jo;
      continue;
    }
    for (let f = 0, E; f < m; f++) (E = g + f), (i[E] = r[E] ^ l[f]);
    g += m;
  }
}
function b0(s, e) {
  const {
    allowShortKeys: t,
    extendNonceFn: n,
    counterLength: r,
    counterRight: i,
    rounds: o,
  } = l0(
    { allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 },
    e
  );
  if (typeof s != "function") throw new Error("core must be a function");
  return (
    pc(r),
    pc(o),
    sl(i),
    sl(t),
    (a, c, l, d, u = 0) => {
      Lt(a), Lt(c), Lt(l);
      const p = l.length;
      if (
        (d === void 0 && (d = new Uint8Array(p)),
        Lt(d),
        pc(u),
        u < 0 || u >= af)
      )
        throw new Error("arx: counter overflow");
      if (d.length < p)
        throw new Error(
          `arx: output (${d.length}) is shorter than data (${p})`
        );
      const w = [];
      let g = a.length,
        m,
        f;
      if (g === 32) w.push((m = rl(a))), (f = w0);
      else if (g === 16 && t)
        (m = new Uint8Array(32)), m.set(a), m.set(a, 16), (f = m0), w.push(m);
      else throw new Error(`arx: invalid 32-byte key, got length=${g}`);
      il(c) || w.push((c = rl(c)));
      const E = Cn(m);
      if (n) {
        if (c.length !== 24)
          throw new Error("arx: extended nonce must be 24 bytes");
        n(f, E, Cn(c.subarray(0, 16)), E), (c = c.subarray(16));
      }
      const b = 16 - r;
      if (b !== c.length)
        throw new Error(`arx: nonce must be ${b} or 16 bytes`);
      if (b !== 12) {
        const N = new Uint8Array(12);
        N.set(c, i ? 0 : 12 - c.length), (c = N), w.push(c);
      }
      const _ = Cn(c);
      return E0(s, f, E, _, l, d, u, o), Vr(...w), d;
    }
  );
}
const lt = (s, e) => (s[e++] & 255) | ((s[e++] & 255) << 8);
class _0 {
  constructor(e) {
    (this.blockLen = 16),
      (this.outputLen = 16),
      (this.buffer = new Uint8Array(16)),
      (this.r = new Uint16Array(10)),
      (this.h = new Uint16Array(10)),
      (this.pad = new Uint16Array(8)),
      (this.pos = 0),
      (this.finished = !1),
      (e = nl(e)),
      Lt(e, 32);
    const t = lt(e, 0),
      n = lt(e, 2),
      r = lt(e, 4),
      i = lt(e, 6),
      o = lt(e, 8),
      a = lt(e, 10),
      c = lt(e, 12),
      l = lt(e, 14);
    (this.r[0] = t & 8191),
      (this.r[1] = ((t >>> 13) | (n << 3)) & 8191),
      (this.r[2] = ((n >>> 10) | (r << 6)) & 7939),
      (this.r[3] = ((r >>> 7) | (i << 9)) & 8191),
      (this.r[4] = ((i >>> 4) | (o << 12)) & 255),
      (this.r[5] = (o >>> 1) & 8190),
      (this.r[6] = ((o >>> 14) | (a << 2)) & 8191),
      (this.r[7] = ((a >>> 11) | (c << 5)) & 8065),
      (this.r[8] = ((c >>> 8) | (l << 8)) & 8191),
      (this.r[9] = (l >>> 5) & 127);
    for (let d = 0; d < 8; d++) this.pad[d] = lt(e, 16 + 2 * d);
  }
  process(e, t, n = !1) {
    const r = n ? 0 : 2048,
      { h: i, r: o } = this,
      a = o[0],
      c = o[1],
      l = o[2],
      d = o[3],
      u = o[4],
      p = o[5],
      w = o[6],
      g = o[7],
      m = o[8],
      f = o[9],
      E = lt(e, t + 0),
      b = lt(e, t + 2),
      _ = lt(e, t + 4),
      N = lt(e, t + 6),
      A = lt(e, t + 8),
      L = lt(e, t + 10),
      Q = lt(e, t + 12),
      K = lt(e, t + 14);
    let C = i[0] + (E & 8191),
      T = i[1] + (((E >>> 13) | (b << 3)) & 8191),
      v = i[2] + (((b >>> 10) | (_ << 6)) & 8191),
      I = i[3] + (((_ >>> 7) | (N << 9)) & 8191),
      x = i[4] + (((N >>> 4) | (A << 12)) & 8191),
      U = i[5] + ((A >>> 1) & 8191),
      k = i[6] + (((A >>> 14) | (L << 2)) & 8191),
      $ = i[7] + (((L >>> 11) | (Q << 5)) & 8191),
      B = i[8] + (((Q >>> 8) | (K << 8)) & 8191),
      V = i[9] + ((K >>> 5) | r),
      O = 0,
      ee = O + C * a + T * (5 * f) + v * (5 * m) + I * (5 * g) + x * (5 * w);
    (O = ee >>> 13),
      (ee &= 8191),
      (ee +=
        U * (5 * p) + k * (5 * u) + $ * (5 * d) + B * (5 * l) + V * (5 * c)),
      (O += ee >>> 13),
      (ee &= 8191);
    let J = O + C * c + T * a + v * (5 * f) + I * (5 * m) + x * (5 * g);
    (O = J >>> 13),
      (J &= 8191),
      (J +=
        U * (5 * w) + k * (5 * p) + $ * (5 * u) + B * (5 * d) + V * (5 * l)),
      (O += J >>> 13),
      (J &= 8191);
    let ce = O + C * l + T * c + v * a + I * (5 * f) + x * (5 * m);
    (O = ce >>> 13),
      (ce &= 8191),
      (ce +=
        U * (5 * g) + k * (5 * w) + $ * (5 * p) + B * (5 * u) + V * (5 * d)),
      (O += ce >>> 13),
      (ce &= 8191);
    let ye = O + C * d + T * l + v * c + I * a + x * (5 * f);
    (O = ye >>> 13),
      (ye &= 8191),
      (ye +=
        U * (5 * m) + k * (5 * g) + $ * (5 * w) + B * (5 * p) + V * (5 * u)),
      (O += ye >>> 13),
      (ye &= 8191);
    let we = O + C * u + T * d + v * l + I * c + x * a;
    (O = we >>> 13),
      (we &= 8191),
      (we +=
        U * (5 * f) + k * (5 * m) + $ * (5 * g) + B * (5 * w) + V * (5 * p)),
      (O += we >>> 13),
      (we &= 8191);
    let Ee = O + C * p + T * u + v * d + I * l + x * c;
    (O = Ee >>> 13),
      (Ee &= 8191),
      (Ee += U * a + k * (5 * f) + $ * (5 * m) + B * (5 * g) + V * (5 * w)),
      (O += Ee >>> 13),
      (Ee &= 8191);
    let Me = O + C * w + T * p + v * u + I * d + x * l;
    (O = Me >>> 13),
      (Me &= 8191),
      (Me += U * c + k * a + $ * (5 * f) + B * (5 * m) + V * (5 * g)),
      (O += Me >>> 13),
      (Me &= 8191);
    let Ze = O + C * g + T * w + v * p + I * u + x * d;
    (O = Ze >>> 13),
      (Ze &= 8191),
      (Ze += U * l + k * c + $ * a + B * (5 * f) + V * (5 * m)),
      (O += Ze >>> 13),
      (Ze &= 8191);
    let Ye = O + C * m + T * g + v * w + I * p + x * u;
    (O = Ye >>> 13),
      (Ye &= 8191),
      (Ye += U * d + k * l + $ * c + B * a + V * (5 * f)),
      (O += Ye >>> 13),
      (Ye &= 8191);
    let Ve = O + C * f + T * m + v * g + I * w + x * p;
    (O = Ve >>> 13),
      (Ve &= 8191),
      (Ve += U * u + k * d + $ * l + B * c + V * a),
      (O += Ve >>> 13),
      (Ve &= 8191),
      (O = ((O << 2) + O) | 0),
      (O = (O + ee) | 0),
      (ee = O & 8191),
      (O = O >>> 13),
      (J += O),
      (i[0] = ee),
      (i[1] = J),
      (i[2] = ce),
      (i[3] = ye),
      (i[4] = we),
      (i[5] = Ee),
      (i[6] = Me),
      (i[7] = Ze),
      (i[8] = Ye),
      (i[9] = Ve);
  }
  finalize() {
    const { h: e, pad: t } = this,
      n = new Uint16Array(10);
    let r = e[1] >>> 13;
    e[1] &= 8191;
    for (let a = 2; a < 10; a++) (e[a] += r), (r = e[a] >>> 13), (e[a] &= 8191);
    (e[0] += r * 5),
      (r = e[0] >>> 13),
      (e[0] &= 8191),
      (e[1] += r),
      (r = e[1] >>> 13),
      (e[1] &= 8191),
      (e[2] += r),
      (n[0] = e[0] + 5),
      (r = n[0] >>> 13),
      (n[0] &= 8191);
    for (let a = 1; a < 10; a++)
      (n[a] = e[a] + r), (r = n[a] >>> 13), (n[a] &= 8191);
    n[9] -= 8192;
    let i = (r ^ 1) - 1;
    for (let a = 0; a < 10; a++) n[a] &= i;
    i = ~i;
    for (let a = 0; a < 10; a++) e[a] = (e[a] & i) | n[a];
    (e[0] = (e[0] | (e[1] << 13)) & 65535),
      (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
      (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
      (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
      (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
      (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
      (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
      (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
    let o = e[0] + t[0];
    e[0] = o & 65535;
    for (let a = 1; a < 8; a++)
      (o = (((e[a] + t[a]) | 0) + (o >>> 16)) | 0), (e[a] = o & 65535);
    Vr(n);
  }
  update(e) {
    uu(this), (e = nl(e)), Lt(e);
    const { buffer: t, blockLen: n } = this,
      r = e.length;
    for (let i = 0; i < r; ) {
      const o = Math.min(n - this.pos, r - i);
      if (o === n) {
        for (; n <= r - i; i += n) this.process(e, i);
        continue;
      }
      t.set(e.subarray(i, i + o), this.pos),
        (this.pos += o),
        (i += o),
        this.pos === n && (this.process(t, 0, !1), (this.pos = 0));
    }
    return this;
  }
  destroy() {
    Vr(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    uu(this), i0(e, this), (this.finished = !0);
    const { buffer: t, h: n } = this;
    let { pos: r } = this;
    if (r) {
      for (t[r++] = 1; r < 16; r++) t[r] = 0;
      this.process(t, 0, !0);
    }
    this.finalize();
    let i = 0;
    for (let o = 0; o < 8; o++) (e[i++] = n[o] >>> 0), (e[i++] = n[o] >>> 8);
    return e;
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
}
function C0(s) {
  const e = (n, r) => s(r).update(nl(n)).digest(),
    t = s(new Uint8Array(32));
  return (
    (e.outputLen = t.outputLen),
    (e.blockLen = t.blockLen),
    (e.create = (n) => s(n)),
    e
  );
}
const v0 = C0((s) => new _0(s));
function A0(s, e, t, n, r, i = 20) {
  let o = s[0],
    a = s[1],
    c = s[2],
    l = s[3],
    d = e[0],
    u = e[1],
    p = e[2],
    w = e[3],
    g = e[4],
    m = e[5],
    f = e[6],
    E = e[7],
    b = r,
    _ = t[0],
    N = t[1],
    A = t[2],
    L = o,
    Q = a,
    K = c,
    C = l,
    T = d,
    v = u,
    I = p,
    x = w,
    U = g,
    k = m,
    $ = f,
    B = E,
    V = b,
    O = _,
    ee = N,
    J = A;
  for (let ye = 0; ye < i; ye += 2)
    (L = (L + T) | 0),
      (V = Ie(V ^ L, 16)),
      (U = (U + V) | 0),
      (T = Ie(T ^ U, 12)),
      (L = (L + T) | 0),
      (V = Ie(V ^ L, 8)),
      (U = (U + V) | 0),
      (T = Ie(T ^ U, 7)),
      (Q = (Q + v) | 0),
      (O = Ie(O ^ Q, 16)),
      (k = (k + O) | 0),
      (v = Ie(v ^ k, 12)),
      (Q = (Q + v) | 0),
      (O = Ie(O ^ Q, 8)),
      (k = (k + O) | 0),
      (v = Ie(v ^ k, 7)),
      (K = (K + I) | 0),
      (ee = Ie(ee ^ K, 16)),
      ($ = ($ + ee) | 0),
      (I = Ie(I ^ $, 12)),
      (K = (K + I) | 0),
      (ee = Ie(ee ^ K, 8)),
      ($ = ($ + ee) | 0),
      (I = Ie(I ^ $, 7)),
      (C = (C + x) | 0),
      (J = Ie(J ^ C, 16)),
      (B = (B + J) | 0),
      (x = Ie(x ^ B, 12)),
      (C = (C + x) | 0),
      (J = Ie(J ^ C, 8)),
      (B = (B + J) | 0),
      (x = Ie(x ^ B, 7)),
      (L = (L + v) | 0),
      (J = Ie(J ^ L, 16)),
      ($ = ($ + J) | 0),
      (v = Ie(v ^ $, 12)),
      (L = (L + v) | 0),
      (J = Ie(J ^ L, 8)),
      ($ = ($ + J) | 0),
      (v = Ie(v ^ $, 7)),
      (Q = (Q + I) | 0),
      (V = Ie(V ^ Q, 16)),
      (B = (B + V) | 0),
      (I = Ie(I ^ B, 12)),
      (Q = (Q + I) | 0),
      (V = Ie(V ^ Q, 8)),
      (B = (B + V) | 0),
      (I = Ie(I ^ B, 7)),
      (K = (K + x) | 0),
      (O = Ie(O ^ K, 16)),
      (U = (U + O) | 0),
      (x = Ie(x ^ U, 12)),
      (K = (K + x) | 0),
      (O = Ie(O ^ K, 8)),
      (U = (U + O) | 0),
      (x = Ie(x ^ U, 7)),
      (C = (C + T) | 0),
      (ee = Ie(ee ^ C, 16)),
      (k = (k + ee) | 0),
      (T = Ie(T ^ k, 12)),
      (C = (C + T) | 0),
      (ee = Ie(ee ^ C, 8)),
      (k = (k + ee) | 0),
      (T = Ie(T ^ k, 7));
  let ce = 0;
  (n[ce++] = (o + L) | 0),
    (n[ce++] = (a + Q) | 0),
    (n[ce++] = (c + K) | 0),
    (n[ce++] = (l + C) | 0),
    (n[ce++] = (d + T) | 0),
    (n[ce++] = (u + v) | 0),
    (n[ce++] = (p + I) | 0),
    (n[ce++] = (w + x) | 0),
    (n[ce++] = (g + U) | 0),
    (n[ce++] = (m + k) | 0),
    (n[ce++] = (f + $) | 0),
    (n[ce++] = (E + B) | 0),
    (n[ce++] = (b + V) | 0),
    (n[ce++] = (_ + O) | 0),
    (n[ce++] = (N + ee) | 0),
    (n[ce++] = (A + J) | 0);
}
const I0 = b0(A0, { counterRight: !1, counterLength: 4, allowShortKeys: !1 }),
  S0 = new Uint8Array(16),
  gu = (s, e) => {
    s.update(e);
    const t = e.length % 16;
    t && s.update(S0.subarray(t));
  },
  N0 = new Uint8Array(32);
function mu(s, e, t, n, r) {
  const i = s(e, t, N0),
    o = v0.create(i);
  r && gu(o, r), gu(o, n);
  const a = h0(n.length, r ? r.length : 0, !0);
  o.update(a);
  const c = o.digest();
  return Vr(i, a), c;
}
const T0 = (s) => (e, t, n) => ({
    encrypt(r, i) {
      const o = r.length;
      (i = hu(o + 16, i, !1)), i.set(r);
      const a = i.subarray(0, -16);
      s(e, t, a, a, 1);
      const c = mu(s, e, t, a, n);
      return i.set(c, o), Vr(c), i;
    },
    decrypt(r, i) {
      i = hu(r.length - 16, i, !1);
      const o = r.subarray(0, -16),
        a = r.subarray(-16),
        c = mu(s, e, t, o, n);
      if (!d0(a, c)) throw new Error("invalid tag");
      return i.set(r.subarray(0, -16)), s(e, t, i, i, 1), Vr(c), i;
    },
  }),
  cf = u0({ blockSize: 64, nonceLength: 12, tagLength: 16 }, T0(I0));
let lf = class extends La {
  constructor(e, t) {
    super(), (this.finished = !1), (this.destroyed = !1), Xl(e);
    const n = Es(t);
    if (((this.iHash = e.create()), typeof this.iHash.update != "function"))
      throw new Error("Expected instance of class which extends utils.Hash");
    (this.blockLen = this.iHash.blockLen),
      (this.outputLen = this.iHash.outputLen);
    const r = this.blockLen,
      i = new Uint8Array(r);
    i.set(n.length > r ? e.create().update(n).digest() : n);
    for (let o = 0; o < i.length; o++) i[o] ^= 54;
    this.iHash.update(i), (this.oHash = e.create());
    for (let o = 0; o < i.length; o++) i[o] ^= 106;
    this.oHash.update(i), as(i);
  }
  update(e) {
    return Rn(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Rn(this),
      os(e, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(e),
      this.oHash.update(e),
      this.oHash.digestInto(e),
      this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash: t,
      iHash: n,
      finished: r,
      destroyed: i,
      blockLen: o,
      outputLen: a,
    } = this;
    return (
      (e = e),
      (e.finished = r),
      (e.destroyed = i),
      (e.blockLen = o),
      (e.outputLen = a),
      (e.oHash = t._cloneInto(e.oHash)),
      (e.iHash = n._cloneInto(e.iHash)),
      e
    );
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
};
const Ba = (s, e, t) => new lf(s, e).update(t).digest();
Ba.create = (s, e) => new lf(s, e);
function R0(s, e, t) {
  return (
    Xl(s),
    t === void 0 && (t = new Uint8Array(s.outputLen)),
    Ba(s, Es(t), Es(e))
  );
}
const fc = Uint8Array.from([0]),
  wu = Uint8Array.of();
function x0(s, e, t, n = 32) {
  Xl(s), tn(n);
  const r = s.outputLen;
  if (n > 255 * r) throw new Error("Length should be <= 255*HashLen");
  const i = Math.ceil(n / r);
  t === void 0 && (t = wu);
  const o = new Uint8Array(i * r),
    a = Ba.create(s, e),
    c = a._cloneInto(),
    l = new Uint8Array(a.outputLen);
  for (let d = 0; d < i; d++)
    (fc[0] = d + 1),
      c
        .update(d === 0 ? wu : l)
        .update(t)
        .update(fc)
        .digestInto(l),
      o.set(l, r * d),
      a._cloneInto(c);
  return a.destroy(), c.destroy(), as(l, fc), o.slice(0, n);
}
const P0 = (s, e, t, n, r) => x0(s, R0(s, e, t), n, r),
  Fa = Ma,
  nd = BigInt(0),
  ol = BigInt(1);
function ya(s, e) {
  if (typeof e != "boolean") throw new Error(s + " boolean expected, got " + e);
}
function qo(s) {
  const e = s.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function df(s) {
  if (typeof s != "string")
    throw new Error("hex string expected, got " + typeof s);
  return s === "" ? nd : BigInt("0x" + s);
}
function ja(s) {
  return df(so(s));
}
function Ea(s) {
  return os(s), df(so(Uint8Array.from(s).reverse()));
}
function rd(s, e) {
  return ed(s.toString(16).padStart(e * 2, "0"));
}
function id(s, e) {
  return rd(s, e).reverse();
}
function Dt(s, e, t) {
  let n;
  if (typeof e == "string")
    try {
      n = ed(e);
    } catch (i) {
      throw new Error(s + " must be hex string or Uint8Array, cause: " + i);
    }
  else if (Jl(e)) n = Uint8Array.from(e);
  else throw new Error(s + " must be hex string or Uint8Array");
  const r = n.length;
  if (typeof t == "number" && r !== t)
    throw new Error(s + " of length " + t + " expected, got " + r);
  return n;
}
const gc = (s) => typeof s == "bigint" && nd <= s;
function O0(s, e, t) {
  return gc(s) && gc(e) && gc(t) && e <= s && s < t;
}
function al(s, e, t, n) {
  if (!O0(e, t, n))
    throw new Error(
      "expected valid " + s + ": " + t + " <= n < " + n + ", got " + e
    );
}
function k0(s) {
  let e;
  for (e = 0; s > nd; s >>= ol, e += 1);
  return e;
}
const qa = (s) => (ol << BigInt(s)) - ol;
function U0(s, e, t) {
  if (typeof s != "number" || s < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof t != "function") throw new Error("hmacFn must be a function");
  const n = (p) => new Uint8Array(p),
    r = (p) => Uint8Array.of(p);
  let i = n(s),
    o = n(s),
    a = 0;
  const c = () => {
      i.fill(1), o.fill(0), (a = 0);
    },
    l = (...p) => t(o, i, ...p),
    d = (p = n(0)) => {
      (o = l(r(0), p)),
        (i = l()),
        p.length !== 0 && ((o = l(r(1), p)), (i = l()));
    },
    u = () => {
      if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let p = 0;
      const w = [];
      for (; p < e; ) {
        i = l();
        const g = i.slice();
        w.push(g), (p += i.length);
      }
      return Vn(...w);
    };
  return (p, w) => {
    c(), d(p);
    let g;
    for (; !(g = w(u())); ) d();
    return c(), g;
  };
}
function Ha(s, e, t = {}) {
  if (!s || typeof s != "object")
    throw new Error("expected valid options object");
  function n(r, i, o) {
    const a = s[r];
    if (o && a === void 0) return;
    const c = typeof a;
    if (c !== i || a === null)
      throw new Error(`param "${r}" is invalid: expected ${i}, got ${c}`);
  }
  Object.entries(e).forEach(([r, i]) => n(r, i, !1)),
    Object.entries(t).forEach(([r, i]) => n(r, i, !0));
}
function yu(s) {
  const e = new WeakMap();
  return (t, ...n) => {
    const r = e.get(t);
    if (r !== void 0) return r;
    const i = s(t, ...n);
    return e.set(t, i), i;
  };
}
const Bt = BigInt(0),
  It = BigInt(1),
  Kn = BigInt(2),
  $0 = BigInt(3),
  uf = BigInt(4),
  hf = BigInt(5),
  pf = BigInt(8);
function rs(s, e) {
  const t = s % e;
  return t >= Bt ? t : e + t;
}
function ps(s, e, t) {
  let n = s;
  for (; e-- > Bt; ) (n *= n), (n %= t);
  return n;
}
function Eu(s, e) {
  if (s === Bt) throw new Error("invert: expected non-zero number");
  if (e <= Bt) throw new Error("invert: expected positive modulus, got " + e);
  let t = rs(s, e),
    n = e,
    r = Bt,
    i = It;
  for (; t !== Bt; ) {
    const o = n / t,
      a = n % t,
      c = r - i * o;
    (n = t), (t = a), (r = i), (i = c);
  }
  if (n !== It) throw new Error("invert: does not exist");
  return rs(r, e);
}
function ff(s, e) {
  const t = (s.ORDER + It) / uf,
    n = s.pow(e, t);
  if (!s.eql(s.sqr(n), e)) throw new Error("Cannot find square root");
  return n;
}
function D0(s, e) {
  const t = (s.ORDER - hf) / pf,
    n = s.mul(e, Kn),
    r = s.pow(n, t),
    i = s.mul(e, r),
    o = s.mul(s.mul(i, Kn), r),
    a = s.mul(i, s.sub(o, s.ONE));
  if (!s.eql(s.sqr(a), e)) throw new Error("Cannot find square root");
  return a;
}
function L0(s) {
  if (s < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e = s - It,
    t = 0;
  for (; e % Kn === Bt; ) (e /= Kn), t++;
  let n = Kn;
  const r = ci(s);
  for (; bu(r, n) === 1; )
    if (n++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (t === 1) return ff;
  let i = r.pow(n, e);
  const o = (e + It) / Kn;
  return function (a, c) {
    if (a.is0(c)) return c;
    if (bu(a, c) !== 1) throw new Error("Cannot find square root");
    let l = t,
      d = a.mul(a.ONE, i),
      u = a.pow(c, e),
      p = a.pow(c, o);
    for (; !a.eql(u, a.ONE); ) {
      if (a.is0(u)) return a.ZERO;
      let w = 1,
        g = a.sqr(u);
      for (; !a.eql(g, a.ONE); )
        if ((w++, (g = a.sqr(g)), w === l))
          throw new Error("Cannot find square root");
      const m = It << BigInt(l - w - 1),
        f = a.pow(d, m);
      (l = w), (d = a.sqr(f)), (u = a.mul(u, d)), (p = a.mul(p, f));
    }
    return p;
  };
}
function M0(s) {
  return s % uf === $0 ? ff : s % pf === hf ? D0 : L0(s);
}
const B0 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN",
];
function F0(s) {
  const e = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number",
    },
    t = B0.reduce((n, r) => ((n[r] = "function"), n), e);
  return Ha(s, t), s;
}
function j0(s, e, t) {
  if (t < Bt) throw new Error("invalid exponent, negatives unsupported");
  if (t === Bt) return s.ONE;
  if (t === It) return e;
  let n = s.ONE,
    r = e;
  for (; t > Bt; ) t & It && (n = s.mul(n, r)), (r = s.sqr(r)), (t >>= It);
  return n;
}
function gf(s, e, t = !1) {
  const n = new Array(e.length).fill(t ? s.ZERO : void 0),
    r = e.reduce(
      (o, a, c) => (s.is0(a) ? o : ((n[c] = o), s.mul(o, a))),
      s.ONE
    ),
    i = s.inv(r);
  return (
    e.reduceRight(
      (o, a, c) => (s.is0(a) ? o : ((n[c] = s.mul(o, n[c])), s.mul(o, a))),
      i
    ),
    n
  );
}
function bu(s, e) {
  const t = (s.ORDER - It) / Kn,
    n = s.pow(e, t),
    r = s.eql(n, s.ONE),
    i = s.eql(n, s.ZERO),
    o = s.eql(n, s.neg(s.ONE));
  if (!r && !i && !o) throw new Error("invalid Legendre symbol result");
  return r ? 1 : i ? 0 : -1;
}
function q0(s, e) {
  e !== void 0 && tn(e);
  const t = e !== void 0 ? e : s.toString(2).length,
    n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function ci(s, e, t = !1, n = {}) {
  if (s <= Bt) throw new Error("invalid field: expected ORDER > 0, got " + s);
  let r, i;
  if (typeof e == "object" && e != null) {
    if (n.sqrt || t) throw new Error("cannot specify opts in two arguments");
    const d = e;
    d.BITS && (r = d.BITS),
      d.sqrt && (i = d.sqrt),
      typeof d.isLE == "boolean" && (t = d.isLE);
  } else typeof e == "number" && (r = e), n.sqrt && (i = n.sqrt);
  const { nBitLength: o, nByteLength: a } = q0(s, r);
  if (a > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let c;
  const l = Object.freeze({
    ORDER: s,
    isLE: t,
    BITS: o,
    BYTES: a,
    MASK: qa(o),
    ZERO: Bt,
    ONE: It,
    create: (d) => rs(d, s),
    isValid: (d) => {
      if (typeof d != "bigint")
        throw new Error(
          "invalid field element: expected bigint, got " + typeof d
        );
      return Bt <= d && d < s;
    },
    is0: (d) => d === Bt,
    isValidNot0: (d) => !l.is0(d) && l.isValid(d),
    isOdd: (d) => (d & It) === It,
    neg: (d) => rs(-d, s),
    eql: (d, u) => d === u,
    sqr: (d) => rs(d * d, s),
    add: (d, u) => rs(d + u, s),
    sub: (d, u) => rs(d - u, s),
    mul: (d, u) => rs(d * u, s),
    pow: (d, u) => j0(l, d, u),
    div: (d, u) => rs(d * Eu(u, s), s),
    sqrN: (d) => d * d,
    addN: (d, u) => d + u,
    subN: (d, u) => d - u,
    mulN: (d, u) => d * u,
    inv: (d) => Eu(d, s),
    sqrt: i || ((d) => (c || (c = M0(s)), c(l, d))),
    toBytes: (d) => (t ? id(d, a) : rd(d, a)),
    fromBytes: (d) => {
      if (d.length !== a)
        throw new Error(
          "Field.fromBytes: expected " + a + " bytes, got " + d.length
        );
      return t ? Ea(d) : ja(d);
    },
    invertBatch: (d) => gf(l, d),
    cmov: (d, u, p) => (p ? u : d),
  });
  return Object.freeze(l);
}
function mf(s) {
  if (typeof s != "bigint") throw new Error("field order must be bigint");
  const e = s.toString(2).length;
  return Math.ceil(e / 8);
}
function wf(s) {
  const e = mf(s);
  return e + Math.ceil(e / 2);
}
function H0(s, e, t = !1) {
  const n = s.length,
    r = mf(e),
    i = wf(e);
  if (n < 16 || n < i || n > 1024)
    throw new Error("expected " + i + "-1024 bytes of input, got " + n);
  const o = t ? Ea(s) : ja(s),
    a = rs(o, e - It) + It;
  return t ? id(a, r) : rd(a, r);
}
const Kr = BigInt(0),
  Gn = BigInt(1);
function Bi(s, e) {
  const t = e.negate();
  return s ? t : e;
}
function W0(s, e, t) {
  const n = (i) => i.pz,
    r = gf(s.Fp, t.map(n));
  return t.map((i, o) => i.toAffine(r[o])).map(s.fromAffine);
}
function yf(s, e) {
  if (!Number.isSafeInteger(s) || s <= 0 || s > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + s);
}
function mc(s, e) {
  yf(s, e);
  const t = Math.ceil(e / s) + 1,
    n = 2 ** (s - 1),
    r = 2 ** s,
    i = qa(s),
    o = BigInt(s);
  return { windows: t, windowSize: n, mask: i, maxNumber: r, shiftBy: o };
}
function _u(s, e, t) {
  const { windowSize: n, mask: r, maxNumber: i, shiftBy: o } = t;
  let a = Number(s & r),
    c = s >> o;
  a > n && ((a -= i), (c += Gn));
  const l = e * n,
    d = l + Math.abs(a) - 1,
    u = a === 0,
    p = a < 0,
    w = e % 2 !== 0;
  return { nextN: c, offset: d, isZero: u, isNeg: p, isNegF: w, offsetF: l };
}
function z0(s, e) {
  if (!Array.isArray(s)) throw new Error("array expected");
  s.forEach((t, n) => {
    if (!(t instanceof e)) throw new Error("invalid point at index " + n);
  });
}
function V0(s, e) {
  if (!Array.isArray(s)) throw new Error("array of scalars expected");
  s.forEach((t, n) => {
    if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
  });
}
const wc = new WeakMap(),
  Ef = new WeakMap();
function yc(s) {
  return Ef.get(s) || 1;
}
function Cu(s) {
  if (s !== Kr) throw new Error("invalid wNAF");
}
function K0(s, e) {
  return {
    constTimeNegate: Bi,
    hasPrecomputes(t) {
      return yc(t) !== 1;
    },
    unsafeLadder(t, n, r = s.ZERO) {
      let i = t;
      for (; n > Kr; ) n & Gn && (r = r.add(i)), (i = i.double()), (n >>= Gn);
      return r;
    },
    precomputeWindow(t, n) {
      const { windows: r, windowSize: i } = mc(n, e),
        o = [];
      let a = t,
        c = a;
      for (let l = 0; l < r; l++) {
        (c = a), o.push(c);
        for (let d = 1; d < i; d++) (c = c.add(a)), o.push(c);
        a = c.double();
      }
      return o;
    },
    wNAF(t, n, r) {
      let i = s.ZERO,
        o = s.BASE;
      const a = mc(t, e);
      for (let c = 0; c < a.windows; c++) {
        const {
          nextN: l,
          offset: d,
          isZero: u,
          isNeg: p,
          isNegF: w,
          offsetF: g,
        } = _u(r, c, a);
        (r = l), u ? (o = o.add(Bi(w, n[g]))) : (i = i.add(Bi(p, n[d])));
      }
      return Cu(r), { p: i, f: o };
    },
    wNAFUnsafe(t, n, r, i = s.ZERO) {
      const o = mc(t, e);
      for (let a = 0; a < o.windows && r !== Kr; a++) {
        const { nextN: c, offset: l, isZero: d, isNeg: u } = _u(r, a, o);
        if (((r = c), !d)) {
          const p = n[l];
          i = i.add(u ? p.negate() : p);
        }
      }
      return Cu(r), i;
    },
    getPrecomputes(t, n, r) {
      let i = wc.get(n);
      return (
        i ||
          ((i = this.precomputeWindow(n, t)),
          t !== 1 && (typeof r == "function" && (i = r(i)), wc.set(n, i))),
        i
      );
    },
    wNAFCached(t, n, r) {
      const i = yc(t);
      return this.wNAF(i, this.getPrecomputes(i, t, r), n);
    },
    wNAFCachedUnsafe(t, n, r, i) {
      const o = yc(t);
      return o === 1
        ? this.unsafeLadder(t, n, i)
        : this.wNAFUnsafe(o, this.getPrecomputes(o, t, r), n, i);
    },
    setWindowSize(t, n) {
      yf(n, e), Ef.set(t, n), wc.delete(t);
    },
  };
}
function G0(s, e, t, n) {
  let r = e,
    i = s.ZERO,
    o = s.ZERO;
  for (; t > Kr || n > Kr; )
    t & Gn && (i = i.add(r)),
      n & Gn && (o = o.add(r)),
      (r = r.double()),
      (t >>= Gn),
      (n >>= Gn);
  return { p1: i, p2: o };
}
function Y0(s, e, t, n) {
  z0(t, s), V0(n, e);
  const r = t.length,
    i = n.length;
  if (r !== i)
    throw new Error("arrays of points and scalars must have equal length");
  const o = s.ZERO,
    a = k0(BigInt(r));
  let c = 1;
  a > 12 ? (c = a - 3) : a > 4 ? (c = a - 2) : a > 0 && (c = 2);
  const l = qa(c),
    d = new Array(Number(l) + 1).fill(o),
    u = Math.floor((e.BITS - 1) / c) * c;
  let p = o;
  for (let w = u; w >= 0; w -= c) {
    d.fill(o);
    for (let m = 0; m < i; m++) {
      const f = n[m],
        E = Number((f >> BigInt(w)) & l);
      d[E] = d[E].add(t[m]);
    }
    let g = o;
    for (let m = d.length - 1, f = o; m > 0; m--)
      (f = f.add(d[m])), (g = g.add(f));
    if (((p = p.add(g)), w !== 0)) for (let m = 0; m < c; m++) p = p.double();
  }
  return p;
}
function vu(s, e) {
  if (e) {
    if (e.ORDER !== s)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return F0(e), e;
  } else return ci(s);
}
function Z0(s, e, t = {}) {
  if (!e || typeof e != "object")
    throw new Error(`expected valid ${s} CURVE object`);
  for (const o of ["p", "n", "h"]) {
    const a = e[o];
    if (!(typeof a == "bigint" && a > Kr))
      throw new Error(`CURVE.${o} must be positive bigint`);
  }
  const n = vu(e.p, t.Fp),
    r = vu(e.n, t.Fn),
    i = ["Gx", "Gy", "a", "b"];
  for (const o of i)
    if (!n.isValid(e[o]))
      throw new Error(`CURVE.${o} must be valid field element of CURVE.Fp`);
  return { Fp: n, Fn: r };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
const yi = BigInt(0),
  wr = BigInt(1),
  Ho = BigInt(2);
function J0(s) {
  return (
    Ha(s, { adjustScalarBytes: "function", powPminus2: "function" }),
    Object.freeze({ ...s })
  );
}
function X0(s) {
  const e = J0(s),
    { P: t, type: n, adjustScalarBytes: r, powPminus2: i, randomBytes: o } = e,
    a = n === "x25519";
  if (!a && n !== "x448") throw new Error("invalid type");
  const c = o || ai,
    l = a ? 255 : 448,
    d = a ? 32 : 56,
    u = BigInt(a ? 9 : 5),
    p = BigInt(a ? 121665 : 39081),
    w = a ? Ho ** BigInt(254) : Ho ** BigInt(447),
    g = a
      ? BigInt(8) * Ho ** BigInt(251) - wr
      : BigInt(4) * Ho ** BigInt(445) - wr,
    m = w + g + wr,
    f = (C) => rs(C, t),
    E = b(u);
  function b(C) {
    return id(f(C), d);
  }
  function _(C) {
    const T = Dt("u coordinate", C, d);
    return a && (T[31] &= 127), f(Ea(T));
  }
  function N(C) {
    return Ea(r(Dt("scalar", C, d)));
  }
  function A(C, T) {
    const v = K(_(T), N(C));
    if (v === yi) throw new Error("invalid private or public key received");
    return b(v);
  }
  function L(C) {
    return A(C, E);
  }
  function Q(C, T, v) {
    const I = f(C * (T - v));
    return (T = f(T - I)), (v = f(v + I)), { x_2: T, x_3: v };
  }
  function K(C, T) {
    al("u", C, yi, t), al("scalar", T, w, m);
    const v = T,
      I = C;
    let x = wr,
      U = yi,
      k = C,
      $ = wr,
      B = yi;
    for (let O = BigInt(l - 1); O >= yi; O--) {
      const ee = (v >> O) & wr;
      (B ^= ee),
        ({ x_2: x, x_3: k } = Q(B, x, k)),
        ({ x_2: U, x_3: $ } = Q(B, U, $)),
        (B = ee);
      const J = x + U,
        ce = f(J * J),
        ye = x - U,
        we = f(ye * ye),
        Ee = ce - we,
        Me = k + $,
        Ze = k - $,
        Ye = f(Ze * J),
        Ve = f(Me * ye),
        Jt = Ye + Ve,
        js = Ye - Ve;
      (k = f(Jt * Jt)),
        ($ = f(I * f(js * js))),
        (x = f(ce * we)),
        (U = f(Ee * (ce + f(p * Ee))));
    }
    ({ x_2: x, x_3: k } = Q(B, x, k)), ({ x_2: U, x_3: $ } = Q(B, U, $));
    const V = i(U);
    return f(x * V);
  }
  return {
    scalarMult: A,
    scalarMultBase: L,
    getSharedSecret: (C, T) => A(C, T),
    getPublicKey: (C) => L(C),
    utils: { randomPrivateKey: () => c(d) },
    GuBytes: E.slice(),
  };
}
BigInt(0);
const Q0 = BigInt(1),
  Au = BigInt(2),
  e_ = BigInt(3),
  t_ = BigInt(5);
BigInt(8);
const bf = {
  p: BigInt(
    "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"
  ),
  n: BigInt(
    "0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"
  ),
  a: BigInt(
    "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"
  ),
  d: BigInt(
    "0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"
  ),
  Gx: BigInt(
    "0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"
  ),
  Gy: BigInt(
    "0x6666666666666666666666666666666666666666666666666666666666666658"
  ),
};
function s_(s) {
  const e = BigInt(10),
    t = BigInt(20),
    n = BigInt(40),
    r = BigInt(80),
    i = bf.p,
    o = (((s * s) % i) * s) % i,
    a = (ps(o, Au, i) * o) % i,
    c = (ps(a, Q0, i) * s) % i,
    l = (ps(c, t_, i) * c) % i,
    d = (ps(l, e, i) * l) % i,
    u = (ps(d, t, i) * d) % i,
    p = (ps(u, n, i) * u) % i,
    w = (ps(p, r, i) * p) % i,
    g = (ps(w, r, i) * p) % i,
    m = (ps(g, e, i) * l) % i;
  return { pow_p_5_8: (ps(m, Au, i) * s) % i, b2: o };
}
function n_(s) {
  return (s[0] &= 248), (s[31] &= 127), (s[31] |= 64), s;
}
const cl = (() => {
  const s = bf.p;
  return X0({
    P: s,
    type: "x25519",
    powPminus2: (e) => {
      const { pow_p_5_8: t, b2: n } = s_(e);
      return rs(ps(t, e_, s) * n, s);
    },
    adjustScalarBytes: n_,
  });
})();
function Iu(s) {
  s.lowS !== void 0 && ya("lowS", s.lowS),
    s.prehash !== void 0 && ya("prehash", s.prehash);
}
class r_ extends Error {
  constructor(e = "") {
    super(e);
  }
}
const Ys = {
    Err: r_,
    _tlv: {
      encode: (s, e) => {
        const { Err: t } = Ys;
        if (s < 0 || s > 256) throw new t("tlv.encode: wrong tag");
        if (e.length & 1) throw new t("tlv.encode: unpadded data");
        const n = e.length / 2,
          r = qo(n);
        if ((r.length / 2) & 128)
          throw new t("tlv.encode: long form length too big");
        const i = n > 127 ? qo((r.length / 2) | 128) : "";
        return qo(s) + i + r + e;
      },
      decode(s, e) {
        const { Err: t } = Ys;
        let n = 0;
        if (s < 0 || s > 256) throw new t("tlv.encode: wrong tag");
        if (e.length < 2 || e[n++] !== s) throw new t("tlv.decode: wrong tlv");
        const r = e[n++],
          i = !!(r & 128);
        let o = 0;
        if (!i) o = r;
        else {
          const c = r & 127;
          if (!c)
            throw new t("tlv.decode(long): indefinite length not supported");
          if (c > 4) throw new t("tlv.decode(long): byte length is too big");
          const l = e.subarray(n, n + c);
          if (l.length !== c)
            throw new t("tlv.decode: length bytes not complete");
          if (l[0] === 0) throw new t("tlv.decode(long): zero leftmost byte");
          for (const d of l) o = (o << 8) | d;
          if (((n += c), o < 128))
            throw new t("tlv.decode(long): not minimal encoding");
        }
        const a = e.subarray(n, n + o);
        if (a.length !== o) throw new t("tlv.decode: wrong value length");
        return { v: a, l: e.subarray(n + o) };
      },
    },
    _int: {
      encode(s) {
        const { Err: e } = Ys;
        if (s < Fi) throw new e("integer: negative integers are not allowed");
        let t = qo(s);
        if ((Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1))
          throw new e("unexpected DER parsing assertion: unpadded hex");
        return t;
      },
      decode(s) {
        const { Err: e } = Ys;
        if (s[0] & 128) throw new e("invalid signature integer: negative");
        if (s[0] === 0 && !(s[1] & 128))
          throw new e("invalid signature integer: unnecessary leading zero");
        return ja(s);
      },
    },
    toSig(s) {
      const { Err: e, _int: t, _tlv: n } = Ys,
        r = Dt("signature", s),
        { v: i, l: o } = n.decode(48, r);
      if (o.length) throw new e("invalid signature: left bytes after parsing");
      const { v: a, l: c } = n.decode(2, i),
        { v: l, l: d } = n.decode(2, c);
      if (d.length) throw new e("invalid signature: left bytes after parsing");
      return { r: t.decode(a), s: t.decode(l) };
    },
    hexFromSig(s) {
      const { _tlv: e, _int: t } = Ys,
        n = e.encode(2, t.encode(s.r)),
        r = e.encode(2, t.encode(s.s)),
        i = n + r;
      return e.encode(48, i);
    },
  },
  Fi = BigInt(0),
  ji = BigInt(1),
  i_ = BigInt(2),
  Wo = BigInt(3),
  o_ = BigInt(4);
function a_(s, e, t) {
  function n(r) {
    const i = s.sqr(r),
      o = s.mul(i, r);
    return s.add(s.add(o, s.mul(r, e)), t);
  }
  return n;
}
function _f(s, e, t) {
  const { BYTES: n } = s;
  function r(i) {
    let o;
    if (typeof i == "bigint") o = i;
    else {
      let a = Dt("private key", i);
      if (e) {
        if (!e.includes(a.length * 2)) throw new Error("invalid private key");
        const c = new Uint8Array(n);
        c.set(a, c.length - a.length), (a = c);
      }
      try {
        o = s.fromBytes(a);
      } catch {
        throw new Error(
          `invalid private key: expected ui8a of size ${n}, got ${typeof i}`
        );
      }
    }
    if ((t && (o = s.create(o)), !s.isValidNot0(o)))
      throw new Error("invalid private key: out of range [1..N-1]");
    return o;
  }
  return r;
}
function c_(s, e = {}) {
  const { Fp: t, Fn: n } = Z0("weierstrass", s, e),
    { h: r, n: i } = s;
  Ha(
    e,
    {},
    {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean",
    }
  );
  const { endo: o } = e;
  if (
    o &&
    (!t.is0(s.a) ||
      typeof o.beta != "bigint" ||
      typeof o.splitScalar != "function")
  )
    throw new Error(
      'invalid endo: expected "beta": bigint and "splitScalar": function'
    );
  function a() {
    if (!t.isOdd)
      throw new Error(
        "compression is not supported: Field does not have .isOdd()"
      );
  }
  function c(K, C, T) {
    const { x: v, y: I } = C.toAffine(),
      x = t.toBytes(v);
    if ((ya("isCompressed", T), T)) {
      a();
      const U = !t.isOdd(I);
      return Vn(Cf(U), x);
    } else return Vn(Uint8Array.of(4), x, t.toBytes(I));
  }
  function l(K) {
    os(K);
    const C = t.BYTES,
      T = C + 1,
      v = 2 * C + 1,
      I = K.length,
      x = K[0],
      U = K.subarray(1);
    if (I === T && (x === 2 || x === 3)) {
      const k = t.fromBytes(U);
      if (!t.isValid(k)) throw new Error("bad point: is not on curve, wrong x");
      const $ = p(k);
      let B;
      try {
        B = t.sqrt($);
      } catch (O) {
        const ee = O instanceof Error ? ": " + O.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + ee);
      }
      a();
      const V = t.isOdd(B);
      return ((x & 1) === 1) !== V && (B = t.neg(B)), { x: k, y: B };
    } else if (I === v && x === 4) {
      const k = t.fromBytes(U.subarray(C * 0, C * 1)),
        $ = t.fromBytes(U.subarray(C * 1, C * 2));
      if (!w(k, $)) throw new Error("bad point: is not on curve");
      return { x: k, y: $ };
    } else
      throw new Error(
        `bad point: got length ${I}, expected compressed=${T} or uncompressed=${v}`
      );
  }
  const d = e.toBytes || c,
    u = e.fromBytes || l,
    p = a_(t, s.a, s.b);
  function w(K, C) {
    const T = t.sqr(C),
      v = p(K);
    return t.eql(T, v);
  }
  if (!w(s.Gx, s.Gy)) throw new Error("bad curve params: generator point");
  const g = t.mul(t.pow(s.a, Wo), o_),
    m = t.mul(t.sqr(s.b), BigInt(27));
  if (t.is0(t.add(g, m))) throw new Error("bad curve params: a or b");
  function f(K, C, T = !1) {
    if (!t.isValid(C) || (T && t.is0(C)))
      throw new Error(`bad point coordinate ${K}`);
    return C;
  }
  function E(K) {
    if (!(K instanceof A)) throw new Error("ProjectivePoint expected");
  }
  const b = yu((K, C) => {
      const { px: T, py: v, pz: I } = K;
      if (t.eql(I, t.ONE)) return { x: T, y: v };
      const x = K.is0();
      C == null && (C = x ? t.ONE : t.inv(I));
      const U = t.mul(T, C),
        k = t.mul(v, C),
        $ = t.mul(I, C);
      if (x) return { x: t.ZERO, y: t.ZERO };
      if (!t.eql($, t.ONE)) throw new Error("invZ was invalid");
      return { x: U, y: k };
    }),
    _ = yu((K) => {
      if (K.is0()) {
        if (e.allowInfinityPoint && !t.is0(K.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: C, y: T } = K.toAffine();
      if (!t.isValid(C) || !t.isValid(T))
        throw new Error("bad point: x or y not field elements");
      if (!w(C, T)) throw new Error("bad point: equation left != right");
      if (!K.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return !0;
    });
  function N(K, C, T, v, I) {
    return (
      (T = new A(t.mul(T.px, K), T.py, T.pz)),
      (C = Bi(v, C)),
      (T = Bi(I, T)),
      C.add(T)
    );
  }
  class A {
    constructor(C, T, v) {
      (this.px = f("x", C)),
        (this.py = f("y", T, !0)),
        (this.pz = f("z", v)),
        Object.freeze(this);
    }
    static fromAffine(C) {
      const { x: T, y: v } = C || {};
      if (!C || !t.isValid(T) || !t.isValid(v))
        throw new Error("invalid affine point");
      if (C instanceof A) throw new Error("projective point not allowed");
      return t.is0(T) && t.is0(v) ? A.ZERO : new A(T, v, t.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(C) {
      return W0(A, "pz", C);
    }
    static fromBytes(C) {
      return os(C), A.fromHex(C);
    }
    static fromHex(C) {
      const T = A.fromAffine(u(Dt("pointHex", C)));
      return T.assertValidity(), T;
    }
    static fromPrivateKey(C) {
      const T = _f(n, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
      return A.BASE.multiply(T(C));
    }
    static msm(C, T) {
      return Y0(A, n, C, T);
    }
    precompute(C = 8, T = !0) {
      return Q.setWindowSize(this, C), T || this.multiply(Wo), this;
    }
    _setWindowSize(C) {
      this.precompute(C);
    }
    assertValidity() {
      _(this);
    }
    hasEvenY() {
      const { y: C } = this.toAffine();
      if (!t.isOdd) throw new Error("Field doesn't support isOdd");
      return !t.isOdd(C);
    }
    equals(C) {
      E(C);
      const { px: T, py: v, pz: I } = this,
        { px: x, py: U, pz: k } = C,
        $ = t.eql(t.mul(T, k), t.mul(x, I)),
        B = t.eql(t.mul(v, k), t.mul(U, I));
      return $ && B;
    }
    negate() {
      return new A(this.px, t.neg(this.py), this.pz);
    }
    double() {
      const { a: C, b: T } = s,
        v = t.mul(T, Wo),
        { px: I, py: x, pz: U } = this;
      let k = t.ZERO,
        $ = t.ZERO,
        B = t.ZERO,
        V = t.mul(I, I),
        O = t.mul(x, x),
        ee = t.mul(U, U),
        J = t.mul(I, x);
      return (
        (J = t.add(J, J)),
        (B = t.mul(I, U)),
        (B = t.add(B, B)),
        (k = t.mul(C, B)),
        ($ = t.mul(v, ee)),
        ($ = t.add(k, $)),
        (k = t.sub(O, $)),
        ($ = t.add(O, $)),
        ($ = t.mul(k, $)),
        (k = t.mul(J, k)),
        (B = t.mul(v, B)),
        (ee = t.mul(C, ee)),
        (J = t.sub(V, ee)),
        (J = t.mul(C, J)),
        (J = t.add(J, B)),
        (B = t.add(V, V)),
        (V = t.add(B, V)),
        (V = t.add(V, ee)),
        (V = t.mul(V, J)),
        ($ = t.add($, V)),
        (ee = t.mul(x, U)),
        (ee = t.add(ee, ee)),
        (V = t.mul(ee, J)),
        (k = t.sub(k, V)),
        (B = t.mul(ee, O)),
        (B = t.add(B, B)),
        (B = t.add(B, B)),
        new A(k, $, B)
      );
    }
    add(C) {
      E(C);
      const { px: T, py: v, pz: I } = this,
        { px: x, py: U, pz: k } = C;
      let $ = t.ZERO,
        B = t.ZERO,
        V = t.ZERO;
      const O = s.a,
        ee = t.mul(s.b, Wo);
      let J = t.mul(T, x),
        ce = t.mul(v, U),
        ye = t.mul(I, k),
        we = t.add(T, v),
        Ee = t.add(x, U);
      (we = t.mul(we, Ee)),
        (Ee = t.add(J, ce)),
        (we = t.sub(we, Ee)),
        (Ee = t.add(T, I));
      let Me = t.add(x, k);
      return (
        (Ee = t.mul(Ee, Me)),
        (Me = t.add(J, ye)),
        (Ee = t.sub(Ee, Me)),
        (Me = t.add(v, I)),
        ($ = t.add(U, k)),
        (Me = t.mul(Me, $)),
        ($ = t.add(ce, ye)),
        (Me = t.sub(Me, $)),
        (V = t.mul(O, Ee)),
        ($ = t.mul(ee, ye)),
        (V = t.add($, V)),
        ($ = t.sub(ce, V)),
        (V = t.add(ce, V)),
        (B = t.mul($, V)),
        (ce = t.add(J, J)),
        (ce = t.add(ce, J)),
        (ye = t.mul(O, ye)),
        (Ee = t.mul(ee, Ee)),
        (ce = t.add(ce, ye)),
        (ye = t.sub(J, ye)),
        (ye = t.mul(O, ye)),
        (Ee = t.add(Ee, ye)),
        (J = t.mul(ce, Ee)),
        (B = t.add(B, J)),
        (J = t.mul(Me, Ee)),
        ($ = t.mul(we, $)),
        ($ = t.sub($, J)),
        (J = t.mul(we, ce)),
        (V = t.mul(Me, V)),
        (V = t.add(V, J)),
        new A($, B, V)
      );
    }
    subtract(C) {
      return this.add(C.negate());
    }
    is0() {
      return this.equals(A.ZERO);
    }
    multiply(C) {
      const { endo: T } = e;
      if (!n.isValidNot0(C)) throw new Error("invalid scalar: out of range");
      let v, I;
      const x = (U) => Q.wNAFCached(this, U, A.normalizeZ);
      if (T) {
        const { k1neg: U, k1: k, k2neg: $, k2: B } = T.splitScalar(C),
          { p: V, f: O } = x(k),
          { p: ee, f: J } = x(B);
        (I = O.add(J)), (v = N(T.beta, V, ee, U, $));
      } else {
        const { p: U, f: k } = x(C);
        (v = U), (I = k);
      }
      return A.normalizeZ([v, I])[0];
    }
    multiplyUnsafe(C) {
      const { endo: T } = e,
        v = this;
      if (!n.isValid(C)) throw new Error("invalid scalar: out of range");
      if (C === Fi || v.is0()) return A.ZERO;
      if (C === ji) return v;
      if (Q.hasPrecomputes(this)) return this.multiply(C);
      if (T) {
        const { k1neg: I, k1: x, k2neg: U, k2: k } = T.splitScalar(C),
          { p1: $, p2: B } = G0(A, v, x, k);
        return N(T.beta, $, B, I, U);
      } else return Q.wNAFCachedUnsafe(v, C);
    }
    multiplyAndAddUnsafe(C, T, v) {
      const I = this.multiplyUnsafe(T).add(C.multiplyUnsafe(v));
      return I.is0() ? void 0 : I;
    }
    toAffine(C) {
      return b(this, C);
    }
    isTorsionFree() {
      const { isTorsionFree: C } = e;
      return r === ji ? !0 : C ? C(A, this) : Q.wNAFCachedUnsafe(this, i).is0();
    }
    clearCofactor() {
      const { clearCofactor: C } = e;
      return r === ji ? this : C ? C(A, this) : this.multiplyUnsafe(r);
    }
    toBytes(C = !0) {
      return ya("isCompressed", C), this.assertValidity(), d(A, this, C);
    }
    toRawBytes(C = !0) {
      return this.toBytes(C);
    }
    toHex(C = !0) {
      return so(this.toBytes(C));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  (A.BASE = new A(s.Gx, s.Gy, t.ONE)),
    (A.ZERO = new A(t.ZERO, t.ONE, t.ZERO)),
    (A.Fp = t),
    (A.Fn = n);
  const L = n.BITS,
    Q = K0(A, e.endo ? Math.ceil(L / 2) : L);
  return A;
}
function Cf(s) {
  return Uint8Array.of(s ? 2 : 3);
}
function l_(s, e, t = {}) {
  Ha(
    e,
    { hash: "function" },
    {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function",
    }
  );
  const n = e.randomBytes || ai,
    r = e.hmac || ((v, ...I) => Ba(e.hash, v, Vn(...I))),
    { Fp: i, Fn: o } = s,
    { ORDER: a, BITS: c } = o;
  function l(v) {
    const I = a >> ji;
    return v > I;
  }
  function d(v) {
    return l(v) ? o.neg(v) : v;
  }
  function u(v, I) {
    if (!o.isValidNot0(I))
      throw new Error(`invalid signature ${v}: out of range 1..CURVE.n`);
  }
  class p {
    constructor(I, x, U) {
      u("r", I),
        u("s", x),
        (this.r = I),
        (this.s = x),
        U != null && (this.recovery = U),
        Object.freeze(this);
    }
    static fromCompact(I) {
      const x = o.BYTES,
        U = Dt("compactSignature", I, x * 2);
      return new p(
        o.fromBytes(U.subarray(0, x)),
        o.fromBytes(U.subarray(x, x * 2))
      );
    }
    static fromDER(I) {
      const { r: x, s: U } = Ys.toSig(Dt("DER", I));
      return new p(x, U);
    }
    assertValidity() {}
    addRecoveryBit(I) {
      return new p(this.r, this.s, I);
    }
    recoverPublicKey(I) {
      const x = i.ORDER,
        { r: U, s: k, recovery: $ } = this;
      if ($ == null || ![0, 1, 2, 3].includes($))
        throw new Error("recovery id invalid");
      if (a * i_ < x && $ > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const B = $ === 2 || $ === 3 ? U + a : U;
      if (!i.isValid(B)) throw new Error("recovery id 2 or 3 invalid");
      const V = i.toBytes(B),
        O = s.fromHex(Vn(Cf(($ & 1) === 0), V)),
        ee = o.inv(B),
        J = _(Dt("msgHash", I)),
        ce = o.create(-J * ee),
        ye = o.create(k * ee),
        we = s.BASE.multiplyUnsafe(ce).add(O.multiplyUnsafe(ye));
      if (we.is0()) throw new Error("point at infinify");
      return we.assertValidity(), we;
    }
    hasHighS() {
      return l(this.s);
    }
    normalizeS() {
      return this.hasHighS()
        ? new p(this.r, o.neg(this.s), this.recovery)
        : this;
    }
    toBytes(I) {
      if (I === "compact") return Vn(o.toBytes(this.r), o.toBytes(this.s));
      if (I === "der") return ed(Ys.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return so(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return so(this.toBytes("compact"));
    }
  }
  const w = _f(o, t.allowedPrivateKeyLengths, t.wrapPrivateKey),
    g = {
      isValidPrivateKey(v) {
        try {
          return w(v), !0;
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: w,
      randomPrivateKey: () => {
        const v = a;
        return H0(n(wf(v)), v);
      },
      precompute(v = 8, I = s.BASE) {
        return I.precompute(v, !1);
      },
    };
  function m(v, I = !0) {
    return s.fromPrivateKey(v).toBytes(I);
  }
  function f(v) {
    if (typeof v == "bigint") return !1;
    if (v instanceof s) return !0;
    const I = Dt("key", v).length,
      x = i.BYTES,
      U = x + 1,
      k = 2 * x + 1;
    if (!(t.allowedPrivateKeyLengths || o.BYTES === U))
      return I === U || I === k;
  }
  function E(v, I, x = !0) {
    if (f(v) === !0) throw new Error("first arg must be private key");
    if (f(I) === !1) throw new Error("second arg must be public key");
    return s.fromHex(I).multiply(w(v)).toBytes(x);
  }
  const b =
      e.bits2int ||
      function (v) {
        if (v.length > 8192) throw new Error("input is too large");
        const I = ja(v),
          x = v.length * 8 - c;
        return x > 0 ? I >> BigInt(x) : I;
      },
    _ =
      e.bits2int_modN ||
      function (v) {
        return o.create(b(v));
      },
    N = qa(c);
  function A(v) {
    return al("num < 2^" + c, v, Fi, N), o.toBytes(v);
  }
  function L(v, I, x = Q) {
    if (["recovered", "canonical"].some((we) => we in x))
      throw new Error("sign() legacy options not supported");
    const { hash: U } = e;
    let { lowS: k, prehash: $, extraEntropy: B } = x;
    k == null && (k = !0),
      (v = Dt("msgHash", v)),
      Iu(x),
      $ && (v = Dt("prehashed msgHash", U(v)));
    const V = _(v),
      O = w(I),
      ee = [A(O), A(V)];
    if (B != null && B !== !1) {
      const we = B === !0 ? n(i.BYTES) : B;
      ee.push(Dt("extraEntropy", we));
    }
    const J = Vn(...ee),
      ce = V;
    function ye(we) {
      const Ee = b(we);
      if (!o.isValidNot0(Ee)) return;
      const Me = o.inv(Ee),
        Ze = s.BASE.multiply(Ee).toAffine(),
        Ye = o.create(Ze.x);
      if (Ye === Fi) return;
      const Ve = o.create(Me * o.create(ce + Ye * O));
      if (Ve === Fi) return;
      let Jt = (Ze.x === Ye ? 0 : 2) | Number(Ze.y & ji),
        js = Ve;
      return k && l(Ve) && ((js = d(Ve)), (Jt ^= 1)), new p(Ye, js, Jt);
    }
    return { seed: J, k2sig: ye };
  }
  const Q = { lowS: e.lowS, prehash: !1 },
    K = { lowS: e.lowS, prehash: !1 };
  function C(v, I, x = Q) {
    const { seed: U, k2sig: k } = L(v, I, x);
    return U0(e.hash.outputLen, o.BYTES, r)(U, k);
  }
  s.BASE.precompute(8);
  function T(v, I, x, U = K) {
    const k = v;
    (I = Dt("msgHash", I)), (x = Dt("publicKey", x)), Iu(U);
    const { lowS: $, prehash: B, format: V } = U;
    if ("strict" in U) throw new Error("options.strict was renamed to lowS");
    if (V !== void 0 && !["compact", "der", "js"].includes(V))
      throw new Error('format must be "compact", "der" or "js"');
    const O = typeof k == "string" || Jl(k),
      ee =
        !O &&
        !V &&
        typeof k == "object" &&
        k !== null &&
        typeof k.r == "bigint" &&
        typeof k.s == "bigint";
    if (!O && !ee)
      throw new Error(
        "invalid signature, expected Uint8Array, hex string or Signature instance"
      );
    let J, ce;
    try {
      if (ee)
        if (V === void 0 || V === "js") J = new p(k.r, k.s);
        else throw new Error("invalid format");
      if (O) {
        try {
          V !== "compact" && (J = p.fromDER(k));
        } catch (Jt) {
          if (!(Jt instanceof Ys.Err)) throw Jt;
        }
        !J && V !== "der" && (J = p.fromCompact(k));
      }
      ce = s.fromHex(x);
    } catch {
      return !1;
    }
    if (!J || ($ && J.hasHighS())) return !1;
    B && (I = e.hash(I));
    const { r: ye, s: we } = J,
      Ee = _(I),
      Me = o.inv(we),
      Ze = o.create(Ee * Me),
      Ye = o.create(ye * Me),
      Ve = s.BASE.multiplyUnsafe(Ze).add(ce.multiplyUnsafe(Ye));
    return Ve.is0() ? !1 : o.create(Ve.x) === ye;
  }
  return Object.freeze({
    getPublicKey: m,
    getSharedSecret: E,
    sign: C,
    verify: T,
    utils: g,
    Point: s,
    Signature: p,
  });
}
function d_(s) {
  const e = {
      a: s.a,
      b: s.b,
      p: s.Fp.ORDER,
      n: s.n,
      h: s.h,
      Gx: s.Gx,
      Gy: s.Gy,
    },
    t = s.Fp,
    n = ci(e.n, s.nBitLength),
    r = {
      Fp: t,
      Fn: n,
      allowedPrivateKeyLengths: s.allowedPrivateKeyLengths,
      allowInfinityPoint: s.allowInfinityPoint,
      endo: s.endo,
      wrapPrivateKey: s.wrapPrivateKey,
      isTorsionFree: s.isTorsionFree,
      clearCofactor: s.clearCofactor,
      fromBytes: s.fromBytes,
      toBytes: s.toBytes,
    };
  return { CURVE: e, curveOpts: r };
}
function u_(s) {
  const { CURVE: e, curveOpts: t } = d_(s),
    n = {
      hash: s.hash,
      hmac: s.hmac,
      randomBytes: s.randomBytes,
      lowS: s.lowS,
      bits2int: s.bits2int,
      bits2int_modN: s.bits2int_modN,
    };
  return { CURVE: e, curveOpts: t, ecdsaOpts: n };
}
function h_(s, e) {
  return Object.assign({}, e, { ProjectivePoint: e.Point, CURVE: s });
}
function p_(s) {
  const { CURVE: e, curveOpts: t, ecdsaOpts: n } = u_(s),
    r = c_(e, t),
    i = l_(r, n, t);
  return h_(s, i);
}
function ll(s, e) {
  const t = (n) => p_({ ...s, hash: n });
  return { ...t(e), create: t };
}
const vf = {
    p: BigInt(
      "0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"
    ),
    n: BigInt(
      "0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"
    ),
    h: BigInt(1),
    a: BigInt(
      "0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"
    ),
    b: BigInt(
      "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"
    ),
    Gx: BigInt(
      "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"
    ),
    Gy: BigInt(
      "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
    ),
  },
  Af = {
    p: BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"
    ),
    n: BigInt(
      "0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"
    ),
    h: BigInt(1),
    a: BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"
    ),
    b: BigInt(
      "0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"
    ),
    Gx: BigInt(
      "0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"
    ),
    Gy: BigInt(
      "0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"
    ),
  },
  If = {
    p: BigInt(
      "0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
    ),
    n: BigInt(
      "0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"
    ),
    h: BigInt(1),
    a: BigInt(
      "0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"
    ),
    b: BigInt(
      "0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"
    ),
    Gx: BigInt(
      "0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"
    ),
    Gy: BigInt(
      "0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"
    ),
  },
  f_ = ci(vf.p),
  g_ = ci(Af.p),
  m_ = ci(If.p),
  w_ = ll({ ...vf, Fp: f_, lowS: !1 }, Ma);
ll({ ...Af, Fp: g_, lowS: !1 }, Ib),
  ll(
    { ...If, Fp: m_, lowS: !1, allowedPrivateKeyLengths: [130, 131, 132] },
    Ab
  );
const y_ = w_,
  Sf = "base10",
  St = "base16",
  ws = "base64pad",
  wn = "base64url",
  Ro = "utf8",
  Nf = 0,
  Js = 1,
  xo = 2,
  E_ = 0,
  Su = 1,
  qi = 12,
  od = 32;
function b_() {
  const s = cl.utils.randomPrivateKey(),
    e = cl.getPublicKey(s);
  return { privateKey: Ft(s, St), publicKey: Ft(e, St) };
}
function dl() {
  const s = ai(od);
  return Ft(s, St);
}
function __(s, e) {
  const t = cl.getSharedSecret(is(s, St), is(e, St)),
    n = P0(Fa, t, void 0, void 0, od);
  return Ft(n, St);
}
function ea(s) {
  const e = Fa(is(s, St));
  return Ft(e, St);
}
function Os(s) {
  const e = Fa(is(s, Ro));
  return Ft(e, St);
}
function Tf(s) {
  return is(`${s}`, Sf);
}
function sr(s) {
  return Number(Ft(s, Sf));
}
function Rf(s) {
  return s.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function xf(s) {
  const e = s.replace(/-/g, "+").replace(/_/g, "/"),
    t = (4 - (e.length % 4)) % 4;
  return e + "=".repeat(t);
}
function C_(s) {
  const e = Tf(typeof s.type < "u" ? s.type : Nf);
  if (sr(e) === Js && typeof s.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof s.senderPublicKey < "u" ? is(s.senderPublicKey, St) : void 0,
    n = typeof s.iv < "u" ? is(s.iv, St) : ai(qi),
    r = is(s.symKey, St),
    i = cf(r, n).encrypt(is(s.message, Ro)),
    o = Pf({ type: e, sealed: i, iv: n, senderPublicKey: t });
  return s.encoding === wn ? Rf(o) : o;
}
function v_(s) {
  const e = is(s.symKey, St),
    { sealed: t, iv: n } = ro({ encoded: s.encoded, encoding: s.encoding }),
    r = cf(e, n).decrypt(t);
  if (r === null) throw new Error("Failed to decrypt");
  return Ft(r, Ro);
}
function A_(s, e) {
  const t = Tf(xo),
    n = ai(qi),
    r = is(s, Ro),
    i = Pf({ type: t, sealed: r, iv: n });
  return e === wn ? Rf(i) : i;
}
function I_(s, e) {
  const { sealed: t } = ro({ encoded: s, encoding: e });
  return Ft(t, Ro);
}
function Pf(s) {
  if (sr(s.type) === xo) return Ft(Mi([s.type, s.sealed]), ws);
  if (sr(s.type) === Js) {
    if (typeof s.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return Ft(Mi([s.type, s.senderPublicKey, s.iv, s.sealed]), ws);
  }
  return Ft(Mi([s.type, s.iv, s.sealed]), ws);
}
function ro(s) {
  const e = (s.encoding || ws) === wn ? xf(s.encoded) : s.encoded,
    t = is(e, ws),
    n = t.slice(E_, Su),
    r = Su;
  if (sr(n) === Js) {
    const c = r + od,
      l = c + qi,
      d = t.slice(r, c),
      u = t.slice(c, l),
      p = t.slice(l);
    return { type: n, sealed: p, iv: u, senderPublicKey: d };
  }
  if (sr(n) === xo) {
    const c = t.slice(r),
      l = ai(qi);
    return { type: n, sealed: c, iv: l };
  }
  const i = r + qi,
    o = t.slice(r, i),
    a = t.slice(i);
  return { type: n, sealed: a, iv: o };
}
function S_(s, e) {
  const t = ro({ encoded: s, encoding: e == null ? void 0 : e.encoding });
  return Of({
    type: sr(t.type),
    senderPublicKey:
      typeof t.senderPublicKey < "u" ? Ft(t.senderPublicKey, St) : void 0,
    receiverPublicKey: e == null ? void 0 : e.receiverPublicKey,
  });
}
function Of(s) {
  const e = (s == null ? void 0 : s.type) || Nf;
  if (e === Js) {
    if (typeof (s == null ? void 0 : s.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (s == null ? void 0 : s.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return {
    type: e,
    senderPublicKey: s == null ? void 0 : s.senderPublicKey,
    receiverPublicKey: s == null ? void 0 : s.receiverPublicKey,
  };
}
function Nu(s) {
  return (
    s.type === Js &&
    typeof s.senderPublicKey == "string" &&
    typeof s.receiverPublicKey == "string"
  );
}
function Tu(s) {
  return s.type === xo;
}
function N_(s) {
  const e = Buffer.from(s.x, "base64"),
    t = Buffer.from(s.y, "base64");
  return Mi([new Uint8Array([4]), e, t]);
}
function T_(s, e) {
  const [t, n, r] = s.split("."),
    i = Buffer.from(xf(r), "base64");
  if (i.length !== 64) throw new Error("Invalid signature length");
  const o = i.slice(0, 32),
    a = i.slice(32, 64),
    c = `${t}.${n}`,
    l = Fa(c),
    d = N_(e);
  if (!y_.verify(Mi([o, a]), l, d)) throw new Error("Invalid signature");
  return jc(s).payload;
}
const R_ = "irn";
function ba(s) {
  return (s == null ? void 0 : s.relay) || { protocol: R_ };
}
function ki(s) {
  const e = Yg[s];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${s}`);
  return e;
}
function x_(s, e = "-") {
  const t = {},
    n = "relay" + e;
  return (
    Object.keys(s).forEach((r) => {
      if (r.startsWith(n)) {
        const i = r.replace(n, ""),
          o = s[r];
        t[i] = o;
      }
    }),
    t
  );
}
function Ru(s) {
  if (!s.includes("wc:")) {
    const l = qp(s);
    l != null && l.includes("wc:") && (s = l);
  }
  (s = s.includes("wc://") ? s.replace("wc://", "") : s),
    (s = s.includes("wc:") ? s.replace("wc:", "") : s);
  const e = s.indexOf(":"),
    t = s.indexOf("?") !== -1 ? s.indexOf("?") : void 0,
    n = s.substring(0, e),
    r = s.substring(e + 1, t).split("@"),
    i = typeof t < "u" ? s.substring(t) : "",
    o = new URLSearchParams(i),
    a = {};
  o.forEach((l, d) => {
    a[d] = l;
  });
  const c = typeof a.methods == "string" ? a.methods.split(",") : void 0;
  return {
    protocol: n,
    topic: P_(r[0]),
    version: parseInt(r[1], 10),
    symKey: a.symKey,
    relay: x_(a),
    methods: c,
    expiryTimestamp: a.expiryTimestamp
      ? parseInt(a.expiryTimestamp, 10)
      : void 0,
  };
}
function P_(s) {
  return s.startsWith("//") ? s.substring(2) : s;
}
function O_(s, e = "-") {
  const t = "relay",
    n = {};
  return (
    Object.keys(s).forEach((r) => {
      const i = r,
        o = t + e + i;
      s[i] && (n[o] = s[i]);
    }),
    n
  );
}
function xu(s) {
  const e = new URLSearchParams(),
    t = O_(s.relay);
  Object.keys(t)
    .sort()
    .forEach((r) => {
      e.set(r, t[r]);
    }),
    e.set("symKey", s.symKey),
    s.expiryTimestamp && e.set("expiryTimestamp", s.expiryTimestamp.toString()),
    s.methods && e.set("methods", s.methods.join(","));
  const n = e.toString();
  return `${s.protocol}:${s.topic}@${s.version}?${n}`;
}
function zo(s, e, t) {
  return `${s}?wc_ev=${t}&topic=${e}`;
}
var k_ = Object.defineProperty,
  U_ = Object.defineProperties,
  $_ = Object.getOwnPropertyDescriptors,
  Pu = Object.getOwnPropertySymbols,
  D_ = Object.prototype.hasOwnProperty,
  L_ = Object.prototype.propertyIsEnumerable,
  Ou = (s, e, t) =>
    e in s
      ? k_(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  M_ = (s, e) => {
    for (var t in e || (e = {})) D_.call(e, t) && Ou(s, t, e[t]);
    if (Pu) for (var t of Pu(e)) L_.call(e, t) && Ou(s, t, e[t]);
    return s;
  },
  B_ = (s, e) => U_(s, $_(e));
function li(s) {
  const e = [];
  return (
    s.forEach((t) => {
      const [n, r] = t.split(":");
      e.push(`${n}:${r}`);
    }),
    e
  );
}
function F_(s) {
  const e = [];
  return (
    Object.values(s).forEach((t) => {
      e.push(...li(t.accounts));
    }),
    e
  );
}
function j_(s, e) {
  const t = [];
  return (
    Object.values(s).forEach((n) => {
      li(n.accounts).includes(e) && t.push(...n.methods);
    }),
    t
  );
}
function q_(s, e) {
  const t = [];
  return (
    Object.values(s).forEach((n) => {
      li(n.accounts).includes(e) && t.push(...n.events);
    }),
    t
  );
}
function Wa(s) {
  return s.includes(":");
}
function Lr(s) {
  return Wa(s) ? s.split(":")[0] : s;
}
function ku(s) {
  var e, t, n;
  const r = {};
  if (!vn(s)) return r;
  for (const [i, o] of Object.entries(s)) {
    const a = Wa(i) ? [i] : o.chains,
      c = o.methods || [],
      l = o.events || [],
      d = Lr(i);
    r[d] = B_(M_({}, r[d]), {
      chains: Ds(a, (e = r[d]) == null ? void 0 : e.chains),
      methods: Ds(c, (t = r[d]) == null ? void 0 : t.methods),
      events: Ds(l, (n = r[d]) == null ? void 0 : n.events),
    });
  }
  return r;
}
function H_(s) {
  const e = {};
  return (
    s == null ||
      s.forEach((t) => {
        var n;
        const [r, i] = t.split(":");
        e[r] || (e[r] = { accounts: [], chains: [], events: [], methods: [] }),
          e[r].accounts.push(t),
          (n = e[r].chains) == null || n.push(`${r}:${i}`);
      }),
    e
  );
}
function Uu(s, e) {
  e = e.map((n) => n.replace("did:pkh:", ""));
  const t = H_(e);
  for (const [n, r] of Object.entries(t))
    r.methods ? (r.methods = Ds(r.methods, s)) : (r.methods = s),
      (r.events = ["chainChanged", "accountsChanged"]);
  return t;
}
function W_(s, e) {
  var t, n, r, i, o, a;
  const c = ku(s),
    l = ku(e),
    d = {},
    u = Object.keys(c).concat(Object.keys(l));
  for (const p of u)
    d[p] = {
      chains: Ds(
        (t = c[p]) == null ? void 0 : t.chains,
        (n = l[p]) == null ? void 0 : n.chains
      ),
      methods: Ds(
        (r = c[p]) == null ? void 0 : r.methods,
        (i = l[p]) == null ? void 0 : i.methods
      ),
      events: Ds(
        (o = c[p]) == null ? void 0 : o.events,
        (a = l[p]) == null ? void 0 : a.events
      ),
    };
  return d;
}
const z_ = {
    INVALID_METHOD: { message: "Invalid method.", code: 1001 },
    INVALID_EVENT: { message: "Invalid event.", code: 1002 },
    INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 },
    INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 },
    INVALID_SESSION_SETTLE_REQUEST: {
      message: "Invalid session settle request.",
      code: 1005,
    },
    UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 },
    UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 },
    UNAUTHORIZED_UPDATE_REQUEST: {
      message: "Unauthorized update request.",
      code: 3003,
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
      message: "Unauthorized extend request.",
      code: 3004,
    },
    USER_REJECTED: { message: "User rejected.", code: 5e3 },
    USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 },
    USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 },
    USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 },
    UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 },
    UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 },
    UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 },
    UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 },
    UNSUPPORTED_NAMESPACE_KEY: {
      message: "Unsupported namespace key.",
      code: 5104,
    },
    USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 },
    SESSION_SETTLEMENT_FAILED: {
      message: "Session settlement failed.",
      code: 7e3,
    },
    WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 },
  },
  V_ = {
    NOT_INITIALIZED: { message: "Not initialized.", code: 1 },
    NO_MATCHING_KEY: { message: "No matching key.", code: 2 },
    RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 },
    RESUBSCRIBED: { message: "Resubscribed.", code: 4 },
    MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 },
    EXPIRED: { message: "Expired.", code: 6 },
    UNKNOWN_TYPE: { message: "Unknown type.", code: 7 },
    MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 },
    NON_CONFORMING_NAMESPACES: {
      message: "Non conforming namespaces.",
      code: 9,
    },
  };
function F(s, e) {
  const { message: t, code: n } = V_[s];
  return { message: e ? `${t} ${e}` : t, code: n };
}
function ze(s, e) {
  const { message: t, code: n } = z_[s];
  return { message: e ? `${t} ${e}` : t, code: n };
}
function Xs(s, e) {
  return !!Array.isArray(s);
}
function vn(s) {
  return Object.getPrototypeOf(s) === Object.prototype && Object.keys(s).length;
}
function pt(s) {
  return typeof s > "u";
}
function Xe(s, e) {
  return e && pt(s) ? !0 : typeof s == "string" && !!s.trim().length;
}
function ad(s, e) {
  return e && pt(s) ? !0 : typeof s == "number" && !isNaN(s);
}
function K_(s, e) {
  const { requiredNamespaces: t } = e,
    n = Object.keys(s.namespaces),
    r = Object.keys(t);
  let i = !0;
  return zn(r, n)
    ? (n.forEach((o) => {
        const { accounts: a, methods: c, events: l } = s.namespaces[o],
          d = li(a),
          u = t[o];
        (!zn(Lp(o, u), d) || !zn(u.methods, c) || !zn(u.events, l)) && (i = !1);
      }),
      i)
    : !1;
}
function _a(s) {
  return Xe(s, !1) && s.includes(":") ? s.split(":").length === 2 : !1;
}
function G_(s) {
  if (Xe(s, !1) && s.includes(":")) {
    const e = s.split(":");
    if (e.length === 3) {
      const t = e[0] + ":" + e[1];
      return !!e[2] && _a(t);
    }
  }
  return !1;
}
function Y_(s) {
  function e(t) {
    try {
      return typeof new URL(t) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (Xe(s, !1)) {
      if (e(s)) return !0;
      const t = qp(s);
      return e(t);
    }
  } catch {}
  return !1;
}
function Z_(s) {
  var e;
  return (e = s == null ? void 0 : s.proposer) == null ? void 0 : e.publicKey;
}
function J_(s) {
  return s == null ? void 0 : s.topic;
}
function X_(s, e) {
  let t = null;
  return (
    Xe(s == null ? void 0 : s.publicKey, !1) ||
      (t = F(
        "MISSING_OR_INVALID",
        `${e} controller public key should be a string`
      )),
    t
  );
}
function $u(s) {
  let e = !0;
  return Xs(s) ? s.length && (e = s.every((t) => Xe(t, !1))) : (e = !1), e;
}
function Q_(s, e, t) {
  let n = null;
  return (
    Xs(e) && e.length
      ? e.forEach((r) => {
          n ||
            _a(r) ||
            (n = ze(
              "UNSUPPORTED_CHAINS",
              `${t}, chain ${r} should be a string and conform to "namespace:chainId" format`
            ));
        })
      : _a(s) ||
        (n = ze(
          "UNSUPPORTED_CHAINS",
          `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
        )),
    n
  );
}
function eC(s, e, t) {
  let n = null;
  return (
    Object.entries(s).forEach(([r, i]) => {
      if (n) return;
      const o = Q_(r, Lp(r, i), `${e} ${t}`);
      o && (n = o);
    }),
    n
  );
}
function tC(s, e) {
  let t = null;
  return (
    Xs(s)
      ? s.forEach((n) => {
          t ||
            G_(n) ||
            (t = ze(
              "UNSUPPORTED_ACCOUNTS",
              `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`
            ));
        })
      : (t = ze(
          "UNSUPPORTED_ACCOUNTS",
          `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
        )),
    t
  );
}
function sC(s, e) {
  let t = null;
  return (
    Object.values(s).forEach((n) => {
      if (t) return;
      const r = tC(n == null ? void 0 : n.accounts, `${e} namespace`);
      r && (t = r);
    }),
    t
  );
}
function nC(s, e) {
  let t = null;
  return (
    $u(s == null ? void 0 : s.methods)
      ? $u(s == null ? void 0 : s.events) ||
        (t = ze(
          "UNSUPPORTED_EVENTS",
          `${e}, events should be an array of strings or empty array for no events`
        ))
      : (t = ze(
          "UNSUPPORTED_METHODS",
          `${e}, methods should be an array of strings or empty array for no methods`
        )),
    t
  );
}
function kf(s, e) {
  let t = null;
  return (
    Object.values(s).forEach((n) => {
      if (t) return;
      const r = nC(n, `${e}, namespace`);
      r && (t = r);
    }),
    t
  );
}
function rC(s, e, t) {
  let n = null;
  if (s && vn(s)) {
    const r = kf(s, e);
    r && (n = r);
    const i = eC(s, e, t);
    i && (n = i);
  } else
    n = F("MISSING_OR_INVALID", `${e}, ${t} should be an object with data`);
  return n;
}
function Ec(s, e) {
  let t = null;
  if (s && vn(s)) {
    const n = kf(s, e);
    n && (t = n);
    const r = sC(s, e);
    r && (t = r);
  } else
    t = F(
      "MISSING_OR_INVALID",
      `${e}, namespaces should be an object with data`
    );
  return t;
}
function Uf(s) {
  return Xe(s.protocol, !0);
}
function iC(s, e) {
  let t = !1;
  return (
    s
      ? s &&
        Xs(s) &&
        s.length &&
        s.forEach((n) => {
          t = Uf(n);
        })
      : (t = !0),
    t
  );
}
function oC(s) {
  return typeof s == "number";
}
function Ut(s) {
  return typeof s < "u" && typeof s !== null;
}
function aC(s) {
  return !(
    !s ||
    typeof s != "object" ||
    !s.code ||
    !ad(s.code, !1) ||
    !s.message ||
    !Xe(s.message, !1)
  );
}
function cC(s) {
  return !(pt(s) || !Xe(s.method, !1));
}
function lC(s) {
  return !(
    pt(s) ||
    (pt(s.result) && pt(s.error)) ||
    !ad(s.id, !1) ||
    !Xe(s.jsonrpc, !1)
  );
}
function dC(s) {
  return !(pt(s) || !Xe(s.name, !1));
}
function Du(s, e) {
  return !(!_a(e) || !F_(s).includes(e));
}
function uC(s, e, t) {
  return Xe(t, !1) ? j_(s, e).includes(t) : !1;
}
function hC(s, e, t) {
  return Xe(t, !1) ? q_(s, e).includes(t) : !1;
}
function Lu(s, e, t) {
  let n = null;
  const r = pC(s),
    i = fC(e),
    o = Object.keys(r),
    a = Object.keys(i),
    c = Mu(Object.keys(s)),
    l = Mu(Object.keys(e)),
    d = c.filter((u) => !l.includes(u));
  return (
    d.length &&
      (n = F(
        "NON_CONFORMING_NAMESPACES",
        `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d.toString()}
      Received: ${Object.keys(e).toString()}`
      )),
    zn(o, a) ||
      (n = F(
        "NON_CONFORMING_NAMESPACES",
        `${t} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`
      )),
    Object.keys(e).forEach((u) => {
      if (!u.includes(":") || n) return;
      const p = li(e[u].accounts);
      p.includes(u) ||
        (n = F(
          "NON_CONFORMING_NAMESPACES",
          `${t} namespaces accounts don't satisfy namespace accounts for ${u}
        Required: ${u}
        Approved: ${p.toString()}`
        ));
    }),
    o.forEach((u) => {
      n ||
        (zn(r[u].methods, i[u].methods)
          ? zn(r[u].events, i[u].events) ||
            (n = F(
              "NON_CONFORMING_NAMESPACES",
              `${t} namespaces events don't satisfy namespace events for ${u}`
            ))
          : (n = F(
              "NON_CONFORMING_NAMESPACES",
              `${t} namespaces methods don't satisfy namespace methods for ${u}`
            )));
    }),
    n
  );
}
function pC(s) {
  const e = {};
  return (
    Object.keys(s).forEach((t) => {
      var n;
      t.includes(":")
        ? (e[t] = s[t])
        : (n = s[t].chains) == null ||
          n.forEach((r) => {
            e[r] = { methods: s[t].methods, events: s[t].events };
          });
    }),
    e
  );
}
function Mu(s) {
  return [...new Set(s.map((e) => (e.includes(":") ? e.split(":")[0] : e)))];
}
function fC(s) {
  const e = {};
  return (
    Object.keys(s).forEach((t) => {
      if (t.includes(":")) e[t] = s[t];
      else {
        const n = li(s[t].accounts);
        n == null ||
          n.forEach((r) => {
            e[r] = {
              accounts: s[t].accounts.filter((i) => i.includes(`${r}:`)),
              methods: s[t].methods,
              events: s[t].events,
            };
          });
      }
    }),
    e
  );
}
function gC(s, e) {
  return ad(s, !1) && s <= e.max && s >= e.min;
}
function Bu() {
  const s = No();
  return new Promise((e) => {
    switch (s) {
      case Kt.browser:
        e(mC());
        break;
      case Kt.reactNative:
        e(wC());
        break;
      case Kt.node:
        e(yC());
        break;
      default:
        e(!0);
    }
  });
}
function mC() {
  return oi() && (navigator == null ? void 0 : navigator.onLine);
}
async function wC() {
  if (kn() && typeof global < "u" && global != null && global.NetInfo) {
    const s = await (global == null ? void 0 : global.NetInfo.fetch());
    return s == null ? void 0 : s.isConnected;
  }
  return !0;
}
function yC() {
  return !0;
}
function EC(s) {
  switch (No()) {
    case Kt.browser:
      bC(s);
      break;
    case Kt.reactNative:
      _C(s);
      break;
  }
}
function bC(s) {
  !kn() &&
    oi() &&
    (window.addEventListener("online", () => s(!0)),
    window.addEventListener("offline", () => s(!1)));
}
function _C(s) {
  kn() &&
    typeof global < "u" &&
    global != null &&
    global.NetInfo &&
    (global == null ||
      global.NetInfo.addEventListener((e) =>
        s(e == null ? void 0 : e.isConnected)
      ));
}
function CC() {
  var s;
  return oi() && en.getDocument()
    ? ((s = en.getDocument()) == null ? void 0 : s.visibilityState) ===
        "visible"
    : !0;
}
const bc = {};
class Ei {
  static get(e) {
    return bc[e];
  }
  static set(e, t) {
    bc[e] = t;
  }
  static delete(e) {
    delete bc[e];
  }
}
function vC(s) {
  const e = ei.decode(s);
  if (e.length < 33) throw new Error("Too short to contain a public key");
  return e.slice(1, 33);
}
function AC({ publicKey: s, signature: e, payload: t }) {
  var n;
  const r = ul(t.method),
    i =
      128 | parseInt(((n = t.version) == null ? void 0 : n.toString()) || "4"),
    o = NC(t.address),
    a = t.era === "00" ? new Uint8Array([0]) : ul(t.era);
  if (a.length !== 1 && a.length !== 2) throw new Error("Invalid era length");
  const c = parseInt(t.nonce, 16),
    l = new Uint8Array([c & 255, (c >> 8) & 255]),
    d = BigInt(`0x${SC(t.tip)}`),
    u = RC(d),
    p = new Uint8Array([0, ...s, o, ...e, ...a, ...l, ...u, ...r]),
    w = TC(p.length + 1);
  return new Uint8Array([...w, i, ...p]);
}
function IC(s) {
  const e = ul(s),
    t = mE.blake2b(e, void 0, 32);
  return "0x" + Buffer.from(t).toString("hex");
}
function ul(s) {
  return new Uint8Array(
    s
      .replace(/^0x/, "")
      .match(/.{1,2}/g)
      .map((e) => parseInt(e, 16))
  );
}
function SC(s) {
  return s.startsWith("0x") ? s.slice(2) : s;
}
function NC(s) {
  const e = ei.decode(s)[0];
  return e === 42 ? 0 : e === 60 ? 2 : 1;
}
function TC(s) {
  if (s < 64) return new Uint8Array([s << 2]);
  if (s < 16384) {
    const e = (s << 2) | 1;
    return new Uint8Array([e & 255, (e >> 8) & 255]);
  } else if (s < 1 << 30) {
    const e = (s << 2) | 2;
    return new Uint8Array([
      e & 255,
      (e >> 8) & 255,
      (e >> 16) & 255,
      (e >> 24) & 255,
    ]);
  } else throw new Error("Compact encoding > 2^30 not supported");
}
function RC(s) {
  if (s < BigInt(1) << BigInt(6))
    return new Uint8Array([Number(s << BigInt(2))]);
  if (s < BigInt(1) << BigInt(14)) {
    const e = (s << BigInt(2)) | BigInt(1);
    return new Uint8Array([
      Number(e & BigInt(255)),
      Number((e >> BigInt(8)) & BigInt(255)),
    ]);
  } else if (s < BigInt(1) << BigInt(30)) {
    const e = (s << BigInt(2)) | BigInt(2);
    return new Uint8Array([
      Number(e & BigInt(255)),
      Number((e >> BigInt(8)) & BigInt(255)),
      Number((e >> BigInt(16)) & BigInt(255)),
      Number((e >> BigInt(24)) & BigInt(255)),
    ]);
  } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function xC(s) {
  const e = Uint8Array.from(Buffer.from(s.signature, "hex")),
    t = vC(s.transaction.address),
    n = AC({ publicKey: t, signature: e, payload: s.transaction }),
    r = Buffer.from(n).toString("hex");
  return IC(r);
}
var PC = {};
const $f = "wc",
  Df = 2,
  hl = "core",
  Ms = `${$f}@2:${hl}:`,
  OC = { logger: "error" },
  kC = { database: ":memory:" },
  UC = "crypto",
  Fu = "client_ed25519_seed",
  $C = j.ONE_DAY,
  DC = "keychain",
  LC = "0.3",
  MC = "messages",
  BC = "0.3",
  ju = j.SIX_HOURS,
  FC = "publisher",
  Lf = "irn",
  jC = "error",
  Mf = "wss://relay.walletconnect.org",
  qC = "relayer",
  ot = {
    message: "relayer_message",
    message_ack: "relayer_message_ack",
    connect: "relayer_connect",
    disconnect: "relayer_disconnect",
    error: "relayer_error",
    connection_stalled: "relayer_connection_stalled",
    publish: "relayer_publish",
  },
  HC = "_subscription",
  Qt = {
    payload: "payload",
    connect: "connect",
    disconnect: "disconnect",
    error: "error",
  },
  WC = 0.1,
  pl = "2.21.3",
  We = { link_mode: "link_mode", relay: "relay" },
  ta = { inbound: "inbound", outbound: "outbound" },
  zC = "0.3",
  VC = "WALLETCONNECT_CLIENT_ID",
  qu = "WALLETCONNECT_LINK_MODE_APPS",
  Ht = {
    created: "subscription_created",
    deleted: "subscription_deleted",
    sync: "subscription_sync",
    resubscribed: "subscription_resubscribed",
  },
  KC = "subscription",
  GC = "0.3",
  YC = "pairing",
  ZC = "0.3",
  bi = {
    wc_pairingDelete: {
      req: { ttl: j.ONE_DAY, prompt: !1, tag: 1e3 },
      res: { ttl: j.ONE_DAY, prompt: !1, tag: 1001 },
    },
    wc_pairingPing: {
      req: { ttl: j.THIRTY_SECONDS, prompt: !1, tag: 1002 },
      res: { ttl: j.THIRTY_SECONDS, prompt: !1, tag: 1003 },
    },
    unregistered_method: {
      req: { ttl: j.ONE_DAY, prompt: !1, tag: 0 },
      res: { ttl: j.ONE_DAY, prompt: !1, tag: 0 },
    },
  },
  qn = {
    create: "pairing_create",
    expire: "pairing_expire",
    delete: "pairing_delete",
    ping: "pairing_ping",
  },
  ds = {
    created: "history_created",
    updated: "history_updated",
    deleted: "history_deleted",
    sync: "history_sync",
  },
  JC = "history",
  XC = "0.3",
  QC = "expirer",
  ns = {
    created: "expirer_created",
    deleted: "expirer_deleted",
    expired: "expirer_expired",
    sync: "expirer_sync",
  },
  ev = "0.3",
  tv = "verify-api",
  sv = "https://verify.walletconnect.com",
  Bf = "https://verify.walletconnect.org",
  Hi = Bf,
  nv = `${Hi}/v3`,
  rv = [sv, Bf],
  iv = "echo",
  ov = "https://echo.walletconnect.com",
  Rs = {
    pairing_started: "pairing_started",
    pairing_uri_validation_success: "pairing_uri_validation_success",
    pairing_uri_not_expired: "pairing_uri_not_expired",
    store_new_pairing: "store_new_pairing",
    subscribing_pairing_topic: "subscribing_pairing_topic",
    subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
    existing_pairing: "existing_pairing",
    pairing_not_expired: "pairing_not_expired",
    emit_inactive_pairing: "emit_inactive_pairing",
    emit_session_proposal: "emit_session_proposal",
  },
  Gs = {
    no_internet_connection: "no_internet_connection",
    malformed_pairing_uri: "malformed_pairing_uri",
    active_pairing_already_exists: "active_pairing_already_exists",
    subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
    pairing_expired: "pairing_expired",
    proposal_listener_not_found: "proposal_listener_not_found",
  },
  us = {
    session_approve_started: "session_approve_started",
    session_namespaces_validation_success:
      "session_namespaces_validation_success",
    subscribing_session_topic: "subscribing_session_topic",
    subscribe_session_topic_success: "subscribe_session_topic_success",
    publishing_session_approve: "publishing_session_approve",
    session_approve_publish_success: "session_approve_publish_success",
    store_session: "store_session",
    publishing_session_settle: "publishing_session_settle",
    session_settle_publish_success: "session_settle_publish_success",
  },
  $n = {
    no_internet_connection: "no_internet_connection",
    proposal_expired: "proposal_expired",
    subscribe_session_topic_failure: "subscribe_session_topic_failure",
    session_approve_publish_failure: "session_approve_publish_failure",
    session_settle_publish_failure: "session_settle_publish_failure",
    session_approve_namespace_validation_failure:
      "session_approve_namespace_validation_failure",
    proposal_not_found: "proposal_not_found",
  },
  Dn = {
    authenticated_session_approve_started:
      "authenticated_session_approve_started",
    create_authenticated_session_topic: "create_authenticated_session_topic",
    cacaos_verified: "cacaos_verified",
    store_authenticated_session: "store_authenticated_session",
    subscribing_authenticated_session_topic:
      "subscribing_authenticated_session_topic",
    subscribe_authenticated_session_topic_success:
      "subscribe_authenticated_session_topic_success",
    publishing_authenticated_session_approve:
      "publishing_authenticated_session_approve",
  },
  _i = {
    no_internet_connection: "no_internet_connection",
    invalid_cacao: "invalid_cacao",
    subscribe_authenticated_session_topic_failure:
      "subscribe_authenticated_session_topic_failure",
    authenticated_session_approve_publish_failure:
      "authenticated_session_approve_publish_failure",
    authenticated_session_pending_request_not_found:
      "authenticated_session_pending_request_not_found",
  },
  av = 0.1,
  cv = "event-client",
  lv = 86400,
  dv = "https://pulse.walletconnect.org/batch";
function uv(s, e) {
  if (s.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
  for (var r = 0; r < s.length; r++) {
    var i = s.charAt(r),
      o = i.charCodeAt(0);
    if (t[o] !== 255) throw new TypeError(i + " is ambiguous");
    t[o] = r;
  }
  var a = s.length,
    c = s.charAt(0),
    l = Math.log(a) / Math.log(256),
    d = Math.log(256) / Math.log(a);
  function u(g) {
    if (
      (g instanceof Uint8Array ||
        (ArrayBuffer.isView(g)
          ? (g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength))
          : Array.isArray(g) && (g = Uint8Array.from(g))),
      !(g instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (g.length === 0) return "";
    for (var m = 0, f = 0, E = 0, b = g.length; E !== b && g[E] === 0; )
      E++, m++;
    for (var _ = ((b - E) * d + 1) >>> 0, N = new Uint8Array(_); E !== b; ) {
      for (
        var A = g[E], L = 0, Q = _ - 1;
        (A !== 0 || L < f) && Q !== -1;
        Q--, L++
      )
        (A += (256 * N[Q]) >>> 0), (N[Q] = A % a >>> 0), (A = (A / a) >>> 0);
      if (A !== 0) throw new Error("Non-zero carry");
      (f = L), E++;
    }
    for (var K = _ - f; K !== _ && N[K] === 0; ) K++;
    for (var C = c.repeat(m); K < _; ++K) C += s.charAt(N[K]);
    return C;
  }
  function p(g) {
    if (typeof g != "string") throw new TypeError("Expected String");
    if (g.length === 0) return new Uint8Array();
    var m = 0;
    if (g[m] !== " ") {
      for (var f = 0, E = 0; g[m] === c; ) f++, m++;
      for (
        var b = ((g.length - m) * l + 1) >>> 0, _ = new Uint8Array(b);
        g[m];

      ) {
        var N = t[g.charCodeAt(m)];
        if (N === 255) return;
        for (var A = 0, L = b - 1; (N !== 0 || A < E) && L !== -1; L--, A++)
          (N += (a * _[L]) >>> 0),
            (_[L] = N % 256 >>> 0),
            (N = (N / 256) >>> 0);
        if (N !== 0) throw new Error("Non-zero carry");
        (E = A), m++;
      }
      if (g[m] !== " ") {
        for (var Q = b - E; Q !== b && _[Q] === 0; ) Q++;
        for (var K = new Uint8Array(f + (b - Q)), C = f; Q !== b; )
          K[C++] = _[Q++];
        return K;
      }
    }
  }
  function w(g) {
    var m = p(g);
    if (m) return m;
    throw new Error(`Non-${e} character`);
  }
  return { encode: u, decodeUnsafe: p, decode: w };
}
var hv = uv,
  pv = hv;
const Ff = (s) => {
    if (s instanceof Uint8Array && s.constructor.name === "Uint8Array")
      return s;
    if (s instanceof ArrayBuffer) return new Uint8Array(s);
    if (ArrayBuffer.isView(s))
      return new Uint8Array(s.buffer, s.byteOffset, s.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
  fv = (s) => new TextEncoder().encode(s),
  gv = (s) => new TextDecoder().decode(s);
class mv {
  constructor(e, t, n) {
    (this.name = e), (this.prefix = t), (this.baseEncode = n);
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class wv {
  constructor(e, t, n) {
    if (((this.name = e), (this.prefix = t), t.codePointAt(0) === void 0))
      throw new Error("Invalid prefix character");
    (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = n);
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${
            this.name
          } decoder only supports inputs prefixed with ${this.prefix}`
        );
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return jf(this, e);
  }
}
class yv {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return jf(this, e);
  }
  decode(e) {
    const t = e[0],
      n = this.decoders[t];
    if (n) return n.decode(e);
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(
        e
      )}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    );
  }
}
const jf = (s, e) =>
  new yv({
    ...(s.decoders || { [s.prefix]: s }),
    ...(e.decoders || { [e.prefix]: e }),
  });
class Ev {
  constructor(e, t, n, r) {
    (this.name = e),
      (this.prefix = t),
      (this.baseEncode = n),
      (this.baseDecode = r),
      (this.encoder = new mv(e, t, n)),
      (this.decoder = new wv(e, t, r));
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const za = ({ name: s, prefix: e, encode: t, decode: n }) => new Ev(s, e, t, n),
  Po = ({ prefix: s, name: e, alphabet: t }) => {
    const { encode: n, decode: r } = pv(t, e);
    return za({ prefix: s, name: e, encode: n, decode: (i) => Ff(r(i)) });
  },
  bv = (s, e, t, n) => {
    const r = {};
    for (let d = 0; d < e.length; ++d) r[e[d]] = d;
    let i = s.length;
    for (; s[i - 1] === "="; ) --i;
    const o = new Uint8Array(((i * t) / 8) | 0);
    let a = 0,
      c = 0,
      l = 0;
    for (let d = 0; d < i; ++d) {
      const u = r[s[d]];
      if (u === void 0) throw new SyntaxError(`Non-${n} character`);
      (c = (c << t) | u),
        (a += t),
        a >= 8 && ((a -= 8), (o[l++] = 255 & (c >> a)));
    }
    if (a >= t || 255 & (c << (8 - a)))
      throw new SyntaxError("Unexpected end of data");
    return o;
  },
  _v = (s, e, t) => {
    const n = e[e.length - 1] === "=",
      r = (1 << t) - 1;
    let i = "",
      o = 0,
      a = 0;
    for (let c = 0; c < s.length; ++c)
      for (a = (a << 8) | s[c], o += 8; o > t; )
        (o -= t), (i += e[r & (a >> o)]);
    if ((o && (i += e[r & (a << (t - o))]), n))
      for (; (i.length * t) & 7; ) i += "=";
    return i;
  },
  gt = ({ name: s, prefix: e, bitsPerChar: t, alphabet: n }) =>
    za({
      prefix: e,
      name: s,
      encode(r) {
        return _v(r, n, t);
      },
      decode(r) {
        return bv(r, n, t, s);
      },
    }),
  Cv = za({
    prefix: "\0",
    name: "identity",
    encode: (s) => gv(s),
    decode: (s) => fv(s),
  });
var vv = Object.freeze({ __proto__: null, identity: Cv });
const Av = gt({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Iv = Object.freeze({ __proto__: null, base2: Av });
const Sv = gt({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3,
});
var Nv = Object.freeze({ __proto__: null, base8: Sv });
const Tv = Po({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Rv = Object.freeze({ __proto__: null, base10: Tv });
const xv = gt({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4,
  }),
  Pv = gt({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4,
  });
var Ov = Object.freeze({ __proto__: null, base16: xv, base16upper: Pv });
const kv = gt({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5,
  }),
  Uv = gt({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5,
  }),
  $v = gt({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5,
  }),
  Dv = gt({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5,
  }),
  Lv = gt({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5,
  }),
  Mv = gt({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5,
  }),
  Bv = gt({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5,
  }),
  Fv = gt({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5,
  }),
  jv = gt({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5,
  });
var qv = Object.freeze({
  __proto__: null,
  base32: kv,
  base32upper: Uv,
  base32pad: $v,
  base32padupper: Dv,
  base32hex: Lv,
  base32hexupper: Mv,
  base32hexpad: Bv,
  base32hexpadupper: Fv,
  base32z: jv,
});
const Hv = Po({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
  }),
  Wv = Po({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  });
var zv = Object.freeze({ __proto__: null, base36: Hv, base36upper: Wv });
const Vv = Po({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  }),
  Kv = Po({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  });
var Gv = Object.freeze({ __proto__: null, base58btc: Vv, base58flickr: Kv });
const Yv = gt({
    prefix: "m",
    name: "base64",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6,
  }),
  Zv = gt({
    prefix: "M",
    name: "base64pad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6,
  }),
  Jv = gt({
    prefix: "u",
    name: "base64url",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6,
  }),
  Xv = gt({
    prefix: "U",
    name: "base64urlpad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6,
  });
var Qv = Object.freeze({
  __proto__: null,
  base64: Yv,
  base64pad: Zv,
  base64url: Jv,
  base64urlpad: Xv,
});
const qf = Array.from(
    ""
  ),
  eA = qf.reduce((s, e, t) => ((s[t] = e), s), []),
  tA = qf.reduce((s, e, t) => ((s[e.codePointAt(0)] = t), s), []);
function sA(s) {
  return s.reduce((e, t) => ((e += eA[t]), e), "");
}
function nA(s) {
  const e = [];
  for (const t of s) {
    const n = tA[t.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const rA = za({ prefix: "", name: "base256emoji", encode: sA, decode: nA });
var iA = Object.freeze({ __proto__: null, base256emoji: rA }),
  oA = Hf,
  Hu = 128,
  aA = -128,
  cA = Math.pow(2, 31);
function Hf(s, e, t) {
  (e = e || []), (t = t || 0);
  for (var n = t; s >= cA; ) (e[t++] = (s & 255) | Hu), (s /= 128);
  for (; s & aA; ) (e[t++] = (s & 255) | Hu), (s >>>= 7);
  return (e[t] = s | 0), (Hf.bytes = t - n + 1), e;
}
var lA = fl,
  dA = 128,
  Wu = 127;
function fl(s, n) {
  var t = 0,
    n = n || 0,
    r = 0,
    i = n,
    o,
    a = s.length;
  do {
    if (i >= a)
      throw ((fl.bytes = 0), new RangeError("Could not decode varint"));
    (o = s[i++]),
      (t += r < 28 ? (o & Wu) << r : (o & Wu) * Math.pow(2, r)),
      (r += 7);
  } while (o >= dA);
  return (fl.bytes = i - n), t;
}
var uA = Math.pow(2, 7),
  hA = Math.pow(2, 14),
  pA = Math.pow(2, 21),
  fA = Math.pow(2, 28),
  gA = Math.pow(2, 35),
  mA = Math.pow(2, 42),
  wA = Math.pow(2, 49),
  yA = Math.pow(2, 56),
  EA = Math.pow(2, 63),
  bA = function (s) {
    return s < uA
      ? 1
      : s < hA
      ? 2
      : s < pA
      ? 3
      : s < fA
      ? 4
      : s < gA
      ? 5
      : s < mA
      ? 6
      : s < wA
      ? 7
      : s < yA
      ? 8
      : s < EA
      ? 9
      : 10;
  },
  _A = { encode: oA, decode: lA, encodingLength: bA },
  Wf = _A;
const zu = (s, e, t = 0) => (Wf.encode(s, e, t), e),
  Vu = (s) => Wf.encodingLength(s),
  gl = (s, e) => {
    const t = e.byteLength,
      n = Vu(s),
      r = n + Vu(t),
      i = new Uint8Array(r + t);
    return zu(s, i, 0), zu(t, i, n), i.set(e, r), new CA(s, t, e, i);
  };
class CA {
  constructor(e, t, n, r) {
    (this.code = e), (this.size = t), (this.digest = n), (this.bytes = r);
  }
}
const zf = ({ name: s, code: e, encode: t }) => new vA(s, e, t);
class vA {
  constructor(e, t, n) {
    (this.name = e), (this.code = t), (this.encode = n);
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array
        ? gl(this.code, t)
        : t.then((n) => gl(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
}
const Vf = (s) => async (e) => new Uint8Array(await crypto.subtle.digest(s, e)),
  AA = zf({ name: "sha2-256", code: 18, encode: Vf("SHA-256") }),
  IA = zf({ name: "sha2-512", code: 19, encode: Vf("SHA-512") });
var SA = Object.freeze({ __proto__: null, sha256: AA, sha512: IA });
const Kf = 0,
  NA = "identity",
  Gf = Ff,
  TA = (s) => gl(Kf, Gf(s)),
  RA = { code: Kf, name: NA, encode: Gf, digest: TA };
var xA = Object.freeze({ __proto__: null, identity: RA });
new TextEncoder(), new TextDecoder();
const Ku = {
  ...vv,
  ...Iv,
  ...Nv,
  ...Rv,
  ...Ov,
  ...qv,
  ...zv,
  ...Gv,
  ...Qv,
  ...iA,
};
({ ...SA, ...xA });
function Yf(s) {
  return globalThis.Buffer != null
    ? new Uint8Array(s.buffer, s.byteOffset, s.byteLength)
    : s;
}
function PA(s = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? Yf(globalThis.Buffer.allocUnsafe(s))
    : new Uint8Array(s);
}
function Zf(s, e, t, n) {
  return {
    name: s,
    prefix: e,
    encoder: { name: s, prefix: e, encode: t },
    decoder: { decode: n },
  };
}
const Gu = Zf(
    "utf8",
    "u",
    (s) => "u" + new TextDecoder("utf8").decode(s),
    (s) => new TextEncoder().encode(s.substring(1))
  ),
  _c = Zf(
    "ascii",
    "a",
    (s) => {
      let e = "a";
      for (let t = 0; t < s.length; t++) e += String.fromCharCode(s[t]);
      return e;
    },
    (s) => {
      s = s.substring(1);
      const e = PA(s.length);
      for (let t = 0; t < s.length; t++) e[t] = s.charCodeAt(t);
      return e;
    }
  ),
  OA = {
    utf8: Gu,
    "utf-8": Gu,
    hex: Ku.base16,
    latin1: _c,
    ascii: _c,
    binary: _c,
    ...Ku,
  };
function kA(s, e = "utf8") {
  const t = OA[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? Yf(globalThis.Buffer.from(s, "utf-8"))
    : t.decoder.decode(`${t.prefix}${s}`);
}
var UA = Object.defineProperty,
  $A = (s, e, t) =>
    e in s
      ? UA(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Ns = (s, e, t) => $A(s, typeof e != "symbol" ? e + "" : e, t);
class DA {
  constructor(e, t) {
    (this.core = e),
      (this.logger = t),
      Ns(this, "keychain", new Map()),
      Ns(this, "name", DC),
      Ns(this, "version", LC),
      Ns(this, "initialized", !1),
      Ns(this, "storagePrefix", Ms),
      Ns(this, "init", async () => {
        if (!this.initialized) {
          const n = await this.getKeyChain();
          typeof n < "u" && (this.keychain = n), (this.initialized = !0);
        }
      }),
      Ns(this, "has", (n) => (this.isInitialized(), this.keychain.has(n))),
      Ns(this, "set", async (n, r) => {
        this.isInitialized(), this.keychain.set(n, r), await this.persist();
      }),
      Ns(this, "get", (n) => {
        this.isInitialized();
        const r = this.keychain.get(n);
        if (typeof r > "u") {
          const { message: i } = F("NO_MATCHING_KEY", `${this.name}: ${n}`);
          throw new Error(i);
        }
        return r;
      }),
      Ns(this, "del", async (n) => {
        this.isInitialized(), this.keychain.delete(n), await this.persist();
      }),
      (this.core = e),
      (this.logger = _t(t, this.name));
  }
  get context() {
    return Yt(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Qc(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? el(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var LA = Object.defineProperty,
  MA = (s, e, t) =>
    e in s
      ? LA(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  dt = (s, e, t) => MA(s, typeof e != "symbol" ? e + "" : e, t);
class BA {
  constructor(e, t, n) {
    (this.core = e),
      (this.logger = t),
      dt(this, "name", UC),
      dt(this, "keychain"),
      dt(this, "randomSessionIdentifier", dl()),
      dt(this, "initialized", !1),
      dt(this, "init", async () => {
        this.initialized ||
          (await this.keychain.init(), (this.initialized = !0));
      }),
      dt(this, "hasKeys", (r) => (this.isInitialized(), this.keychain.has(r))),
      dt(this, "getClientId", async () => {
        this.isInitialized();
        const r = await this.getClientSeed(),
          i = yd(r);
        return em(i.publicKey);
      }),
      dt(this, "generateKeyPair", () => {
        this.isInitialized();
        const r = b_();
        return this.setPrivateKey(r.publicKey, r.privateKey);
      }),
      dt(this, "signJWT", async (r) => {
        this.isInitialized();
        const i = await this.getClientSeed(),
          o = yd(i),
          a = this.randomSessionIdentifier;
        return await tm(a, r, $C, o);
      }),
      dt(this, "generateSharedKey", (r, i, o) => {
        this.isInitialized();
        const a = this.getPrivateKey(r),
          c = __(a, i);
        return this.setSymKey(c, o);
      }),
      dt(this, "setSymKey", async (r, i) => {
        this.isInitialized();
        const o = i || ea(r);
        return await this.keychain.set(o, r), o;
      }),
      dt(this, "deleteKeyPair", async (r) => {
        this.isInitialized(), await this.keychain.del(r);
      }),
      dt(this, "deleteSymKey", async (r) => {
        this.isInitialized(), await this.keychain.del(r);
      }),
      dt(this, "encode", async (r, i, o) => {
        this.isInitialized();
        const a = Of(o),
          c = sm(i);
        if (Tu(a)) return A_(c, o == null ? void 0 : o.encoding);
        if (Nu(a)) {
          const p = a.senderPublicKey,
            w = a.receiverPublicKey;
          r = await this.generateSharedKey(p, w);
        }
        const l = this.getSymKey(r),
          { type: d, senderPublicKey: u } = a;
        return C_({
          type: d,
          symKey: l,
          message: c,
          senderPublicKey: u,
          encoding: o == null ? void 0 : o.encoding,
        });
      }),
      dt(this, "decode", async (r, i, o) => {
        this.isInitialized();
        const a = S_(i, o);
        if (Tu(a)) {
          const c = I_(i, o == null ? void 0 : o.encoding);
          return Ed(c);
        }
        if (Nu(a)) {
          const c = a.receiverPublicKey,
            l = a.senderPublicKey;
          r = await this.generateSharedKey(c, l);
        }
        try {
          const c = this.getSymKey(r),
            l = v_({
              symKey: c,
              encoded: i,
              encoding: o == null ? void 0 : o.encoding,
            });
          return Ed(l);
        } catch (c) {
          this.logger.error(
            `Failed to decode message from topic: '${r}', clientId: '${await this.getClientId()}'`
          ),
            this.logger.error(c);
        }
      }),
      dt(this, "getPayloadType", (r, i = ws) => {
        const o = ro({ encoded: r, encoding: i });
        return sr(o.type);
      }),
      dt(this, "getPayloadSenderPublicKey", (r, i = ws) => {
        const o = ro({ encoded: r, encoding: i });
        return o.senderPublicKey ? Ft(o.senderPublicKey, St) : void 0;
      }),
      (this.core = e),
      (this.logger = _t(t, this.name)),
      (this.keychain = n || new DA(this.core, this.logger));
  }
  get context() {
    return Yt(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(Fu);
    } catch {
      (e = dl()), await this.keychain.set(Fu, e);
    }
    return kA(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var FA = Object.defineProperty,
  jA = Object.defineProperties,
  qA = Object.getOwnPropertyDescriptors,
  Yu = Object.getOwnPropertySymbols,
  HA = Object.prototype.hasOwnProperty,
  WA = Object.prototype.propertyIsEnumerable,
  ml = (s, e, t) =>
    e in s
      ? FA(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  zA = (s, e) => {
    for (var t in e || (e = {})) HA.call(e, t) && ml(s, t, e[t]);
    if (Yu) for (var t of Yu(e)) WA.call(e, t) && ml(s, t, e[t]);
    return s;
  },
  VA = (s, e) => jA(s, qA(e)),
  qt = (s, e, t) => ml(s, typeof e != "symbol" ? e + "" : e, t);
class KA extends vw {
  constructor(e, t) {
    super(e, t),
      (this.logger = e),
      (this.core = t),
      qt(this, "messages", new Map()),
      qt(this, "messagesWithoutClientAck", new Map()),
      qt(this, "name", MC),
      qt(this, "version", BC),
      qt(this, "initialized", !1),
      qt(this, "storagePrefix", Ms),
      qt(this, "init", async () => {
        if (!this.initialized) {
          this.logger.trace("Initialized");
          try {
            const n = await this.getRelayerMessages();
            typeof n < "u" && (this.messages = n);
            const r = await this.getRelayerMessagesWithoutClientAck();
            typeof r < "u" && (this.messagesWithoutClientAck = r),
              this.logger.debug(
                `Successfully Restored records for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                size: this.messages.size,
              });
          } catch (n) {
            this.logger.debug(`Failed to Restore records for ${this.name}`),
              this.logger.error(n);
          } finally {
            this.initialized = !0;
          }
        }
      }),
      qt(this, "set", async (n, r, i) => {
        this.isInitialized();
        const o = Os(r);
        let a = this.messages.get(n);
        if ((typeof a > "u" && (a = {}), typeof a[o] < "u")) return o;
        if (((a[o] = r), this.messages.set(n, a), i === ta.inbound)) {
          const c = this.messagesWithoutClientAck.get(n) || {};
          this.messagesWithoutClientAck.set(n, VA(zA({}, c), { [o]: r }));
        }
        return await this.persist(), o;
      }),
      qt(this, "get", (n) => {
        this.isInitialized();
        let r = this.messages.get(n);
        return typeof r > "u" && (r = {}), r;
      }),
      qt(this, "getWithoutAck", (n) => {
        this.isInitialized();
        const r = {};
        for (const i of n) {
          const o = this.messagesWithoutClientAck.get(i) || {};
          r[i] = Object.values(o);
        }
        return r;
      }),
      qt(this, "has", (n, r) => {
        this.isInitialized();
        const i = this.get(n),
          o = Os(r);
        return typeof i[o] < "u";
      }),
      qt(this, "ack", async (n, r) => {
        this.isInitialized();
        const i = this.messagesWithoutClientAck.get(n);
        if (typeof i > "u") return;
        const o = Os(r);
        delete i[o],
          Object.keys(i).length === 0
            ? this.messagesWithoutClientAck.delete(n)
            : this.messagesWithoutClientAck.set(n, i),
          await this.persist();
      }),
      qt(this, "del", async (n) => {
        this.isInitialized(),
          this.messages.delete(n),
          this.messagesWithoutClientAck.delete(n),
          await this.persist();
      }),
      (this.logger = _t(e, this.name)),
      (this.core = t);
  }
  get context() {
    return Yt(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get storageKeyWithoutClientAck() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name +
      "_withoutClientAck"
    );
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Qc(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, Qc(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? el(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? el(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages),
      await this.setRelayerMessagesWithoutClientAck(
        this.messagesWithoutClientAck
      );
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var GA = Object.defineProperty,
  YA = Object.defineProperties,
  ZA = Object.getOwnPropertyDescriptors,
  Zu = Object.getOwnPropertySymbols,
  JA = Object.prototype.hasOwnProperty,
  XA = Object.prototype.propertyIsEnumerable,
  wl = (s, e, t) =>
    e in s
      ? GA(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Vo = (s, e) => {
    for (var t in e || (e = {})) JA.call(e, t) && wl(s, t, e[t]);
    if (Zu) for (var t of Zu(e)) XA.call(e, t) && wl(s, t, e[t]);
    return s;
  },
  Cc = (s, e) => YA(s, ZA(e)),
  hs = (s, e, t) => wl(s, typeof e != "symbol" ? e + "" : e, t);
class QA extends Aw {
  constructor(e, t) {
    super(e, t),
      (this.relayer = e),
      (this.logger = t),
      hs(this, "events", new cr.EventEmitter()),
      hs(this, "name", FC),
      hs(this, "queue", new Map()),
      hs(this, "publishTimeout", j.toMiliseconds(j.ONE_MINUTE)),
      hs(this, "initialPublishTimeout", j.toMiliseconds(j.ONE_SECOND * 15)),
      hs(this, "needsTransportRestart", !1),
      hs(this, "publish", async (n, r, i) => {
        var o;
        this.logger.debug("Publishing Payload"),
          this.logger.trace({
            type: "method",
            method: "publish",
            params: { topic: n, message: r, opts: i },
          });
        const a = (i == null ? void 0 : i.ttl) || ju,
          c = ba(i),
          l = (i == null ? void 0 : i.prompt) || !1,
          d = (i == null ? void 0 : i.tag) || 0,
          u = (i == null ? void 0 : i.id) || Dr().toString(),
          p = {
            topic: n,
            message: r,
            opts: {
              ttl: a,
              relay: c,
              prompt: l,
              tag: d,
              id: u,
              attestation: i == null ? void 0 : i.attestation,
              tvf: i == null ? void 0 : i.tvf,
            },
          },
          w = `Failed to publish payload, please try again. id:${u} tag:${d}`;
        try {
          const g = new Promise(async (m) => {
            const f = ({ id: b }) => {
              p.opts.id === b &&
                (this.removeRequestFromQueue(b),
                this.relayer.events.removeListener(ot.publish, f),
                m(p));
            };
            this.relayer.events.on(ot.publish, f);
            const E = _n(
              new Promise((b, _) => {
                this.rpcPublish({
                  topic: n,
                  message: r,
                  ttl: a,
                  prompt: l,
                  tag: d,
                  id: u,
                  attestation: i == null ? void 0 : i.attestation,
                  tvf: i == null ? void 0 : i.tvf,
                })
                  .then(b)
                  .catch((N) => {
                    this.logger.warn(N, N == null ? void 0 : N.message), _(N);
                  });
              }),
              this.initialPublishTimeout,
              `Failed initial publish, retrying.... id:${u} tag:${d}`
            );
            try {
              await E, this.events.removeListener(ot.publish, f);
            } catch (b) {
              this.queue.set(u, Cc(Vo({}, p), { attempt: 1 })),
                this.logger.warn(b, b == null ? void 0 : b.message);
            }
          });
          this.logger.trace({
            type: "method",
            method: "publish",
            params: { id: u, topic: n, message: r, opts: i },
          }),
            await _n(g, this.publishTimeout, w);
        } catch (g) {
          if (
            (this.logger.debug("Failed to Publish Payload"),
            this.logger.error(g),
            (o = i == null ? void 0 : i.internal) != null &&
              o.throwOnFailedPublish)
          )
            throw g;
        } finally {
          this.queue.delete(u);
        }
      }),
      hs(this, "on", (n, r) => {
        this.events.on(n, r);
      }),
      hs(this, "once", (n, r) => {
        this.events.once(n, r);
      }),
      hs(this, "off", (n, r) => {
        this.events.off(n, r);
      }),
      hs(this, "removeListener", (n, r) => {
        this.events.removeListener(n, r);
      }),
      (this.relayer = e),
      (this.logger = _t(t, this.name)),
      this.registerEventListeners();
  }
  get context() {
    return Yt(this.logger);
  }
  async rpcPublish(e) {
    var t, n, r, i;
    const {
        topic: o,
        message: a,
        ttl: c = ju,
        prompt: l,
        tag: d,
        id: u,
        attestation: p,
        tvf: w,
      } = e,
      g = {
        method: ki(ba().protocol).publish,
        params: Vo(
          { topic: o, message: a, ttl: c, prompt: l, tag: d, attestation: p },
          w
        ),
        id: u,
      };
    pt((t = g.params) == null ? void 0 : t.prompt) &&
      ((n = g.params) == null || delete n.prompt),
      pt((r = g.params) == null ? void 0 : r.tag) &&
        ((i = g.params) == null || delete i.tag),
      this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "message", direction: "outgoing", request: g });
    const m = await this.relayer.request(g);
    return (
      this.relayer.events.emit(ot.publish, e),
      this.logger.debug("Successfully Published Payload"),
      m
    );
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const n = e.attempt + 1;
      this.queue.set(t, Cc(Vo({}, e), { attempt: n }));
      const { topic: r, message: i, opts: o, attestation: a } = e;
      this.logger.warn(
        {},
        `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${n}`
      ),
        await this.rpcPublish(
          Cc(Vo({}, e), {
            topic: r,
            message: i,
            ttl: o.ttl,
            prompt: o.prompt,
            tag: o.tag,
            id: o.id,
            attestation: a,
            tvf: o.tvf,
          })
        ),
        this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(si.pulse, () => {
      if (this.needsTransportRestart) {
        (this.needsTransportRestart = !1),
          this.relayer.events.emit(ot.connection_stalled);
        return;
      }
      this.checkQueue();
    }),
      this.relayer.on(ot.message_ack, (e) => {
        this.removeRequestFromQueue(e.id.toString());
      });
  }
}
var e1 = Object.defineProperty,
  t1 = (s, e, t) =>
    e in s
      ? e1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  yr = (s, e, t) => t1(s, typeof e != "symbol" ? e + "" : e, t);
class s1 {
  constructor() {
    yr(this, "map", new Map()),
      yr(this, "set", (e, t) => {
        const n = this.get(e);
        this.exists(e, t) || this.map.set(e, [...n, t]);
      }),
      yr(this, "get", (e) => this.map.get(e) || []),
      yr(this, "exists", (e, t) => this.get(e).includes(t)),
      yr(this, "delete", (e, t) => {
        if (typeof t > "u") {
          this.map.delete(e);
          return;
        }
        if (!this.map.has(e)) return;
        const n = this.get(e);
        if (!this.exists(e, t)) return;
        const r = n.filter((i) => i !== t);
        if (!r.length) {
          this.map.delete(e);
          return;
        }
        this.map.set(e, r);
      }),
      yr(this, "clear", () => {
        this.map.clear();
      });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var n1 = Object.defineProperty,
  r1 = Object.defineProperties,
  i1 = Object.getOwnPropertyDescriptors,
  Ju = Object.getOwnPropertySymbols,
  o1 = Object.prototype.hasOwnProperty,
  a1 = Object.prototype.propertyIsEnumerable,
  yl = (s, e, t) =>
    e in s
      ? n1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Ci = (s, e) => {
    for (var t in e || (e = {})) o1.call(e, t) && yl(s, t, e[t]);
    if (Ju) for (var t of Ju(e)) a1.call(e, t) && yl(s, t, e[t]);
    return s;
  },
  vc = (s, e) => r1(s, i1(e)),
  Be = (s, e, t) => yl(s, typeof e != "symbol" ? e + "" : e, t);
class c1 extends Nw {
  constructor(e, t) {
    super(e, t),
      (this.relayer = e),
      (this.logger = t),
      Be(this, "subscriptions", new Map()),
      Be(this, "topicMap", new s1()),
      Be(this, "events", new cr.EventEmitter()),
      Be(this, "name", KC),
      Be(this, "version", GC),
      Be(this, "pending", new Map()),
      Be(this, "cached", []),
      Be(this, "initialized", !1),
      Be(this, "storagePrefix", Ms),
      Be(this, "subscribeTimeout", j.toMiliseconds(j.ONE_MINUTE)),
      Be(this, "initialSubscribeTimeout", j.toMiliseconds(j.ONE_SECOND * 15)),
      Be(this, "clientId"),
      Be(this, "batchSubscribeTopicsLimit", 500),
      Be(this, "init", async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          this.registerEventListeners(),
          await this.restore()),
          (this.initialized = !0);
      }),
      Be(this, "subscribe", async (n, r) => {
        this.isInitialized(),
          this.logger.debug("Subscribing Topic"),
          this.logger.trace({
            type: "method",
            method: "subscribe",
            params: { topic: n, opts: r },
          });
        try {
          const i = ba(r),
            o = {
              topic: n,
              relay: i,
              transportType: r == null ? void 0 : r.transportType,
            };
          this.pending.set(n, o);
          const a = await this.rpcSubscribe(n, i, r);
          return (
            typeof a == "string" &&
              (this.onSubscribe(a, o),
              this.logger.debug("Successfully Subscribed Topic"),
              this.logger.trace({
                type: "method",
                method: "subscribe",
                params: { topic: n, opts: r },
              })),
            a
          );
        } catch (i) {
          throw (
            (this.logger.debug("Failed to Subscribe Topic"),
            this.logger.error(i),
            i)
          );
        }
      }),
      Be(this, "unsubscribe", async (n, r) => {
        this.isInitialized(),
          typeof (r == null ? void 0 : r.id) < "u"
            ? await this.unsubscribeById(n, r.id, r)
            : await this.unsubscribeByTopic(n, r);
      }),
      Be(
        this,
        "isSubscribed",
        (n) =>
          new Promise((r) => {
            r(this.topicMap.topics.includes(n));
          })
      ),
      Be(
        this,
        "isKnownTopic",
        (n) =>
          new Promise((r) => {
            r(
              this.topicMap.topics.includes(n) ||
                this.pending.has(n) ||
                this.cached.some((i) => i.topic === n)
            );
          })
      ),
      Be(this, "on", (n, r) => {
        this.events.on(n, r);
      }),
      Be(this, "once", (n, r) => {
        this.events.once(n, r);
      }),
      Be(this, "off", (n, r) => {
        this.events.off(n, r);
      }),
      Be(this, "removeListener", (n, r) => {
        this.events.removeListener(n, r);
      }),
      Be(this, "start", async () => {
        await this.onConnect();
      }),
      Be(this, "stop", async () => {
        await this.onDisconnect();
      }),
      Be(this, "restart", async () => {
        await this.restore(), await this.onRestart();
      }),
      Be(this, "checkPending", async () => {
        if (
          this.pending.size === 0 &&
          (!this.initialized || !this.relayer.connected)
        )
          return;
        const n = [];
        this.pending.forEach((r) => {
          n.push(r);
        }),
          await this.batchSubscribe(n);
      }),
      Be(this, "registerEventListeners", () => {
        this.relayer.core.heartbeat.on(si.pulse, async () => {
          await this.checkPending();
        }),
          this.events.on(Ht.created, async (n) => {
            const r = Ht.created;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, data: n }),
              await this.persist();
          }),
          this.events.on(Ht.deleted, async (n) => {
            const r = Ht.deleted;
            this.logger.info(`Emitting ${r}`),
              this.logger.debug({ type: "event", event: r, data: n }),
              await this.persist();
          });
      }),
      (this.relayer = e),
      (this.logger = _t(t, this.name)),
      (this.clientId = "");
  }
  get context() {
    return Yt(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.relayer.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return (
      this.topicMap.topics.length > 0 ||
      this.pending.size > 0 ||
      this.cached.length > 0 ||
      this.subscriptions.size > 0
    );
  }
  hasSubscription(e, t) {
    let n = !1;
    try {
      n = this.getSubscription(e).topic === t;
    } catch {}
    return n;
  }
  reset() {
    (this.cached = []), (this.initialized = !0);
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values),
      this.subscriptions.clear(),
      this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (r) => await this.unsubscribeById(e, r, t)));
  }
  async unsubscribeById(e, t, n) {
    this.logger.debug("Unsubscribing Topic"),
      this.logger.trace({
        type: "method",
        method: "unsubscribe",
        params: { topic: e, id: t, opts: n },
      });
    try {
      const r = ba(n);
      await this.restartToComplete({ topic: e, id: t, relay: r }),
        await this.rpcUnsubscribe(e, t, r);
      const i = ze("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, i),
        this.logger.debug("Successfully Unsubscribed Topic"),
        this.logger.trace({
          type: "method",
          method: "unsubscribe",
          params: { topic: e, id: t, opts: n },
        });
    } catch (r) {
      throw (
        (this.logger.debug("Failed to Unsubscribe Topic"),
        this.logger.error(r),
        r)
      );
    }
  }
  async rpcSubscribe(e, t, n) {
    var r;
    (!n || (n == null ? void 0 : n.transportType) === We.relay) &&
      (await this.restartToComplete({ topic: e, id: e, relay: t }));
    const i = { method: ki(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: i });
    const o =
      (r = n == null ? void 0 : n.internal) == null
        ? void 0
        : r.throwOnFailedPublish;
    try {
      const a = await this.getSubscriptionId(e);
      if ((n == null ? void 0 : n.transportType) === We.link_mode)
        return (
          setTimeout(() => {
            (this.relayer.connected || this.relayer.connecting) &&
              this.relayer.request(i).catch((d) => this.logger.warn(d));
          }, j.toMiliseconds(j.ONE_SECOND)),
          a
        );
      const c = new Promise(async (d) => {
          const u = (p) => {
            p.topic === e &&
              (this.events.removeListener(Ht.created, u), d(p.id));
          };
          this.events.on(Ht.created, u);
          try {
            const p = await _n(
              new Promise((w, g) => {
                this.relayer
                  .request(i)
                  .catch((m) => {
                    this.logger.warn(m, m == null ? void 0 : m.message), g(m);
                  })
                  .then(w);
              }),
              this.initialSubscribeTimeout,
              `Subscribing to ${e} failed, please try again`
            );
            this.events.removeListener(Ht.created, u), d(p);
          } catch {}
        }),
        l = await _n(
          c,
          this.subscribeTimeout,
          `Subscribing to ${e} failed, please try again`
        );
      if (!l && o)
        throw new Error(`Subscribing to ${e} failed, please try again`);
      return l ? a : null;
    } catch (a) {
      if (
        (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
        this.relayer.events.emit(ot.connection_stalled),
        o)
      )
        throw a;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay,
      n = {
        method: ki(t.protocol).batchSubscribe,
        params: { topics: e.map((r) => r.topic) },
      };
    this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      await await _n(
        new Promise((r) => {
          this.relayer
            .request(n)
            .catch((i) => this.logger.warn(i))
            .then(r);
        }),
        this.subscribeTimeout,
        "rpcBatchSubscribe failed, please try again"
      );
    } catch {
      this.relayer.events.emit(ot.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay,
      n = {
        method: ki(t.protocol).batchFetchMessages,
        params: { topics: e.map((i) => i.topic) },
      };
    this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    let r;
    try {
      r = await await _n(
        new Promise((i, o) => {
          this.relayer
            .request(n)
            .catch((a) => {
              this.logger.warn(a), o(a);
            })
            .then(i);
        }),
        this.subscribeTimeout,
        "rpcBatchFetchMessages failed, please try again"
      );
    } catch {
      this.relayer.events.emit(ot.connection_stalled);
    }
    return r;
  }
  rpcUnsubscribe(e, t, n) {
    const r = {
      method: ki(n.protocol).unsubscribe,
      params: { topic: e, id: t },
    };
    return (
      this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: r }),
      this.relayer.request(r)
    );
  }
  onSubscribe(e, t) {
    this.setSubscription(e, vc(Ci({}, t), { id: e })),
      this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length &&
      e.forEach((t) => {
        this.setSubscription(t.id, Ci({}, t)), this.pending.delete(t.topic);
      });
  }
  async onUnsubscribe(e, t, n) {
    this.events.removeAllListeners(t),
      this.hasSubscription(t, e) && this.deleteSubscription(t, n),
      await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"),
      this.logger.trace({
        type: "method",
        method: "setSubscription",
        id: e,
        subscription: t,
      }),
      this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, Ci({}, t)),
      this.topicMap.set(t.topic, e),
      this.events.emit(Ht.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"),
      this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: n } = F("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"),
      this.logger.trace({
        type: "method",
        method: "deleteSubscription",
        id: e,
        reason: t,
      });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e),
      this.topicMap.delete(n.topic, e),
      this.events.emit(Ht.deleted, vc(Ci({}, n), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Ht.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached],
        t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let n = 0; n < t; n++) {
        const r = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(r);
      }
    }
    this.events.emit(Ht.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = F("RESTORE_WILL_OVERRIDE", this.name);
        throw (
          (this.logger.error(t),
          this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
          new Error(t))
        );
      }
      (this.cached = e),
        this.logger.debug(
          `Successfully Restored subscriptions for ${this.name}`
        ),
        this.logger.trace({
          type: "method",
          method: "restore",
          subscriptions: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),
        this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length &&
      (await this.rpcBatchSubscribe(e),
      this.onBatchSubscribe(
        await Promise.all(
          e.map(async (t) =>
            vc(Ci({}, t), { id: await this.getSubscriptionId(t.topic) })
          )
        )
      ));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t &&
      t.messages &&
      (await HE(j.toMiliseconds(j.ONE_SECOND)),
      await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected &&
      !this.relayer.connecting &&
      (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return (
      this.clientId ||
        (this.clientId = await this.relayer.core.crypto.getClientId()),
      this.clientId
    );
  }
  async getSubscriptionId(e) {
    return Os(e + (await this.getClientId()));
  }
}
var l1 = Object.defineProperty,
  Xu = Object.getOwnPropertySymbols,
  d1 = Object.prototype.hasOwnProperty,
  u1 = Object.prototype.propertyIsEnumerable,
  El = (s, e, t) =>
    e in s
      ? l1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Qu = (s, e) => {
    for (var t in e || (e = {})) d1.call(e, t) && El(s, t, e[t]);
    if (Xu) for (var t of Xu(e)) u1.call(e, t) && El(s, t, e[t]);
    return s;
  },
  Se = (s, e, t) => El(s, typeof e != "symbol" ? e + "" : e, t);
class h1 extends Iw {
  constructor(e) {
    super(e),
      Se(this, "protocol", "wc"),
      Se(this, "version", 2),
      Se(this, "core"),
      Se(this, "logger"),
      Se(this, "events", new cr.EventEmitter()),
      Se(this, "provider"),
      Se(this, "messages"),
      Se(this, "subscriber"),
      Se(this, "publisher"),
      Se(this, "name", qC),
      Se(this, "transportExplicitlyClosed", !1),
      Se(this, "initialized", !1),
      Se(this, "connectionAttemptInProgress", !1),
      Se(this, "relayUrl"),
      Se(this, "projectId"),
      Se(this, "packageName"),
      Se(this, "bundleId"),
      Se(this, "hasExperiencedNetworkDisruption", !1),
      Se(this, "pingTimeout"),
      Se(
        this,
        "heartBeatTimeout",
        j.toMiliseconds(j.THIRTY_SECONDS + j.FIVE_SECONDS)
      ),
      Se(this, "reconnectTimeout"),
      Se(this, "connectPromise"),
      Se(this, "reconnectInProgress", !1),
      Se(this, "requestsInFlight", []),
      Se(this, "connectTimeout", j.toMiliseconds(j.ONE_SECOND * 15)),
      Se(this, "request", async (t) => {
        var n, r;
        this.logger.debug("Publishing Request Payload");
        const i = t.id || Dr().toString();
        await this.toEstablishConnection();
        try {
          this.logger.trace(
            {
              id: i,
              method: t.method,
              topic: (n = t.params) == null ? void 0 : n.topic,
            },
            "relayer.request - publishing..."
          );
          const o = `${i}:${((r = t.params) == null ? void 0 : r.tag) || ""}`;
          this.requestsInFlight.push(o);
          const a = await this.provider.request(t);
          return (
            (this.requestsInFlight = this.requestsInFlight.filter(
              (c) => c !== o
            )),
            a
          );
        } catch (o) {
          throw (this.logger.debug(`Failed to Publish Request: ${i}`), o);
        }
      }),
      Se(this, "resetPingTimeout", () => {
        ma() &&
          (clearTimeout(this.pingTimeout),
          (this.pingTimeout = setTimeout(() => {
            var t, n, r, i;
            try {
              this.logger.debug(
                {},
                "pingTimeout: Connection stalled, terminating..."
              ),
                (i =
                  (r =
                    (n = (t = this.provider) == null ? void 0 : t.connection) ==
                    null
                      ? void 0
                      : n.socket) == null
                    ? void 0
                    : r.terminate) == null || i.call(r);
            } catch (o) {
              this.logger.warn(o, o == null ? void 0 : o.message);
            }
          }, this.heartBeatTimeout)));
      }),
      Se(this, "onPayloadHandler", (t) => {
        this.onProviderPayload(t), this.resetPingTimeout();
      }),
      Se(this, "onConnectHandler", () => {
        this.logger.warn({}, "Relayer connected "),
          this.startPingTimeout(),
          this.events.emit(ot.connect);
      }),
      Se(this, "onDisconnectHandler", () => {
        this.logger.warn({}, "Relayer disconnected "),
          (this.requestsInFlight = []),
          this.onProviderDisconnect();
      }),
      Se(this, "onProviderErrorHandler", (t) => {
        this.logger.fatal(`Fatal socket error: ${t.message}`),
          this.events.emit(ot.error, t),
          this.logger.fatal("Fatal socket error received, closing transport"),
          this.transportClose();
      }),
      Se(this, "registerProviderListeners", () => {
        this.provider.on(Qt.payload, this.onPayloadHandler),
          this.provider.on(Qt.connect, this.onConnectHandler),
          this.provider.on(Qt.disconnect, this.onDisconnectHandler),
          this.provider.on(Qt.error, this.onProviderErrorHandler);
      }),
      (this.core = e.core),
      (this.logger =
        typeof e.logger < "u" && typeof e.logger != "string"
          ? _t(e.logger, this.name)
          : Dl(ti({ level: e.logger || jC }))),
      (this.messages = new KA(this.logger, e.core)),
      (this.subscriber = new c1(this, this.logger)),
      (this.publisher = new QA(this, this.logger)),
      (this.relayUrl = (e == null ? void 0 : e.relayUrl) || Mf),
      (this.projectId = e.projectId),
      NE() ? (this.packageName = Yd()) : TE() && (this.bundleId = Yd()),
      (this.provider = {});
  }
  async init() {
    this.logger.trace("Initialized"),
      this.registerEventListeners(),
      await Promise.all([this.messages.init(), this.subscriber.init()]),
      (this.initialized = !0),
      this.transportOpen().catch((e) =>
        this.logger.warn(e, e == null ? void 0 : e.message)
      );
  }
  get context() {
    return Yt(this.logger);
  }
  get connected() {
    var e, t, n;
    return (
      ((n =
        (t = (e = this.provider) == null ? void 0 : e.connection) == null
          ? void 0
          : t.socket) == null
        ? void 0
        : n.readyState) === 1 || !1
    );
  }
  get connecting() {
    var e, t, n;
    return (
      ((n =
        (t = (e = this.provider) == null ? void 0 : e.connection) == null
          ? void 0
          : t.socket) == null
        ? void 0
        : n.readyState) === 0 ||
      this.connectPromise !== void 0 ||
      !1
    );
  }
  async publish(e, t, n) {
    this.isInitialized(),
      await this.publisher.publish(e, t, n),
      await this.recordMessageEvent(
        {
          topic: e,
          message: t,
          publishedAt: Date.now(),
          transportType: We.relay,
        },
        ta.outbound
      );
  }
  async subscribe(e, t) {
    var n, r, i;
    this.isInitialized(),
      (!(t != null && t.transportType) ||
        (t == null ? void 0 : t.transportType) === "relay") &&
        (await this.toEstablishConnection());
    const o =
      typeof ((n = t == null ? void 0 : t.internal) == null
        ? void 0
        : n.throwOnFailedPublish) > "u"
        ? !0
        : (r = t == null ? void 0 : t.internal) == null
        ? void 0
        : r.throwOnFailedPublish;
    let a =
        ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || "",
      c;
    const l = (d) => {
      d.topic === e && (this.subscriber.off(Ht.created, l), c());
    };
    return (
      await Promise.all([
        new Promise((d) => {
          (c = d), this.subscriber.on(Ht.created, l);
        }),
        new Promise(async (d, u) => {
          (a =
            (await this.subscriber
              .subscribe(e, Qu({ internal: { throwOnFailedPublish: o } }, t))
              .catch((p) => {
                o && u(p);
              })) || a),
            d();
        }),
      ]),
      a
    );
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect &&
    (this.hasExperiencedNetworkDisruption || this.connected)
      ? await _n(
          this.provider.disconnect(),
          2e3,
          "provider.disconnect()"
        ).catch(() => this.onProviderDisconnect())
      : this.onProviderDisconnect();
  }
  async transportClose() {
    (this.transportExplicitlyClosed = !0), await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn(
        "Starting WS connection skipped because the client has no topics to work with."
      );
      return;
    }
    if (
      (this.connectPromise
        ? (this.logger.debug(
            {},
            "Waiting for existing connection attempt to resolve..."
          ),
          await this.connectPromise,
          this.logger.debug({}, "Existing connection attempt resolved"))
        : ((this.connectPromise = new Promise(async (t, n) => {
            await this.connect(e)
              .then(t)
              .catch(n)
              .finally(() => {
                this.connectPromise = void 0;
              });
          })),
          await this.connectPromise),
      !this.connected)
    )
      throw new Error(
        `Couldn't establish socket connection to the relay server: ${this.relayUrl}`
      );
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."),
      !this.connectionAttemptInProgress &&
        ((this.relayUrl = e || this.relayUrl),
        await this.confirmOnlineStateOrThrow(),
        await this.transportClose(),
        await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!(await Bu()))
      throw new Error(
        "No internet connection detected. Please restart your network and try again."
      );
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((n, r) => n.publishedAt - r.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const n of t)
      try {
        await this.onMessageEvent(n);
      } catch (r) {
        this.logger.warn(
          r,
          "Error while processing batch message event: " +
            (r == null ? void 0 : r.message)
        );
      }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: n } = e;
    if (!t.sessionExists) {
      const r = st(j.FIVE_MINUTES),
        i = { topic: n, expiry: r, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(n, i);
    }
    this.events.emit(ot.message, e),
      await this.recordMessageEvent(e, ta.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(),
      e &&
        e !== this.relayUrl &&
        ((this.relayUrl = e), await this.transportDisconnect()),
      (this.connectionAttemptInProgress = !0),
      (this.transportExplicitlyClosed = !1);
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug(
          {},
          `Connecting to ${this.relayUrl}, attempt: ${t}...`
        ),
          await this.createProvider(),
          await new Promise(async (n, r) => {
            const i = () => {
              r(new Error("Connection interrupted while trying to connect"));
            };
            this.provider.once(Qt.disconnect, i),
              await _n(
                new Promise((o, a) => {
                  this.provider.connect().then(o).catch(a);
                }),
                this.connectTimeout,
                `Socket stalled when trying to connect to ${this.relayUrl}`
              )
                .catch((o) => {
                  r(o);
                })
                .finally(() => {
                  this.provider.off(Qt.disconnect, i),
                    clearTimeout(this.reconnectTimeout);
                }),
              await new Promise(async (o, a) => {
                const c = () => {
                  r(
                    new Error(
                      "Connection interrupted while trying to subscribe"
                    )
                  );
                };
                this.provider.once(Qt.disconnect, c),
                  await this.subscriber
                    .start()
                    .then(o)
                    .catch(a)
                    .finally(() => {
                      this.provider.off(Qt.disconnect, c);
                    });
              }),
              (this.hasExperiencedNetworkDisruption = !1),
              n();
          });
      } catch (n) {
        await this.subscriber.stop();
        const r = n;
        this.logger.warn({}, r.message),
          (this.hasExperiencedNetworkDisruption = !0);
      } finally {
        this.connectionAttemptInProgress = !1;
      }
      if (this.connected) {
        this.logger.debug(
          {},
          `Connected to ${this.relayUrl} successfully on attempt: ${t}`
        );
        break;
      }
      await new Promise((n) => setTimeout(n, j.toMiliseconds(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, n, r, i;
    if (ma())
      try {
        (t = (e = this.provider) == null ? void 0 : e.connection) != null &&
          t.socket &&
          ((i =
            (r = (n = this.provider) == null ? void 0 : n.connection) == null
              ? void 0
              : r.socket) == null ||
            i.on("ping", () => {
              this.resetPingTimeout();
            })),
          this.resetPingTimeout();
      } catch (o) {
        this.logger.warn(o, o == null ? void 0 : o.message);
      }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    (this.provider = new cs(
      new Qg(
        kE({
          sdkVersion: pl,
          protocol: this.protocol,
          version: this.version,
          relayUrl: this.relayUrl,
          projectId: this.projectId,
          auth: e,
          useOnCloseEvent: !0,
          bundleId: this.bundleId,
          packageName: this.packageName,
        })
      )
    )),
      this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: n, message: r } = e;
    await this.messages.set(n, r, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: n } = e;
    if (!n || n.length === 0)
      return this.logger.warn(`Ignoring invalid/empty message: ${n}`), !0;
    if (!(await this.subscriber.isKnownTopic(t)))
      return this.logger.warn(`Ignoring message for unknown topic ${t}`), !0;
    const r = this.messages.has(t, n);
    return r && this.logger.warn(`Ignoring duplicate message: ${n}`), r;
  }
  async onProviderPayload(e) {
    if (
      (this.logger.debug("Incoming Relay Payload"),
      this.logger.trace({ type: "payload", direction: "incoming", payload: e }),
      Ll(e))
    ) {
      if (!e.method.endsWith(HC)) return;
      const t = e.params,
        { topic: n, message: r, publishedAt: i, attestation: o } = t.data,
        a = {
          topic: n,
          message: r,
          publishedAt: i,
          transportType: We.relay,
          attestation: o,
        };
      this.logger.debug("Emitting Relayer Payload"),
        this.logger.trace(Qu({ type: "event", event: t.id }, a)),
        this.events.emit(t.id, a),
        await this.acknowledgePayload(e),
        await this.onMessageEvent(a);
    } else Ml(e) && this.events.emit(ot.message_ack, e);
  }
  async onMessageEvent(e) {
    (await this.shouldIgnoreMessageEvent(e)) ||
      (await this.recordMessageEvent(e, ta.inbound),
      this.events.emit(ot.message, e));
  }
  async acknowledgePayload(e) {
    const t = $a(e.id, !0);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(Qt.payload, this.onPayloadHandler),
      this.provider.off(Qt.connect, this.onConnectHandler),
      this.provider.off(Qt.disconnect, this.onDisconnectHandler),
      this.provider.off(Qt.error, this.onProviderErrorHandler),
      clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Bu();
    EC(async (t) => {
      e !== t &&
        ((e = t),
        t
          ? await this.transportOpen().catch((n) =>
              this.logger.error(n, n == null ? void 0 : n.message)
            )
          : ((this.hasExperiencedNetworkDisruption = !0),
            await this.transportDisconnect(),
            (this.transportExplicitlyClosed = !1)));
    }),
      this.core.heartbeat.on(si.pulse, async () => {
        if (!this.transportExplicitlyClosed && !this.connected && CC())
          try {
            await this.confirmOnlineStateOrThrow(), await this.transportOpen();
          } catch (t) {
            this.logger.warn(t, t == null ? void 0 : t.message);
          }
      });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout),
      this.events.emit(ot.disconnect),
      (this.connectionAttemptInProgress = !1),
      !this.reconnectInProgress &&
        ((this.reconnectInProgress = !0),
        await this.subscriber.stop(),
        this.subscriber.hasAnyTopics &&
          (this.transportExplicitlyClosed ||
            (this.reconnectTimeout = setTimeout(async () => {
              await this.transportOpen().catch((e) =>
                this.logger.error(e, e == null ? void 0 : e.message)
              ),
                (this.reconnectTimeout = void 0),
                (this.reconnectInProgress = !1);
            }, j.toMiliseconds(WC)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if ((await this.confirmOnlineStateOrThrow(), !this.connected)) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
}
function p1(s, e) {
  return s === e || (Number.isNaN(s) && Number.isNaN(e));
}
function eh(s) {
  return Object.getOwnPropertySymbols(s).filter((e) =>
    Object.prototype.propertyIsEnumerable.call(s, e)
  );
}
function th(s) {
  return s == null
    ? s === void 0
      ? "[object Undefined]"
      : "[object Null]"
    : Object.prototype.toString.call(s);
}
const f1 = "[object RegExp]",
  g1 = "[object String]",
  m1 = "[object Number]",
  w1 = "[object Boolean]",
  sh = "[object Arguments]",
  y1 = "[object Symbol]",
  E1 = "[object Date]",
  b1 = "[object Map]",
  _1 = "[object Set]",
  C1 = "[object Array]",
  v1 = "[object Function]",
  A1 = "[object ArrayBuffer]",
  Ac = "[object Object]",
  I1 = "[object Error]",
  S1 = "[object DataView]",
  N1 = "[object Uint8Array]",
  T1 = "[object Uint8ClampedArray]",
  R1 = "[object Uint16Array]",
  x1 = "[object Uint32Array]",
  P1 = "[object BigUint64Array]",
  O1 = "[object Int8Array]",
  k1 = "[object Int16Array]",
  U1 = "[object Int32Array]",
  $1 = "[object BigInt64Array]",
  D1 = "[object Float32Array]",
  L1 = "[object Float64Array]";
function M1() {}
function nh(s) {
  if (!s || typeof s != "object") return !1;
  const e = Object.getPrototypeOf(s);
  return e === null ||
    e === Object.prototype ||
    Object.getPrototypeOf(e) === null
    ? Object.prototype.toString.call(s) === "[object Object]"
    : !1;
}
function B1(s, e, t) {
  return Ui(s, e, void 0, void 0, void 0, void 0, t);
}
function Ui(s, e, t, n, r, i, o) {
  const a = o(s, e, t, n, r, i);
  if (a !== void 0) return a;
  if (typeof s == typeof e)
    switch (typeof s) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return s === e;
      case "number":
        return s === e || Object.is(s, e);
      case "function":
        return s === e;
      case "object":
        return Wi(s, e, i, o);
    }
  return Wi(s, e, i, o);
}
function Wi(s, e, t, n) {
  if (Object.is(s, e)) return !0;
  let r = th(s),
    i = th(e);
  if ((r === sh && (r = Ac), i === sh && (i = Ac), r !== i)) return !1;
  switch (r) {
    case g1:
      return s.toString() === e.toString();
    case m1: {
      const c = s.valueOf(),
        l = e.valueOf();
      return p1(c, l);
    }
    case w1:
    case E1:
    case y1:
      return Object.is(s.valueOf(), e.valueOf());
    case f1:
      return s.source === e.source && s.flags === e.flags;
    case v1:
      return s === e;
  }
  t = t ?? new Map();
  const o = t.get(s),
    a = t.get(e);
  if (o != null && a != null) return o === e;
  t.set(s, e), t.set(e, s);
  try {
    switch (r) {
      case b1: {
        if (s.size !== e.size) return !1;
        for (const [c, l] of s.entries())
          if (!e.has(c) || !Ui(l, e.get(c), c, s, e, t, n)) return !1;
        return !0;
      }
      case _1: {
        if (s.size !== e.size) return !1;
        const c = Array.from(s.values()),
          l = Array.from(e.values());
        for (let d = 0; d < c.length; d++) {
          const u = c[d],
            p = l.findIndex((w) => Ui(u, w, void 0, s, e, t, n));
          if (p === -1) return !1;
          l.splice(p, 1);
        }
        return !0;
      }
      case C1:
      case N1:
      case T1:
      case R1:
      case x1:
      case P1:
      case O1:
      case k1:
      case U1:
      case $1:
      case D1:
      case L1: {
        if (
          (typeof Buffer < "u" && Buffer.isBuffer(s) !== Buffer.isBuffer(e)) ||
          s.length !== e.length
        )
          return !1;
        for (let c = 0; c < s.length; c++)
          if (!Ui(s[c], e[c], c, s, e, t, n)) return !1;
        return !0;
      }
      case A1:
        return s.byteLength !== e.byteLength
          ? !1
          : Wi(new Uint8Array(s), new Uint8Array(e), t, n);
      case S1:
        return s.byteLength !== e.byteLength || s.byteOffset !== e.byteOffset
          ? !1
          : Wi(new Uint8Array(s), new Uint8Array(e), t, n);
      case I1:
        return s.name === e.name && s.message === e.message;
      case Ac: {
        if (!(Wi(s.constructor, e.constructor, t, n) || (nh(s) && nh(e))))
          return !1;
        const c = [...Object.keys(s), ...eh(s)],
          l = [...Object.keys(e), ...eh(e)];
        if (c.length !== l.length) return !1;
        for (let d = 0; d < c.length; d++) {
          const u = c[d],
            p = s[u];
          if (!Object.hasOwn(e, u)) return !1;
          const w = e[u];
          if (!Ui(p, w, u, s, e, t, n)) return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    t.delete(s), t.delete(e);
  }
}
function F1(s, e) {
  return B1(s, e, M1);
}
var j1 = Object.defineProperty,
  rh = Object.getOwnPropertySymbols,
  q1 = Object.prototype.hasOwnProperty,
  H1 = Object.prototype.propertyIsEnumerable,
  bl = (s, e, t) =>
    e in s
      ? j1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  ih = (s, e) => {
    for (var t in e || (e = {})) q1.call(e, t) && bl(s, t, e[t]);
    if (rh) for (var t of rh(e)) H1.call(e, t) && bl(s, t, e[t]);
    return s;
  },
  Pt = (s, e, t) => bl(s, typeof e != "symbol" ? e + "" : e, t);
class hr extends Sw {
  constructor(e, t, n, r = Ms, i = void 0) {
    super(e, t, n, r),
      (this.core = e),
      (this.logger = t),
      (this.name = n),
      Pt(this, "map", new Map()),
      Pt(this, "version", zC),
      Pt(this, "cached", []),
      Pt(this, "initialized", !1),
      Pt(this, "getKey"),
      Pt(this, "storagePrefix", Ms),
      Pt(this, "recentlyDeleted", []),
      Pt(this, "recentlyDeletedLimit", 200),
      Pt(this, "init", async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          await this.restore(),
          this.cached.forEach((o) => {
            this.getKey && o !== null && !pt(o)
              ? this.map.set(this.getKey(o), o)
              : Z_(o)
              ? this.map.set(o.id, o)
              : J_(o) && this.map.set(o.topic, o);
          }),
          (this.cached = []),
          (this.initialized = !0));
      }),
      Pt(this, "set", async (o, a) => {
        this.isInitialized(),
          this.map.has(o)
            ? await this.update(o, a)
            : (this.logger.debug("Setting value"),
              this.logger.trace({
                type: "method",
                method: "set",
                key: o,
                value: a,
              }),
              this.map.set(o, a),
              await this.persist());
      }),
      Pt(
        this,
        "get",
        (o) => (
          this.isInitialized(),
          this.logger.debug("Getting value"),
          this.logger.trace({ type: "method", method: "get", key: o }),
          this.getData(o)
        )
      ),
      Pt(
        this,
        "getAll",
        (o) => (
          this.isInitialized(),
          o
            ? this.values.filter((a) =>
                Object.keys(o).every((c) => F1(a[c], o[c]))
              )
            : this.values
        )
      ),
      Pt(this, "update", async (o, a) => {
        this.isInitialized(),
          this.logger.debug("Updating value"),
          this.logger.trace({
            type: "method",
            method: "update",
            key: o,
            update: a,
          });
        const c = ih(ih({}, this.getData(o)), a);
        this.map.set(o, c), await this.persist();
      }),
      Pt(this, "delete", async (o, a) => {
        this.isInitialized(),
          this.map.has(o) &&
            (this.logger.debug("Deleting value"),
            this.logger.trace({
              type: "method",
              method: "delete",
              key: o,
              reason: a,
            }),
            this.map.delete(o),
            this.addToRecentlyDeleted(o),
            await this.persist());
      }),
      (this.logger = _t(t, this.name)),
      (this.storagePrefix = r),
      (this.getKey = i);
  }
  get context() {
    return Yt(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e),
      this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
        this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: r } = F(
          "MISSING_OR_INVALID",
          `Record was recently deleted - ${this.name}: ${e}`
        );
        throw (this.logger.error(r), new Error(r));
      }
      const { message: n } = F("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw (this.logger.error(n), new Error(n));
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = F("RESTORE_WILL_OVERRIDE", this.name);
        throw (this.logger.error(t), new Error(t));
      }
      (this.cached = e),
        this.logger.debug(`Successfully Restored value for ${this.name}`),
        this.logger.trace({
          type: "method",
          method: "restore",
          value: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`),
        this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var W1 = Object.defineProperty,
  z1 = (s, e, t) =>
    e in s
      ? W1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  be = (s, e, t) => z1(s, typeof e != "symbol" ? e + "" : e, t);
class V1 {
  constructor(e, t) {
    (this.core = e),
      (this.logger = t),
      be(this, "name", YC),
      be(this, "version", ZC),
      be(this, "events", new Bl()),
      be(this, "pairings"),
      be(this, "initialized", !1),
      be(this, "storagePrefix", Ms),
      be(this, "ignoredPayloadTypes", [Js]),
      be(this, "registeredMethods", []),
      be(this, "init", async () => {
        this.initialized ||
          (await this.pairings.init(),
          await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          (this.initialized = !0),
          this.logger.trace("Initialized"));
      }),
      be(this, "register", ({ methods: n }) => {
        this.isInitialized(),
          (this.registeredMethods = [
            ...new Set([...this.registeredMethods, ...n]),
          ]);
      }),
      be(this, "create", async (n) => {
        this.isInitialized();
        const r = dl(),
          i = await this.core.crypto.setSymKey(r),
          o = st(j.FIVE_MINUTES),
          a = { protocol: Lf },
          c = {
            topic: i,
            expiry: o,
            relay: a,
            active: !1,
            methods: n == null ? void 0 : n.methods,
          },
          l = xu({
            protocol: this.core.protocol,
            version: this.core.version,
            topic: i,
            symKey: r,
            relay: a,
            expiryTimestamp: o,
            methods: n == null ? void 0 : n.methods,
          });
        return (
          this.events.emit(qn.create, c),
          this.core.expirer.set(i, o),
          await this.pairings.set(i, c),
          await this.core.relayer.subscribe(i, {
            transportType: n == null ? void 0 : n.transportType,
          }),
          { topic: i, uri: l }
        );
      }),
      be(this, "pair", async (n) => {
        this.isInitialized();
        const r = this.core.eventClient.createEvent({
          properties: {
            topic: n == null ? void 0 : n.uri,
            trace: [Rs.pairing_started],
          },
        });
        this.isValidPair(n, r);
        const {
          topic: i,
          symKey: o,
          relay: a,
          expiryTimestamp: c,
          methods: l,
        } = Ru(n.uri);
        (r.props.properties.topic = i),
          r.addTrace(Rs.pairing_uri_validation_success),
          r.addTrace(Rs.pairing_uri_not_expired);
        let d;
        if (this.pairings.keys.includes(i)) {
          if (
            ((d = this.pairings.get(i)),
            r.addTrace(Rs.existing_pairing),
            d.active)
          )
            throw (
              (r.setError(Gs.active_pairing_already_exists),
              new Error(
                `Pairing already exists: ${i}. Please try again with a new connection URI.`
              ))
            );
          r.addTrace(Rs.pairing_not_expired);
        }
        const u = c || st(j.FIVE_MINUTES),
          p = { topic: i, relay: a, expiry: u, active: !1, methods: l };
        this.core.expirer.set(i, u),
          await this.pairings.set(i, p),
          r.addTrace(Rs.store_new_pairing),
          n.activatePairing && (await this.activate({ topic: i })),
          this.events.emit(qn.create, p),
          r.addTrace(Rs.emit_inactive_pairing),
          this.core.crypto.keychain.has(i) ||
            (await this.core.crypto.setSymKey(o, i)),
          r.addTrace(Rs.subscribing_pairing_topic);
        try {
          await this.core.relayer.confirmOnlineStateOrThrow();
        } catch {
          r.setError(Gs.no_internet_connection);
        }
        try {
          await this.core.relayer.subscribe(i, { relay: a });
        } catch (w) {
          throw (r.setError(Gs.subscribe_pairing_topic_failure), w);
        }
        return r.addTrace(Rs.subscribe_pairing_topic_success), p;
      }),
      be(this, "activate", async ({ topic: n }) => {
        this.isInitialized();
        const r = st(j.FIVE_MINUTES);
        this.core.expirer.set(n, r),
          await this.pairings.update(n, { active: !0, expiry: r });
      }),
      be(this, "ping", async (n) => {
        this.isInitialized(),
          await this.isValidPing(n),
          this.logger.warn(
            "ping() is deprecated and will be removed in the next major release."
          );
        const { topic: r } = n;
        if (this.pairings.keys.includes(r)) {
          const i = await this.sendRequest(r, "wc_pairingPing", {}),
            { done: o, resolve: a, reject: c } = jn();
          this.events.once(Oe("pairing_ping", i), ({ error: l }) => {
            l ? c(l) : a();
          }),
            await o();
        }
      }),
      be(this, "updateExpiry", async ({ topic: n, expiry: r }) => {
        this.isInitialized(), await this.pairings.update(n, { expiry: r });
      }),
      be(this, "updateMetadata", async ({ topic: n, metadata: r }) => {
        this.isInitialized(),
          await this.pairings.update(n, { peerMetadata: r });
      }),
      be(
        this,
        "getPairings",
        () => (this.isInitialized(), this.pairings.values)
      ),
      be(this, "disconnect", async (n) => {
        this.isInitialized(), await this.isValidDisconnect(n);
        const { topic: r } = n;
        this.pairings.keys.includes(r) &&
          (await this.sendRequest(
            r,
            "wc_pairingDelete",
            ze("USER_DISCONNECTED")
          ),
          await this.deletePairing(r));
      }),
      be(this, "formatUriFromPairing", (n) => {
        this.isInitialized();
        const { topic: r, relay: i, expiry: o, methods: a } = n,
          c = this.core.crypto.keychain.get(r);
        return xu({
          protocol: this.core.protocol,
          version: this.core.version,
          topic: r,
          symKey: c,
          relay: i,
          expiryTimestamp: o,
          methods: a,
        });
      }),
      be(this, "sendRequest", async (n, r, i) => {
        const o = Wn(r, i),
          a = await this.core.crypto.encode(n, o),
          c = bi[r].req;
        return (
          this.core.history.set(n, o), this.core.relayer.publish(n, a, c), o.id
        );
      }),
      be(this, "sendResult", async (n, r, i) => {
        const o = $a(n, i),
          a = await this.core.crypto.encode(r, o),
          c = (await this.core.history.get(r, n)).request.method,
          l = bi[c].res;
        await this.core.relayer.publish(r, a, l),
          await this.core.history.resolve(o);
      }),
      be(this, "sendError", async (n, r, i) => {
        const o = np(n, i),
          a = await this.core.crypto.encode(r, o),
          c = (await this.core.history.get(r, n)).request.method,
          l = bi[c] ? bi[c].res : bi.unregistered_method.res;
        await this.core.relayer.publish(r, a, l),
          await this.core.history.resolve(o);
      }),
      be(this, "deletePairing", async (n, r) => {
        await this.core.relayer.unsubscribe(n),
          await Promise.all([
            this.pairings.delete(n, ze("USER_DISCONNECTED")),
            this.core.crypto.deleteSymKey(n),
            r ? Promise.resolve() : this.core.expirer.del(n),
          ]);
      }),
      be(this, "cleanup", async () => {
        const n = this.pairings.getAll().filter((r) => pn(r.expiry));
        await Promise.all(n.map((r) => this.deletePairing(r.topic)));
      }),
      be(this, "onRelayEventRequest", async (n) => {
        const { topic: r, payload: i } = n;
        switch (i.method) {
          case "wc_pairingPing":
            return await this.onPairingPingRequest(r, i);
          case "wc_pairingDelete":
            return await this.onPairingDeleteRequest(r, i);
          default:
            return await this.onUnknownRpcMethodRequest(r, i);
        }
      }),
      be(this, "onRelayEventResponse", async (n) => {
        const { topic: r, payload: i } = n,
          o = (await this.core.history.get(r, i.id)).request.method;
        switch (o) {
          case "wc_pairingPing":
            return this.onPairingPingResponse(r, i);
          default:
            return this.onUnknownRpcMethodResponse(o);
        }
      }),
      be(this, "onPairingPingRequest", async (n, r) => {
        const { id: i } = r;
        try {
          this.isValidPing({ topic: n }),
            await this.sendResult(i, n, !0),
            this.events.emit(qn.ping, { id: i, topic: n });
        } catch (o) {
          await this.sendError(i, n, o), this.logger.error(o);
        }
      }),
      be(this, "onPairingPingResponse", (n, r) => {
        const { id: i } = r;
        setTimeout(() => {
          Vs(r)
            ? this.events.emit(Oe("pairing_ping", i), {})
            : xs(r) &&
              this.events.emit(Oe("pairing_ping", i), { error: r.error });
        }, 500);
      }),
      be(this, "onPairingDeleteRequest", async (n, r) => {
        const { id: i } = r;
        try {
          this.isValidDisconnect({ topic: n }),
            await this.deletePairing(n),
            this.events.emit(qn.delete, { id: i, topic: n });
        } catch (o) {
          await this.sendError(i, n, o), this.logger.error(o);
        }
      }),
      be(this, "onUnknownRpcMethodRequest", async (n, r) => {
        const { id: i, method: o } = r;
        try {
          if (this.registeredMethods.includes(o)) return;
          const a = ze("WC_METHOD_UNSUPPORTED", o);
          await this.sendError(i, n, a), this.logger.error(a);
        } catch (a) {
          await this.sendError(i, n, a), this.logger.error(a);
        }
      }),
      be(this, "onUnknownRpcMethodResponse", (n) => {
        this.registeredMethods.includes(n) ||
          this.logger.error(ze("WC_METHOD_UNSUPPORTED", n));
      }),
      be(this, "isValidPair", (n, r) => {
        var i;
        if (!Ut(n)) {
          const { message: a } = F("MISSING_OR_INVALID", `pair() params: ${n}`);
          throw (r.setError(Gs.malformed_pairing_uri), new Error(a));
        }
        if (!Y_(n.uri)) {
          const { message: a } = F(
            "MISSING_OR_INVALID",
            `pair() uri: ${n.uri}`
          );
          throw (r.setError(Gs.malformed_pairing_uri), new Error(a));
        }
        const o = Ru(n == null ? void 0 : n.uri);
        if (!((i = o == null ? void 0 : o.relay) != null && i.protocol)) {
          const { message: a } = F(
            "MISSING_OR_INVALID",
            "pair() uri#relay-protocol"
          );
          throw (r.setError(Gs.malformed_pairing_uri), new Error(a));
        }
        if (!(o != null && o.symKey)) {
          const { message: a } = F("MISSING_OR_INVALID", "pair() uri#symKey");
          throw (r.setError(Gs.malformed_pairing_uri), new Error(a));
        }
        if (
          o != null &&
          o.expiryTimestamp &&
          j.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()
        ) {
          r.setError(Gs.pairing_expired);
          const { message: a } = F(
            "EXPIRED",
            "pair() URI has expired. Please try again with a new connection URI."
          );
          throw new Error(a);
        }
      }),
      be(this, "isValidPing", async (n) => {
        if (!Ut(n)) {
          const { message: i } = F("MISSING_OR_INVALID", `ping() params: ${n}`);
          throw new Error(i);
        }
        const { topic: r } = n;
        await this.isValidPairingTopic(r);
      }),
      be(this, "isValidDisconnect", async (n) => {
        if (!Ut(n)) {
          const { message: i } = F(
            "MISSING_OR_INVALID",
            `disconnect() params: ${n}`
          );
          throw new Error(i);
        }
        const { topic: r } = n;
        await this.isValidPairingTopic(r);
      }),
      be(this, "isValidPairingTopic", async (n) => {
        if (!Xe(n, !1)) {
          const { message: r } = F(
            "MISSING_OR_INVALID",
            `pairing topic should be a string: ${n}`
          );
          throw new Error(r);
        }
        if (!this.pairings.keys.includes(n)) {
          const { message: r } = F(
            "NO_MATCHING_KEY",
            `pairing topic doesn't exist: ${n}`
          );
          throw new Error(r);
        }
        if (pn(this.pairings.get(n).expiry)) {
          await this.deletePairing(n);
          const { message: r } = F("EXPIRED", `pairing topic: ${n}`);
          throw new Error(r);
        }
      }),
      (this.core = e),
      (this.logger = _t(t, this.name)),
      (this.pairings = new hr(
        this.core,
        this.logger,
        this.name,
        this.storagePrefix
      ));
  }
  get context() {
    return Yt(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(ot.message, async (e) => {
      const { topic: t, message: n, transportType: r } = e;
      if (
        this.pairings.keys.includes(t) &&
        r !== We.link_mode &&
        !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))
      )
        try {
          const i = await this.core.crypto.decode(t, n);
          Ll(i)
            ? (this.core.history.set(t, i),
              await this.onRelayEventRequest({ topic: t, payload: i }))
            : Ml(i) &&
              (await this.core.history.resolve(i),
              await this.onRelayEventResponse({ topic: t, payload: i }),
              this.core.history.delete(t, i.id)),
            await this.core.relayer.messages.ack(t, n);
        } catch (i) {
          this.logger.error(i);
        }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(ns.expired, async (e) => {
      const { topic: t } = jp(e.target);
      t &&
        this.pairings.keys.includes(t) &&
        (await this.deletePairing(t, !0),
        this.events.emit(qn.expire, { topic: t }));
    });
  }
}
var K1 = Object.defineProperty,
  G1 = (s, e, t) =>
    e in s
      ? K1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  ut = (s, e, t) => G1(s, typeof e != "symbol" ? e + "" : e, t);
class Y1 extends Cw {
  constructor(e, t) {
    super(e, t),
      (this.core = e),
      (this.logger = t),
      ut(this, "records", new Map()),
      ut(this, "events", new cr.EventEmitter()),
      ut(this, "name", JC),
      ut(this, "version", XC),
      ut(this, "cached", []),
      ut(this, "initialized", !1),
      ut(this, "storagePrefix", Ms),
      ut(this, "init", async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          await this.restore(),
          this.cached.forEach((n) => this.records.set(n.id, n)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0));
      }),
      ut(this, "set", (n, r, i) => {
        if (
          (this.isInitialized(),
          this.logger.debug("Setting JSON-RPC request history record"),
          this.logger.trace({
            type: "method",
            method: "set",
            topic: n,
            request: r,
            chainId: i,
          }),
          this.records.has(r.id))
        )
          return;
        const o = {
          id: r.id,
          topic: n,
          request: { method: r.method, params: r.params || null },
          chainId: i,
          expiry: st(j.THIRTY_DAYS),
        };
        this.records.set(o.id, o),
          this.persist(),
          this.events.emit(ds.created, o);
      }),
      ut(this, "resolve", async (n) => {
        if (
          (this.isInitialized(),
          this.logger.debug("Updating JSON-RPC response history record"),
          this.logger.trace({ type: "method", method: "update", response: n }),
          !this.records.has(n.id))
        )
          return;
        const r = await this.getRecord(n.id);
        typeof r.response > "u" &&
          ((r.response = xs(n) ? { error: n.error } : { result: n.result }),
          this.records.set(r.id, r),
          this.persist(),
          this.events.emit(ds.updated, r));
      }),
      ut(
        this,
        "get",
        async (n, r) => (
          this.isInitialized(),
          this.logger.debug("Getting record"),
          this.logger.trace({ type: "method", method: "get", topic: n, id: r }),
          await this.getRecord(r)
        )
      ),
      ut(this, "delete", (n, r) => {
        this.isInitialized(),
          this.logger.debug("Deleting record"),
          this.logger.trace({ type: "method", method: "delete", id: r }),
          this.values.forEach((i) => {
            if (i.topic === n) {
              if (typeof r < "u" && i.id !== r) return;
              this.records.delete(i.id), this.events.emit(ds.deleted, i);
            }
          }),
          this.persist();
      }),
      ut(
        this,
        "exists",
        async (n, r) => (
          this.isInitialized(),
          this.records.has(r) ? (await this.getRecord(r)).topic === n : !1
        )
      ),
      ut(this, "on", (n, r) => {
        this.events.on(n, r);
      }),
      ut(this, "once", (n, r) => {
        this.events.once(n, r);
      }),
      ut(this, "off", (n, r) => {
        this.events.off(n, r);
      }),
      ut(this, "removeListener", (n, r) => {
        this.events.removeListener(n, r);
      }),
      (this.logger = _t(t, this.name));
  }
  get context() {
    return Yt(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return (
      this.values.forEach((t) => {
        if (typeof t.response < "u") return;
        const n = {
          topic: t.topic,
          request: Wn(t.request.method, t.request.params, t.id),
          chainId: t.chainId,
        };
        return e.push(n);
      }),
      e
    );
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: n } = F("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(ds.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = F("RESTORE_WILL_OVERRIDE", this.name);
        throw (this.logger.error(t), new Error(t));
      }
      (this.cached = e),
        this.logger.debug(`Successfully Restored records for ${this.name}`),
        this.logger.trace({
          type: "method",
          method: "restore",
          records: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`),
        this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(ds.created, (e) => {
      const t = ds.created;
      this.logger.info(`Emitting ${t}`),
        this.logger.debug({ type: "event", event: t, record: e });
    }),
      this.events.on(ds.updated, (e) => {
        const t = ds.updated;
        this.logger.info(`Emitting ${t}`),
          this.logger.debug({ type: "event", event: t, record: e });
      }),
      this.events.on(ds.deleted, (e) => {
        const t = ds.deleted;
        this.logger.info(`Emitting ${t}`),
          this.logger.debug({ type: "event", event: t, record: e });
      }),
      this.core.heartbeat.on(si.pulse, () => {
        this.cleanup();
      });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = !1;
      this.records.forEach((t) => {
        j.toMiliseconds(t.expiry || 0) - Date.now() <= 0 &&
          (this.logger.info(`Deleting expired history log: ${t.id}`),
          this.records.delete(t.id),
          this.events.emit(ds.deleted, t, !1),
          (e = !0));
      }),
        e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var Z1 = Object.defineProperty,
  J1 = (s, e, t) =>
    e in s
      ? Z1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Et = (s, e, t) => J1(s, typeof e != "symbol" ? e + "" : e, t);
class X1 extends Tw {
  constructor(e, t) {
    super(e, t),
      (this.core = e),
      (this.logger = t),
      Et(this, "expirations", new Map()),
      Et(this, "events", new cr.EventEmitter()),
      Et(this, "name", QC),
      Et(this, "version", ev),
      Et(this, "cached", []),
      Et(this, "initialized", !1),
      Et(this, "storagePrefix", Ms),
      Et(this, "init", async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          await this.restore(),
          this.cached.forEach((n) => this.expirations.set(n.target, n)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0));
      }),
      Et(this, "has", (n) => {
        try {
          const r = this.formatTarget(n);
          return typeof this.getExpiration(r) < "u";
        } catch {
          return !1;
        }
      }),
      Et(this, "set", (n, r) => {
        this.isInitialized();
        const i = this.formatTarget(n),
          o = { target: i, expiry: r };
        this.expirations.set(i, o),
          this.checkExpiry(i, o),
          this.events.emit(ns.created, { target: i, expiration: o });
      }),
      Et(this, "get", (n) => {
        this.isInitialized();
        const r = this.formatTarget(n);
        return this.getExpiration(r);
      }),
      Et(this, "del", (n) => {
        if ((this.isInitialized(), this.has(n))) {
          const r = this.formatTarget(n),
            i = this.getExpiration(r);
          this.expirations.delete(r),
            this.events.emit(ns.deleted, { target: r, expiration: i });
        }
      }),
      Et(this, "on", (n, r) => {
        this.events.on(n, r);
      }),
      Et(this, "once", (n, r) => {
        this.events.once(n, r);
      }),
      Et(this, "off", (n, r) => {
        this.events.off(n, r);
      }),
      Et(this, "removeListener", (n, r) => {
        this.events.removeListener(n, r);
      }),
      (this.logger = _t(t, this.name));
  }
  get context() {
    return Yt(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return UE(e);
    if (typeof e == "number") return $E(e);
    const { message: t } = F("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(ns.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = F("RESTORE_WILL_OVERRIDE", this.name);
        throw (this.logger.error(t), new Error(t));
      }
      (this.cached = e),
        this.logger.debug(`Successfully Restored expirations for ${this.name}`),
        this.logger.trace({
          type: "method",
          method: "restore",
          expirations: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`),
        this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: n } = F("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw (this.logger.warn(n), new Error(n));
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: n } = t;
    j.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e),
      this.events.emit(ns.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected &&
      this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(si.pulse, () => this.checkExpirations()),
      this.events.on(ns.created, (e) => {
        const t = ns.created;
        this.logger.info(`Emitting ${t}`),
          this.logger.debug({ type: "event", event: t, data: e }),
          this.persist();
      }),
      this.events.on(ns.expired, (e) => {
        const t = ns.expired;
        this.logger.info(`Emitting ${t}`),
          this.logger.debug({ type: "event", event: t, data: e }),
          this.persist();
      }),
      this.events.on(ns.deleted, (e) => {
        const t = ns.deleted;
        this.logger.info(`Emitting ${t}`),
          this.logger.debug({ type: "event", event: t, data: e }),
          this.persist();
      });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var Q1 = Object.defineProperty,
  eI = (s, e, t) =>
    e in s
      ? Q1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Je = (s, e, t) => eI(s, typeof e != "symbol" ? e + "" : e, t);
class tI extends Rw {
  constructor(e, t, n) {
    super(e, t, n),
      (this.core = e),
      (this.logger = t),
      (this.store = n),
      Je(this, "name", tv),
      Je(this, "abortController"),
      Je(this, "isDevEnv"),
      Je(this, "verifyUrlV3", nv),
      Je(this, "storagePrefix", Ms),
      Je(this, "version", Df),
      Je(this, "publicKey"),
      Je(this, "fetchPromise"),
      Je(this, "init", async () => {
        var r;
        this.isDevEnv ||
          ((this.publicKey = await this.store.getItem(this.storeKey)),
          this.publicKey &&
            j.toMiliseconds(
              (r = this.publicKey) == null ? void 0 : r.expiresAt
            ) < Date.now() &&
            (this.logger.debug("verify v2 public key expired"),
            await this.removePublicKey()));
      }),
      Je(this, "register", async (r) => {
        if (!oi() || this.isDevEnv) return;
        const i = window.location.origin,
          { id: o, decryptedId: a } = r,
          c = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${i}&id=${o}&decryptedId=${a}`;
        try {
          const l = en.getDocument(),
            d = this.startAbortTimer(j.ONE_SECOND * 5),
            u = await new Promise((p, w) => {
              const g = () => {
                window.removeEventListener("message", f),
                  l.body.removeChild(m),
                  w("attestation aborted");
              };
              this.abortController.signal.addEventListener("abort", g);
              const m = l.createElement("iframe");
              (m.src = c),
                (m.style.display = "none"),
                m.addEventListener("error", g, {
                  signal: this.abortController.signal,
                });
              const f = (E) => {
                if (E.data && typeof E.data == "string")
                  try {
                    const b = JSON.parse(E.data);
                    if (b.type === "verify_attestation") {
                      if (jc(b.attestation).payload.id !== o) return;
                      clearInterval(d),
                        l.body.removeChild(m),
                        this.abortController.signal.removeEventListener(
                          "abort",
                          g
                        ),
                        window.removeEventListener("message", f),
                        p(b.attestation === null ? "" : b.attestation);
                    }
                  } catch (b) {
                    this.logger.warn(b);
                  }
              };
              l.body.appendChild(m),
                window.addEventListener("message", f, {
                  signal: this.abortController.signal,
                });
            });
          return this.logger.debug("jwt attestation", u), u;
        } catch (l) {
          this.logger.warn(l);
        }
        return "";
      }),
      Je(this, "resolve", async (r) => {
        if (this.isDevEnv) return "";
        const { attestationId: i, hash: o, encryptedId: a } = r;
        if (i === "") {
          this.logger.debug("resolve: attestationId is empty, skipping");
          return;
        }
        if (i) {
          if (jc(i).payload.id !== a) return;
          const l = await this.isValidJwtAttestation(i);
          if (l) {
            if (!l.isVerified) {
              this.logger.warn(
                "resolve: jwt attestation: origin url not verified"
              );
              return;
            }
            return l;
          }
        }
        if (!o) return;
        const c = this.getVerifyUrl(r == null ? void 0 : r.verifyUrl);
        return this.fetchAttestation(o, c);
      }),
      Je(this, "fetchAttestation", async (r, i) => {
        this.logger.debug(`resolving attestation: ${r} from url: ${i}`);
        const o = this.startAbortTimer(j.ONE_SECOND * 5),
          a = await fetch(`${i}/attestation/${r}?v2Supported=true`, {
            signal: this.abortController.signal,
          });
        return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
      }),
      Je(this, "getVerifyUrl", (r) => {
        let i = r || Hi;
        return (
          rv.includes(i) ||
            (this.logger.info(
              `verify url: ${i}, not included in trusted list, assigning default: ${Hi}`
            ),
            (i = Hi)),
          i
        );
      }),
      Je(this, "fetchPublicKey", async () => {
        try {
          this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
          const r = this.startAbortTimer(j.FIVE_SECONDS),
            i = await fetch(`${this.verifyUrlV3}/public-key`, {
              signal: this.abortController.signal,
            });
          return clearTimeout(r), await i.json();
        } catch (r) {
          this.logger.warn(r);
        }
      }),
      Je(this, "persistPublicKey", async (r) => {
        this.logger.debug("persisting public key to local storage", r),
          await this.store.setItem(this.storeKey, r),
          (this.publicKey = r);
      }),
      Je(this, "removePublicKey", async () => {
        this.logger.debug("removing verify v2 public key from storage"),
          await this.store.removeItem(this.storeKey),
          (this.publicKey = void 0);
      }),
      Je(this, "isValidJwtAttestation", async (r) => {
        const i = await this.getPublicKey();
        try {
          if (i) return this.validateAttestation(r, i);
        } catch (a) {
          this.logger.error(a),
            this.logger.warn("error validating attestation");
        }
        const o = await this.fetchAndPersistPublicKey();
        try {
          if (o) return this.validateAttestation(r, o);
        } catch (a) {
          this.logger.error(a),
            this.logger.warn("error validating attestation");
        }
      }),
      Je(this, "getPublicKey", async () =>
        this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()
      ),
      Je(this, "fetchAndPersistPublicKey", async () => {
        if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
        this.fetchPromise = new Promise(async (i) => {
          const o = await this.fetchPublicKey();
          o && (await this.persistPublicKey(o), i(o));
        });
        const r = await this.fetchPromise;
        return (this.fetchPromise = void 0), r;
      }),
      Je(this, "validateAttestation", (r, i) => {
        const o = T_(r, i.publicKey),
          a = { hasExpired: j.toMiliseconds(o.exp) < Date.now(), payload: o };
        if (a.hasExpired)
          throw (
            (this.logger.warn("resolve: jwt attestation expired"),
            new Error("JWT attestation expired"))
          );
        return {
          origin: a.payload.origin,
          isScam: a.payload.isScam,
          isVerified: a.payload.isVerified,
        };
      }),
      (this.logger = _t(t, this.name)),
      (this.abortController = new AbortController()),
      (this.isDevEnv = Gl()),
      this.init();
  }
  get storeKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//verify:public:key"
    );
  }
  get context() {
    return Yt(this.logger);
  }
  startAbortTimer(e) {
    return (
      (this.abortController = new AbortController()),
      setTimeout(() => this.abortController.abort(), j.toMiliseconds(e))
    );
  }
}
var sI = Object.defineProperty,
  nI = (s, e, t) =>
    e in s
      ? sI(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  oh = (s, e, t) => nI(s, typeof e != "symbol" ? e + "" : e, t);
class rI extends xw {
  constructor(e, t) {
    super(e, t),
      (this.projectId = e),
      (this.logger = t),
      oh(this, "context", iv),
      oh(this, "registerDeviceToken", async (n) => {
        const {
            clientId: r,
            token: i,
            notificationType: o,
            enableEncrypted: a = !1,
          } = n,
          c = `${ov}/${this.projectId}/clients`;
        await fetch(c, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            client_id: r,
            type: o,
            token: i,
            always_raw: a,
          }),
        });
      }),
      (this.logger = _t(t, this.context));
  }
}
var iI = Object.defineProperty,
  ah = Object.getOwnPropertySymbols,
  oI = Object.prototype.hasOwnProperty,
  aI = Object.prototype.propertyIsEnumerable,
  _l = (s, e, t) =>
    e in s
      ? iI(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  vi = (s, e) => {
    for (var t in e || (e = {})) oI.call(e, t) && _l(s, t, e[t]);
    if (ah) for (var t of ah(e)) aI.call(e, t) && _l(s, t, e[t]);
    return s;
  },
  rt = (s, e, t) => _l(s, typeof e != "symbol" ? e + "" : e, t);
class cI extends Pw {
  constructor(e, t, n = !0) {
    super(e, t, n),
      (this.core = e),
      (this.logger = t),
      rt(this, "context", cv),
      rt(this, "storagePrefix", Ms),
      rt(this, "storageVersion", av),
      rt(this, "events", new Map()),
      rt(this, "shouldPersist", !1),
      rt(this, "init", async () => {
        if (!Gl())
          try {
            const r = {
              eventId: Jd(),
              timestamp: Date.now(),
              domain: this.getAppDomain(),
              props: {
                event: "INIT",
                type: "",
                properties: {
                  client_id: await this.core.crypto.getClientId(),
                  user_agent: Bp(
                    this.core.relayer.protocol,
                    this.core.relayer.version,
                    pl
                  ),
                },
              },
            };
            await this.sendEvent([r]);
          } catch (r) {
            this.logger.warn(r);
          }
      }),
      rt(this, "createEvent", (r) => {
        const {
            event: i = "ERROR",
            type: o = "",
            properties: { topic: a, trace: c },
          } = r,
          l = Jd(),
          d = this.core.projectId || "",
          u = Date.now(),
          p = vi(
            {
              eventId: l,
              timestamp: u,
              props: { event: i, type: o, properties: { topic: a, trace: c } },
              bundleId: d,
              domain: this.getAppDomain(),
            },
            this.setMethods(l)
          );
        return (
          this.telemetryEnabled &&
            (this.events.set(l, p), (this.shouldPersist = !0)),
          p
        );
      }),
      rt(this, "getEvent", (r) => {
        const { eventId: i, topic: o } = r;
        if (i) return this.events.get(i);
        const a = Array.from(this.events.values()).find(
          (c) => c.props.properties.topic === o
        );
        if (a) return vi(vi({}, a), this.setMethods(a.eventId));
      }),
      rt(this, "deleteEvent", (r) => {
        const { eventId: i } = r;
        this.events.delete(i), (this.shouldPersist = !0);
      }),
      rt(this, "setEventListeners", () => {
        this.core.heartbeat.on(si.pulse, async () => {
          this.shouldPersist && (await this.persist()),
            this.events.forEach((r) => {
              j.fromMiliseconds(Date.now()) - j.fromMiliseconds(r.timestamp) >
                lv &&
                (this.events.delete(r.eventId), (this.shouldPersist = !0));
            });
        });
      }),
      rt(this, "setMethods", (r) => ({
        addTrace: (i) => this.addTrace(r, i),
        setError: (i) => this.setError(r, i),
      })),
      rt(this, "addTrace", (r, i) => {
        const o = this.events.get(r);
        o &&
          (o.props.properties.trace.push(i),
          this.events.set(r, o),
          (this.shouldPersist = !0));
      }),
      rt(this, "setError", (r, i) => {
        const o = this.events.get(r);
        o &&
          ((o.props.type = i),
          (o.timestamp = Date.now()),
          this.events.set(r, o),
          (this.shouldPersist = !0));
      }),
      rt(this, "persist", async () => {
        await this.core.storage.setItem(
          this.storageKey,
          Array.from(this.events.values())
        ),
          (this.shouldPersist = !1);
      }),
      rt(this, "restore", async () => {
        try {
          const r = (await this.core.storage.getItem(this.storageKey)) || [];
          if (!r.length) return;
          r.forEach((i) => {
            this.events.set(
              i.eventId,
              vi(vi({}, i), this.setMethods(i.eventId))
            );
          });
        } catch (r) {
          this.logger.warn(r);
        }
      }),
      rt(this, "submit", async () => {
        if (!this.telemetryEnabled || this.events.size === 0) return;
        const r = [];
        for (const [i, o] of this.events) o.props.type && r.push(o);
        if (r.length !== 0)
          try {
            if ((await this.sendEvent(r)).ok)
              for (const i of r)
                this.events.delete(i.eventId), (this.shouldPersist = !0);
          } catch (i) {
            this.logger.warn(i);
          }
      }),
      rt(this, "sendEvent", async (r) => {
        const i = this.getAppDomain() ? "" : "&sp=desktop";
        return await fetch(
          `${dv}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${pl}${i}`,
          { method: "POST", body: JSON.stringify(r) }
        );
      }),
      rt(this, "getAppDomain", () => Mp().url),
      (this.logger = _t(t, this.context)),
      (this.telemetryEnabled = n),
      n
        ? this.restore().then(async () => {
            await this.submit(), this.setEventListeners();
          })
        : this.persist();
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.storageVersion +
      this.core.customStoragePrefix +
      "//" +
      this.context
    );
  }
}
var lI = Object.defineProperty,
  ch = Object.getOwnPropertySymbols,
  dI = Object.prototype.hasOwnProperty,
  uI = Object.prototype.propertyIsEnumerable,
  Cl = (s, e, t) =>
    e in s
      ? lI(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  lh = (s, e) => {
    for (var t in e || (e = {})) dI.call(e, t) && Cl(s, t, e[t]);
    if (ch) for (var t of ch(e)) uI.call(e, t) && Cl(s, t, e[t]);
    return s;
  },
  je = (s, e, t) => Cl(s, typeof e != "symbol" ? e + "" : e, t);
let hI = class Jf extends yw {
  constructor(e) {
    var t;
    super(e),
      je(this, "protocol", $f),
      je(this, "version", Df),
      je(this, "name", hl),
      je(this, "relayUrl"),
      je(this, "projectId"),
      je(this, "customStoragePrefix"),
      je(this, "events", new cr.EventEmitter()),
      je(this, "logger"),
      je(this, "heartbeat"),
      je(this, "relayer"),
      je(this, "crypto"),
      je(this, "storage"),
      je(this, "history"),
      je(this, "expirer"),
      je(this, "pairing"),
      je(this, "verify"),
      je(this, "echoClient"),
      je(this, "linkModeSupportedApps"),
      je(this, "eventClient"),
      je(this, "initialized", !1),
      je(this, "logChunkController"),
      je(this, "on", (a, c) => this.events.on(a, c)),
      je(this, "once", (a, c) => this.events.once(a, c)),
      je(this, "off", (a, c) => this.events.off(a, c)),
      je(this, "removeListener", (a, c) => this.events.removeListener(a, c)),
      je(
        this,
        "dispatchEnvelope",
        ({ topic: a, message: c, sessionExists: l }) => {
          if (!a || !c) return;
          const d = {
            topic: a,
            message: c,
            publishedAt: Date.now(),
            transportType: We.link_mode,
          };
          this.relayer.onLinkMessageEvent(d, { sessionExists: l });
        }
      );
    const n = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
    if (n)
      try {
        return (
          (this.customStoragePrefix = n.customStoragePrefix),
          (this.logger = n.logger),
          (this.heartbeat = n.heartbeat),
          (this.crypto = n.crypto),
          (this.history = n.history),
          (this.expirer = n.expirer),
          (this.storage = n.storage),
          (this.relayer = n.relayer),
          (this.pairing = n.pairing),
          (this.verify = n.verify),
          (this.echoClient = n.echoClient),
          (this.linkModeSupportedApps = n.linkModeSupportedApps),
          (this.eventClient = n.eventClient),
          (this.initialized = n.initialized),
          (this.logChunkController = n.logChunkController),
          n
        );
      } catch (a) {
        console.warn("Failed to copy global core", a);
      }
    (this.projectId = e == null ? void 0 : e.projectId),
      (this.relayUrl = (e == null ? void 0 : e.relayUrl) || Mf),
      (this.customStoragePrefix =
        e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "");
    const r = ti({
        level:
          typeof (e == null ? void 0 : e.logger) == "string" && e.logger
            ? e.logger
            : OC.logger,
        name: hl,
      }),
      { logger: i, chunkLoggerController: o } = $l({
        opts: r,
        maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes,
        loggerOverride: e == null ? void 0 : e.logger,
      });
    (this.logChunkController = o),
      (t = this.logChunkController) != null &&
        t.downloadLogsBlobInBrowser &&
        (window.downloadLogsBlobInBrowser = async () => {
          var a, c;
          (a = this.logChunkController) != null &&
            a.downloadLogsBlobInBrowser &&
            ((c = this.logChunkController) == null ||
              c.downloadLogsBlobInBrowser({
                clientId: await this.crypto.getClientId(),
              }));
        }),
      (this.logger = _t(i, this.name)),
      (this.heartbeat = new Jg()),
      (this.crypto = new BA(
        this,
        this.logger,
        e == null ? void 0 : e.keychain
      )),
      (this.history = new Y1(this, this.logger)),
      (this.expirer = new X1(this, this.logger)),
      (this.storage =
        e != null && e.storage
          ? e.storage
          : new Xg(lh(lh({}, kC), e == null ? void 0 : e.storageOptions))),
      (this.relayer = new h1({
        core: this,
        logger: this.logger,
        relayUrl: this.relayUrl,
        projectId: this.projectId,
      })),
      (this.pairing = new V1(this, this.logger)),
      (this.verify = new tI(this, this.logger, this.storage)),
      (this.echoClient = new rI(this.projectId || "", this.logger)),
      (this.linkModeSupportedApps = []),
      (this.eventClient = new cI(
        this,
        this.logger,
        e == null ? void 0 : e.telemetryEnabled
      )),
      this.setGlobalCore(this);
  }
  static async init(e) {
    const t = new Jf(e);
    await t.initialize();
    const n = await t.crypto.getClientId();
    return await t.storage.setItem(VC, n), t;
  }
  get context() {
    return Yt(this.logger);
  }
  async start() {
    this.initialized || (await this.initialize());
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null
      ? void 0
      : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) ||
      (this.linkModeSupportedApps.push(e),
      await this.storage.setItem(qu, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(),
        await this.history.init(),
        await this.expirer.init(),
        await this.relayer.init(),
        await this.heartbeat.init(),
        await this.pairing.init(),
        (this.linkModeSupportedApps = (await this.storage.getItem(qu)) || []),
        (this.initialized = !0),
        this.logger.info("Core Initialization Success");
    } catch (e) {
      throw (
        (this.logger.warn(
          `Core Initialization Failure at epoch ${Date.now()}`,
          e
        ),
        this.logger.error(e.message),
        e)
      );
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e}`,
        n = `${t}_count`;
      return (
        (globalThis[n] = (globalThis[n] || 0) + 1),
        globalThis[n] > 1 &&
          console.warn(
            `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[n]} times.`
          ),
        globalThis[t]
      );
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const n = `_walletConnectCore_${
        ((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""
      }`;
      globalThis[n] = e;
    } catch (n) {
      console.warn("Failed to set global WalletConnect core", n);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && PC.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return !0;
    }
  }
};
const pI = hI,
  Xf = "wc",
  Qf = 2,
  eg = "client",
  cd = `${Xf}@${Qf}:${eg}:`,
  Ic = { name: eg, logger: "error" },
  dh = "WALLETCONNECT_DEEPLINK_CHOICE",
  fI = "proposal",
  uh = "Proposal expired",
  gI = "session",
  Er = j.SEVEN_DAYS,
  mI = "engine",
  it = {
    wc_sessionPropose: {
      req: { ttl: j.FIVE_MINUTES, prompt: !0, tag: 1100 },
      res: { ttl: j.FIVE_MINUTES, prompt: !1, tag: 1101 },
      reject: { ttl: j.FIVE_MINUTES, prompt: !1, tag: 1120 },
      autoReject: { ttl: j.FIVE_MINUTES, prompt: !1, tag: 1121 },
    },
    wc_sessionSettle: {
      req: { ttl: j.FIVE_MINUTES, prompt: !1, tag: 1102 },
      res: { ttl: j.FIVE_MINUTES, prompt: !1, tag: 1103 },
    },
    wc_sessionUpdate: {
      req: { ttl: j.ONE_DAY, prompt: !1, tag: 1104 },
      res: { ttl: j.ONE_DAY, prompt: !1, tag: 1105 },
    },
    wc_sessionExtend: {
      req: { ttl: j.ONE_DAY, prompt: !1, tag: 1106 },
      res: { ttl: j.ONE_DAY, prompt: !1, tag: 1107 },
    },
    wc_sessionRequest: {
      req: { ttl: j.FIVE_MINUTES, prompt: !0, tag: 1108 },
      res: { ttl: j.FIVE_MINUTES, prompt: !1, tag: 1109 },
    },
    wc_sessionEvent: {
      req: { ttl: j.FIVE_MINUTES, prompt: !0, tag: 1110 },
      res: { ttl: j.FIVE_MINUTES, prompt: !1, tag: 1111 },
    },
    wc_sessionDelete: {
      req: { ttl: j.ONE_DAY, prompt: !1, tag: 1112 },
      res: { ttl: j.ONE_DAY, prompt: !1, tag: 1113 },
    },
    wc_sessionPing: {
      req: { ttl: j.ONE_DAY, prompt: !1, tag: 1114 },
      res: { ttl: j.ONE_DAY, prompt: !1, tag: 1115 },
    },
    wc_sessionAuthenticate: {
      req: { ttl: j.ONE_HOUR, prompt: !0, tag: 1116 },
      res: { ttl: j.ONE_HOUR, prompt: !1, tag: 1117 },
      reject: { ttl: j.FIVE_MINUTES, prompt: !1, tag: 1118 },
      autoReject: { ttl: j.FIVE_MINUTES, prompt: !1, tag: 1119 },
    },
  },
  Sc = { min: j.FIVE_MINUTES, max: j.SEVEN_DAYS },
  Ts = { idle: "IDLE", active: "ACTIVE" },
  wI = {
    eth_sendTransaction: { key: "" },
    eth_sendRawTransaction: { key: "" },
    wallet_sendCalls: { key: "" },
    solana_signTransaction: { key: "signature" },
    solana_signAllTransactions: { key: "transactions" },
    solana_signAndSendTransaction: { key: "signature" },
    sui_signAndExecuteTransaction: { key: "digest" },
    sui_signTransaction: { key: "" },
    hedera_signAndExecuteTransaction: { key: "transactionId" },
    hedera_executeTransaction: { key: "transactionId" },
    near_signTransaction: { key: "" },
    near_signTransactions: { key: "" },
    tron_signTransaction: { key: "txID" },
    xrpl_signTransaction: { key: "" },
    xrpl_signTransactionFor: { key: "" },
    algo_signTxn: { key: "" },
    sendTransfer: { key: "txid" },
    stacks_stxTransfer: { key: "txId" },
    polkadot_signTransaction: { key: "" },
    cosmos_signDirect: { key: "" },
  },
  yI = "request",
  EI = [
    "wc_sessionPropose",
    "wc_sessionRequest",
    "wc_authRequest",
    "wc_sessionAuthenticate",
  ],
  bI = "wc",
  _I = "auth",
  CI = "authKeys",
  vI = "pairingTopics",
  AI = "requests",
  Va = `${bI}@${1.5}:${_I}:`,
  sa = `${Va}:PUB_KEY`;
var II = Object.defineProperty,
  SI = Object.defineProperties,
  NI = Object.getOwnPropertyDescriptors,
  hh = Object.getOwnPropertySymbols,
  TI = Object.prototype.hasOwnProperty,
  RI = Object.prototype.propertyIsEnumerable,
  vl = (s, e, t) =>
    e in s
      ? II(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  He = (s, e) => {
    for (var t in e || (e = {})) TI.call(e, t) && vl(s, t, e[t]);
    if (hh) for (var t of hh(e)) RI.call(e, t) && vl(s, t, e[t]);
    return s;
  },
  Ot = (s, e) => SI(s, NI(e)),
  P = (s, e, t) => vl(s, typeof e != "symbol" ? e + "" : e, t);
class xI extends $w {
  constructor(e) {
    super(e),
      P(this, "name", mI),
      P(this, "events", new Bl()),
      P(this, "initialized", !1),
      P(this, "requestQueue", { state: Ts.idle, queue: [] }),
      P(this, "sessionRequestQueue", { state: Ts.idle, queue: [] }),
      P(this, "requestQueueDelay", j.ONE_SECOND),
      P(this, "expectedPairingMethodMap", new Map()),
      P(this, "recentlyDeletedMap", new Map()),
      P(this, "recentlyDeletedLimit", 200),
      P(this, "relayMessageCache", []),
      P(this, "pendingSessions", new Map()),
      P(this, "init", async () => {
        this.initialized ||
          (await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          this.registerPairingEvents(),
          await this.registerLinkModeListeners(),
          this.client.core.pairing.register({ methods: Object.keys(it) }),
          (this.initialized = !0),
          setTimeout(async () => {
            await this.processPendingMessageEvents(),
              (this.sessionRequestQueue.queue =
                this.getPendingSessionRequests()),
              this.processSessionRequestQueue();
          }, j.toMiliseconds(this.requestQueueDelay)));
      }),
      P(this, "connect", async (t) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        const n = Ot(He({}, t), {
          requiredNamespaces: t.requiredNamespaces || {},
          optionalNamespaces: t.optionalNamespaces || {},
        });
        await this.isValidConnect(n),
          (n.optionalNamespaces = W_(
            n.requiredNamespaces,
            n.optionalNamespaces
          )),
          (n.requiredNamespaces = {});
        const {
          pairingTopic: r,
          requiredNamespaces: i,
          optionalNamespaces: o,
          sessionProperties: a,
          scopedProperties: c,
          relays: l,
        } = n;
        let d = r,
          u,
          p = !1;
        try {
          if (d) {
            const L = this.client.core.pairing.pairings.get(d);
            this.client.logger.warn(
              "connect() with existing pairing topic is deprecated and will be removed in the next major release."
            ),
              (p = L.active);
          }
        } catch (L) {
          throw (
            (this.client.logger.error(`connect() -> pairing.get(${d}) failed`),
            L)
          );
        }
        if (!d || !p) {
          const { topic: L, uri: Q } = await this.client.core.pairing.create();
          (d = L), (u = Q);
        }
        if (!d) {
          const { message: L } = F(
            "NO_MATCHING_KEY",
            `connect() pairing topic: ${d}`
          );
          throw new Error(L);
        }
        const w = await this.client.core.crypto.generateKeyPair(),
          g = it.wc_sessionPropose.req.ttl || j.FIVE_MINUTES,
          m = st(g),
          f = Ot(
            He(
              He(
                {
                  requiredNamespaces: i,
                  optionalNamespaces: o,
                  relays: l ?? [{ protocol: Lf }],
                  proposer: { publicKey: w, metadata: this.client.metadata },
                  expiryTimestamp: m,
                  pairingTopic: d,
                },
                a && { sessionProperties: a }
              ),
              c && { scopedProperties: c }
            ),
            { id: nn() }
          ),
          E = Oe("session_connect", f.id),
          { reject: b, resolve: _, done: N } = jn(g, uh),
          A = ({ id: L }) => {
            L === f.id &&
              (this.client.events.off("proposal_expire", A),
              this.pendingSessions.delete(f.id),
              this.events.emit(E, { error: { message: uh, code: 0 } }));
          };
        return (
          this.client.events.on("proposal_expire", A),
          this.events.once(E, ({ error: L, session: Q }) => {
            this.client.events.off("proposal_expire", A), L ? b(L) : Q && _(Q);
          }),
          await this.sendRequest({
            topic: d,
            method: "wc_sessionPropose",
            params: f,
            throwOnFailedPublish: !0,
            clientRpcId: f.id,
          }),
          await this.setProposal(f.id, f),
          { uri: u, approval: N }
        );
      }),
      P(this, "pair", async (t) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          return await this.client.core.pairing.pair(t);
        } catch (n) {
          throw (this.client.logger.error("pair() failed"), n);
        }
      }),
      P(this, "approve", async (t) => {
        var n, r, i;
        const o = this.client.core.eventClient.createEvent({
          properties: {
            topic:
              (n = t == null ? void 0 : t.id) == null ? void 0 : n.toString(),
            trace: [us.session_approve_started],
          },
        });
        try {
          this.isInitialized(), await this.confirmOnlineStateOrThrow();
        } catch (C) {
          throw (o.setError($n.no_internet_connection), C);
        }
        try {
          await this.isValidProposalId(t == null ? void 0 : t.id);
        } catch (C) {
          throw (
            (this.client.logger.error(
              `approve() -> proposal.get(${t == null ? void 0 : t.id}) failed`
            ),
            o.setError($n.proposal_not_found),
            C)
          );
        }
        try {
          await this.isValidApprove(t);
        } catch (C) {
          throw (
            (this.client.logger.error("approve() -> isValidApprove() failed"),
            o.setError($n.session_approve_namespace_validation_failure),
            C)
          );
        }
        const {
            id: a,
            relayProtocol: c,
            namespaces: l,
            sessionProperties: d,
            scopedProperties: u,
            sessionConfig: p,
          } = t,
          w = this.client.proposal.get(a);
        this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
        const {
          pairingTopic: g,
          proposer: m,
          requiredNamespaces: f,
          optionalNamespaces: E,
        } = w;
        let b =
          (r = this.client.core.eventClient) == null
            ? void 0
            : r.getEvent({ topic: g });
        b ||
          (b =
            (i = this.client.core.eventClient) == null
              ? void 0
              : i.createEvent({
                  type: us.session_approve_started,
                  properties: {
                    topic: g,
                    trace: [
                      us.session_approve_started,
                      us.session_namespaces_validation_success,
                    ],
                  },
                }));
        const _ = await this.client.core.crypto.generateKeyPair(),
          N = m.publicKey,
          A = await this.client.core.crypto.generateSharedKey(_, N),
          L = He(
            He(
              He(
                {
                  relay: { protocol: c ?? "irn" },
                  namespaces: l,
                  controller: { publicKey: _, metadata: this.client.metadata },
                  expiry: st(Er),
                },
                d && { sessionProperties: d }
              ),
              u && { scopedProperties: u }
            ),
            p && { sessionConfig: p }
          ),
          Q = We.relay;
        b.addTrace(us.subscribing_session_topic);
        try {
          await this.client.core.relayer.subscribe(A, { transportType: Q });
        } catch (C) {
          throw (b.setError($n.subscribe_session_topic_failure), C);
        }
        b.addTrace(us.subscribe_session_topic_success);
        const K = Ot(He({}, L), {
          topic: A,
          requiredNamespaces: f,
          optionalNamespaces: E,
          pairingTopic: g,
          acknowledged: !1,
          self: L.controller,
          peer: { publicKey: m.publicKey, metadata: m.metadata },
          controller: _,
          transportType: We.relay,
        });
        await this.client.session.set(A, K), b.addTrace(us.store_session);
        try {
          b.addTrace(us.publishing_session_settle),
            await this.sendRequest({
              topic: A,
              method: "wc_sessionSettle",
              params: L,
              throwOnFailedPublish: !0,
            }).catch((C) => {
              throw (
                (b == null || b.setError($n.session_settle_publish_failure), C)
              );
            }),
            b.addTrace(us.session_settle_publish_success),
            b.addTrace(us.publishing_session_approve),
            await this.sendResult({
              id: a,
              topic: g,
              result: {
                relay: { protocol: c ?? "irn" },
                responderPublicKey: _,
              },
              throwOnFailedPublish: !0,
            }).catch((C) => {
              throw (
                (b == null || b.setError($n.session_approve_publish_failure), C)
              );
            }),
            b.addTrace(us.session_approve_publish_success);
        } catch (C) {
          throw (
            (this.client.logger.error(C),
            this.client.session.delete(A, ze("USER_DISCONNECTED")),
            await this.client.core.relayer.unsubscribe(A),
            C)
          );
        }
        return (
          this.client.core.eventClient.deleteEvent({ eventId: b.eventId }),
          await this.client.core.pairing.updateMetadata({
            topic: g,
            metadata: m.metadata,
          }),
          await this.deleteProposal(a),
          await this.client.core.pairing.activate({ topic: g }),
          await this.setExpiry(A, st(Er)),
          {
            topic: A,
            acknowledged: () => Promise.resolve(this.client.session.get(A)),
          }
        );
      }),
      P(this, "reject", async (t) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          await this.isValidReject(t);
        } catch (o) {
          throw (
            (this.client.logger.error("reject() -> isValidReject() failed"), o)
          );
        }
        const { id: n, reason: r } = t;
        let i;
        try {
          i = this.client.proposal.get(n).pairingTopic;
        } catch (o) {
          throw (
            (this.client.logger.error(`reject() -> proposal.get(${n}) failed`),
            o)
          );
        }
        i &&
          (await this.sendError({
            id: n,
            topic: i,
            error: r,
            rpcOpts: it.wc_sessionPropose.reject,
          })),
          await this.deleteProposal(n);
      }),
      P(this, "update", async (t) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          await this.isValidUpdate(t);
        } catch (u) {
          throw (
            (this.client.logger.error("update() -> isValidUpdate() failed"), u)
          );
        }
        const { topic: n, namespaces: r } = t,
          { done: i, resolve: o, reject: a } = jn(),
          c = nn(),
          l = Dr().toString(),
          d = this.client.session.get(n).namespaces;
        return (
          this.events.once(Oe("session_update", c), ({ error: u }) => {
            u ? a(u) : o();
          }),
          await this.client.session.update(n, { namespaces: r }),
          await this.sendRequest({
            topic: n,
            method: "wc_sessionUpdate",
            params: { namespaces: r },
            throwOnFailedPublish: !0,
            clientRpcId: c,
            relayRpcId: l,
          }).catch((u) => {
            this.client.logger.error(u),
              this.client.session.update(n, { namespaces: d }),
              a(u);
          }),
          { acknowledged: i }
        );
      }),
      P(this, "extend", async (t) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          await this.isValidExtend(t);
        } catch (c) {
          throw (
            (this.client.logger.error("extend() -> isValidExtend() failed"), c)
          );
        }
        const { topic: n } = t,
          r = nn(),
          { done: i, resolve: o, reject: a } = jn();
        return (
          this.events.once(Oe("session_extend", r), ({ error: c }) => {
            c ? a(c) : o();
          }),
          await this.setExpiry(n, st(Er)),
          this.sendRequest({
            topic: n,
            method: "wc_sessionExtend",
            params: {},
            clientRpcId: r,
            throwOnFailedPublish: !0,
          }).catch((c) => {
            a(c);
          }),
          { acknowledged: i }
        );
      }),
      P(this, "request", async (t) => {
        this.isInitialized();
        try {
          await this.isValidRequest(t);
        } catch (f) {
          throw (
            (this.client.logger.error("request() -> isValidRequest() failed"),
            f)
          );
        }
        const {
            chainId: n,
            request: r,
            topic: i,
            expiry: o = it.wc_sessionRequest.req.ttl,
          } = t,
          a = this.client.session.get(i);
        (a == null ? void 0 : a.transportType) === We.relay &&
          (await this.confirmOnlineStateOrThrow());
        const c = nn(),
          l = Dr().toString(),
          {
            done: d,
            resolve: u,
            reject: p,
          } = jn(o, "Request expired. Please try again.");
        this.events.once(
          Oe("session_request", c),
          ({ error: f, result: E }) => {
            f ? p(f) : u(E);
          }
        );
        const w = "wc_sessionRequest",
          g = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
        if (g)
          return (
            await this.sendRequest({
              clientRpcId: c,
              relayRpcId: l,
              topic: i,
              method: w,
              params: {
                request: Ot(He({}, r), { expiryTimestamp: st(o) }),
                chainId: n,
              },
              expiry: o,
              throwOnFailedPublish: !0,
              appLink: g,
            }).catch((f) => p(f)),
            this.client.events.emit("session_request_sent", {
              topic: i,
              request: r,
              chainId: n,
              id: c,
            }),
            await d()
          );
        const m = {
          request: Ot(He({}, r), { expiryTimestamp: st(o) }),
          chainId: n,
        };
        return await Promise.all([
          new Promise(async (f) => {
            await this.sendRequest({
              clientRpcId: c,
              relayRpcId: l,
              topic: i,
              method: w,
              params: m,
              expiry: o,
              throwOnFailedPublish: !0,
              tvf: this.getTVFParams(c, m),
            }).catch((E) => p(E)),
              this.client.events.emit("session_request_sent", {
                topic: i,
                request: r,
                chainId: n,
                id: c,
              }),
              f();
          }),
          new Promise(async (f) => {
            var E;
            if (!((E = a.sessionConfig) != null && E.disableDeepLink)) {
              const b = await BE(this.client.core.storage, dh);
              await DE({ id: c, topic: i, wcDeepLink: b });
            }
            f();
          }),
          d(),
        ]).then((f) => f[2]);
      }),
      P(this, "respond", async (t) => {
        this.isInitialized(), await this.isValidRespond(t);
        const { topic: n, response: r } = t,
          { id: i } = r,
          o = this.client.session.get(n);
        o.transportType === We.relay &&
          (await this.confirmOnlineStateOrThrow());
        const a = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
        Vs(r)
          ? await this.sendResult({
              id: i,
              topic: n,
              result: r.result,
              throwOnFailedPublish: !0,
              appLink: a,
            })
          : xs(r) &&
            (await this.sendError({
              id: i,
              topic: n,
              error: r.error,
              appLink: a,
            })),
          this.cleanupAfterResponse(t);
      }),
      P(this, "ping", async (t) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          await this.isValidPing(t);
        } catch (r) {
          throw (this.client.logger.error("ping() -> isValidPing() failed"), r);
        }
        const { topic: n } = t;
        if (this.client.session.keys.includes(n)) {
          const r = nn(),
            i = Dr().toString(),
            { done: o, resolve: a, reject: c } = jn();
          this.events.once(Oe("session_ping", r), ({ error: l }) => {
            l ? c(l) : a();
          }),
            await Promise.all([
              this.sendRequest({
                topic: n,
                method: "wc_sessionPing",
                params: {},
                throwOnFailedPublish: !0,
                clientRpcId: r,
                relayRpcId: i,
              }),
              o(),
            ]);
        } else
          this.client.core.pairing.pairings.keys.includes(n) &&
            (this.client.logger.warn(
              "ping() on pairing topic is deprecated and will be removed in the next major release."
            ),
            await this.client.core.pairing.ping({ topic: n }));
      }),
      P(this, "emit", async (t) => {
        this.isInitialized(),
          await this.confirmOnlineStateOrThrow(),
          await this.isValidEmit(t);
        const { topic: n, event: r, chainId: i } = t,
          o = Dr().toString(),
          a = nn();
        await this.sendRequest({
          topic: n,
          method: "wc_sessionEvent",
          params: { event: r, chainId: i },
          throwOnFailedPublish: !0,
          relayRpcId: o,
          clientRpcId: a,
        });
      }),
      P(this, "disconnect", async (t) => {
        this.isInitialized(),
          await this.confirmOnlineStateOrThrow(),
          await this.isValidDisconnect(t);
        const { topic: n } = t;
        if (this.client.session.keys.includes(n))
          await this.sendRequest({
            topic: n,
            method: "wc_sessionDelete",
            params: ze("USER_DISCONNECTED"),
            throwOnFailedPublish: !0,
          }),
            await this.deleteSession({ topic: n, emitEvent: !1 });
        else if (this.client.core.pairing.pairings.keys.includes(n))
          await this.client.core.pairing.disconnect({ topic: n });
        else {
          const { message: r } = F(
            "MISMATCHED_TOPIC",
            `Session or pairing topic not found: ${n}`
          );
          throw new Error(r);
        }
      }),
      P(
        this,
        "find",
        (t) => (
          this.isInitialized(),
          this.client.session.getAll().filter((n) => K_(n, t))
        )
      ),
      P(this, "getPendingSessionRequests", () =>
        this.client.pendingRequest.getAll()
      ),
      P(this, "authenticate", async (t, n) => {
        var r;
        this.isInitialized(), this.isValidAuthenticate(t);
        const i =
            n &&
            this.client.core.linkModeSupportedApps.includes(n) &&
            ((r = this.client.metadata.redirect) == null ? void 0 : r.linkMode),
          o = i ? We.link_mode : We.relay;
        o === We.relay && (await this.confirmOnlineStateOrThrow());
        const {
            chains: a,
            statement: c = "",
            uri: l,
            domain: d,
            nonce: u,
            type: p,
            exp: w,
            nbf: g,
            methods: m = [],
            expiry: f,
          } = t,
          E = [...(t.resources || [])],
          { topic: b, uri: _ } = await this.client.core.pairing.create({
            methods: ["wc_sessionAuthenticate"],
            transportType: o,
          });
        this.client.logger.info({
          message: "Generated new pairing",
          pairing: { topic: b, uri: _ },
        });
        const N = await this.client.core.crypto.generateKeyPair(),
          A = ea(N);
        if (
          (await Promise.all([
            this.client.auth.authKeys.set(sa, {
              responseTopic: A,
              publicKey: N,
            }),
            this.client.auth.pairingTopics.set(A, {
              topic: A,
              pairingTopic: b,
            }),
          ]),
          await this.client.core.relayer.subscribe(A, { transportType: o }),
          this.client.logger.info(`sending request to new pairing topic: ${b}`),
          m.length > 0)
        ) {
          const { namespace: O } = Fr(a[0]);
          let ee = e0(O, "request", m);
          Qo(E) && (ee = s0(ee, E.pop())), E.push(ee);
        }
        const L =
            f && f > it.wc_sessionAuthenticate.req.ttl
              ? f
              : it.wc_sessionAuthenticate.req.ttl,
          Q = {
            authPayload: {
              type: p ?? "caip122",
              chains: a,
              statement: c,
              aud: l,
              domain: d,
              version: "1",
              nonce: u,
              iat: new Date().toISOString(),
              exp: w,
              nbf: g,
              resources: E,
            },
            requester: { publicKey: N, metadata: this.client.metadata },
            expiryTimestamp: st(L),
          },
          K = {
            eip155: {
              chains: a,
              methods: [...new Set(["personal_sign", ...m])],
              events: ["chainChanged", "accountsChanged"],
            },
          },
          C = {
            requiredNamespaces: {},
            optionalNamespaces: K,
            relays: [{ protocol: "irn" }],
            pairingTopic: b,
            proposer: { publicKey: N, metadata: this.client.metadata },
            expiryTimestamp: st(it.wc_sessionPropose.req.ttl),
            id: nn(),
          },
          { done: T, resolve: v, reject: I } = jn(L, "Request expired"),
          x = nn(),
          U = Oe("session_connect", C.id),
          k = Oe("session_request", x),
          $ = async ({ error: O, session: ee }) => {
            this.events.off(k, B), O ? I(O) : ee && v({ session: ee });
          },
          B = async (O) => {
            var ee, J, ce;
            if (
              (await this.deletePendingAuthRequest(x, {
                message: "fulfilled",
                code: 0,
              }),
              O.error)
            ) {
              const Ve = ze("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
              return O.error.code === Ve.code
                ? void 0
                : (this.events.off(U, $), I(O.error.message));
            }
            await this.deleteProposal(C.id), this.events.off(U, $);
            const { cacaos: ye, responder: we } = O.result,
              Ee = [],
              Me = [];
            for (const Ve of ye) {
              (await cu({
                cacao: Ve,
                projectId: this.client.core.projectId,
              })) ||
                (this.client.logger.error(Ve, "Signature verification failed"),
                I(
                  ze(
                    "SESSION_SETTLEMENT_FAILED",
                    "Signature verification failed"
                  )
                ));
              const { p: Jt } = Ve,
                js = Qo(Jt.resources),
                md = [tl(Jt.iss)],
                Fg = wa(Jt.iss);
              if (js) {
                const Ja = lu(js),
                  jg = du(js);
                Ee.push(...Ja), md.push(...jg);
              }
              for (const Ja of md) Me.push(`${Ja}:${Fg}`);
            }
            const Ze = await this.client.core.crypto.generateSharedKey(
              N,
              we.publicKey
            );
            let Ye;
            Ee.length > 0 &&
              ((Ye = {
                topic: Ze,
                acknowledged: !0,
                self: { publicKey: N, metadata: this.client.metadata },
                peer: we,
                controller: we.publicKey,
                expiry: st(Er),
                requiredNamespaces: {},
                optionalNamespaces: {},
                relay: { protocol: "irn" },
                pairingTopic: b,
                namespaces: Uu([...new Set(Ee)], [...new Set(Me)]),
                transportType: o,
              }),
              await this.client.core.relayer.subscribe(Ze, {
                transportType: o,
              }),
              await this.client.session.set(Ze, Ye),
              b &&
                (await this.client.core.pairing.updateMetadata({
                  topic: b,
                  metadata: we.metadata,
                })),
              (Ye = this.client.session.get(Ze))),
              (ee = this.client.metadata.redirect) != null &&
                ee.linkMode &&
                (J = we.metadata.redirect) != null &&
                J.linkMode &&
                (ce = we.metadata.redirect) != null &&
                ce.universal &&
                n &&
                (this.client.core.addLinkModeSupportedApp(
                  we.metadata.redirect.universal
                ),
                this.client.session.update(Ze, {
                  transportType: We.link_mode,
                })),
              v({ auths: ye, session: Ye });
          };
        this.events.once(U, $), this.events.once(k, B);
        let V;
        try {
          if (i) {
            const O = Wn("wc_sessionAuthenticate", Q, x);
            this.client.core.history.set(b, O);
            const ee = await this.client.core.crypto.encode("", O, {
              type: xo,
              encoding: wn,
            });
            V = zo(n, b, ee);
          } else
            await Promise.all([
              this.sendRequest({
                topic: b,
                method: "wc_sessionAuthenticate",
                params: Q,
                expiry: t.expiry,
                throwOnFailedPublish: !0,
                clientRpcId: x,
              }),
              this.sendRequest({
                topic: b,
                method: "wc_sessionPropose",
                params: C,
                expiry: it.wc_sessionPropose.req.ttl,
                throwOnFailedPublish: !0,
                clientRpcId: C.id,
              }),
            ]);
        } catch (O) {
          throw (this.events.off(U, $), this.events.off(k, B), O);
        }
        return (
          await this.setProposal(C.id, C),
          await this.setAuthRequest(x, {
            request: Ot(He({}, Q), { verifyContext: {} }),
            pairingTopic: b,
            transportType: o,
          }),
          { uri: V ?? _, response: T }
        );
      }),
      P(this, "approveSessionAuthenticate", async (t) => {
        const { id: n, auths: r } = t,
          i = this.client.core.eventClient.createEvent({
            properties: {
              topic: n.toString(),
              trace: [Dn.authenticated_session_approve_started],
            },
          });
        try {
          this.isInitialized();
        } catch (f) {
          throw (i.setError(_i.no_internet_connection), f);
        }
        const o = this.getPendingAuthRequest(n);
        if (!o)
          throw (
            (i.setError(_i.authenticated_session_pending_request_not_found),
            new Error(`Could not find pending auth request with id ${n}`))
          );
        const a = o.transportType || We.relay;
        a === We.relay && (await this.confirmOnlineStateOrThrow());
        const c = o.requester.publicKey,
          l = await this.client.core.crypto.generateKeyPair(),
          d = ea(c),
          u = { type: Js, receiverPublicKey: c, senderPublicKey: l },
          p = [],
          w = [];
        for (const f of r) {
          if (
            !(await cu({ cacao: f, projectId: this.client.core.projectId }))
          ) {
            i.setError(_i.invalid_cacao);
            const A = ze(
              "SESSION_SETTLEMENT_FAILED",
              "Signature verification failed"
            );
            throw (
              (await this.sendError({
                id: n,
                topic: d,
                error: A,
                encodeOpts: u,
              }),
              new Error(A.message))
            );
          }
          i.addTrace(Dn.cacaos_verified);
          const { p: E } = f,
            b = Qo(E.resources),
            _ = [tl(E.iss)],
            N = wa(E.iss);
          if (b) {
            const A = lu(b),
              L = du(b);
            p.push(...A), _.push(...L);
          }
          for (const A of _) w.push(`${A}:${N}`);
        }
        const g = await this.client.core.crypto.generateSharedKey(l, c);
        i.addTrace(Dn.create_authenticated_session_topic);
        let m;
        if ((p == null ? void 0 : p.length) > 0) {
          (m = {
            topic: g,
            acknowledged: !0,
            self: { publicKey: l, metadata: this.client.metadata },
            peer: { publicKey: c, metadata: o.requester.metadata },
            controller: c,
            expiry: st(Er),
            authentication: r,
            requiredNamespaces: {},
            optionalNamespaces: {},
            relay: { protocol: "irn" },
            pairingTopic: o.pairingTopic,
            namespaces: Uu([...new Set(p)], [...new Set(w)]),
            transportType: a,
          }),
            i.addTrace(Dn.subscribing_authenticated_session_topic);
          try {
            await this.client.core.relayer.subscribe(g, { transportType: a });
          } catch (f) {
            throw (
              (i.setError(_i.subscribe_authenticated_session_topic_failure), f)
            );
          }
          i.addTrace(Dn.subscribe_authenticated_session_topic_success),
            await this.client.session.set(g, m),
            i.addTrace(Dn.store_authenticated_session),
            await this.client.core.pairing.updateMetadata({
              topic: o.pairingTopic,
              metadata: o.requester.metadata,
            });
        }
        i.addTrace(Dn.publishing_authenticated_session_approve);
        try {
          await this.sendResult({
            topic: d,
            id: n,
            result: {
              cacaos: r,
              responder: { publicKey: l, metadata: this.client.metadata },
            },
            encodeOpts: u,
            throwOnFailedPublish: !0,
            appLink: this.getAppLinkIfEnabled(o.requester.metadata, a),
          });
        } catch (f) {
          throw (
            (i.setError(_i.authenticated_session_approve_publish_failure), f)
          );
        }
        return (
          await this.client.auth.requests.delete(n, {
            message: "fulfilled",
            code: 0,
          }),
          await this.client.core.pairing.activate({ topic: o.pairingTopic }),
          this.client.core.eventClient.deleteEvent({ eventId: i.eventId }),
          { session: m }
        );
      }),
      P(this, "rejectSessionAuthenticate", async (t) => {
        this.isInitialized();
        const { id: n, reason: r } = t,
          i = this.getPendingAuthRequest(n);
        if (!i)
          throw new Error(`Could not find pending auth request with id ${n}`);
        i.transportType === We.relay &&
          (await this.confirmOnlineStateOrThrow());
        const o = i.requester.publicKey,
          a = await this.client.core.crypto.generateKeyPair(),
          c = ea(o),
          l = { type: Js, receiverPublicKey: o, senderPublicKey: a };
        await this.sendError({
          id: n,
          topic: c,
          error: r,
          encodeOpts: l,
          rpcOpts: it.wc_sessionAuthenticate.reject,
          appLink: this.getAppLinkIfEnabled(
            i.requester.metadata,
            i.transportType
          ),
        }),
          await this.client.auth.requests.delete(n, {
            message: "rejected",
            code: 0,
          }),
          await this.deleteProposal(n);
      }),
      P(this, "formatAuthMessage", (t) => {
        this.isInitialized();
        const { request: n, iss: r } = t;
        return sf(n, r);
      }),
      P(this, "processRelayMessageCache", () => {
        setTimeout(async () => {
          if (this.relayMessageCache.length !== 0)
            for (; this.relayMessageCache.length > 0; )
              try {
                const t = this.relayMessageCache.shift();
                t && (await this.onRelayMessage(t));
              } catch (t) {
                this.client.logger.error(t);
              }
        }, 50);
      }),
      P(this, "cleanupDuplicatePairings", async (t) => {
        if (t.pairingTopic)
          try {
            const n = this.client.core.pairing.pairings.get(t.pairingTopic),
              r = this.client.core.pairing.pairings.getAll().filter((i) => {
                var o, a;
                return (
                  ((o = i.peerMetadata) == null ? void 0 : o.url) &&
                  ((a = i.peerMetadata) == null ? void 0 : a.url) ===
                    t.peer.metadata.url &&
                  i.topic &&
                  i.topic !== n.topic
                );
              });
            if (r.length === 0) return;
            this.client.logger.info(
              `Cleaning up ${r.length} duplicate pairing(s)`
            ),
              await Promise.all(
                r.map((i) =>
                  this.client.core.pairing.disconnect({ topic: i.topic })
                )
              ),
              this.client.logger.info("Duplicate pairings clean up finished");
          } catch (n) {
            this.client.logger.error(n);
          }
      }),
      P(this, "deleteSession", async (t) => {
        var n;
        const {
            topic: r,
            expirerHasDeleted: i = !1,
            emitEvent: o = !0,
            id: a = 0,
          } = t,
          { self: c } = this.client.session.get(r);
        await this.client.core.relayer.unsubscribe(r),
          await this.client.session.delete(r, ze("USER_DISCONNECTED")),
          this.addToRecentlyDeleted(r, "session"),
          this.client.core.crypto.keychain.has(c.publicKey) &&
            (await this.client.core.crypto.deleteKeyPair(c.publicKey)),
          this.client.core.crypto.keychain.has(r) &&
            (await this.client.core.crypto.deleteSymKey(r)),
          i || this.client.core.expirer.del(r),
          this.client.core.storage
            .removeItem(dh)
            .catch((l) => this.client.logger.warn(l)),
          this.getPendingSessionRequests().forEach((l) => {
            l.topic === r &&
              this.deletePendingSessionRequest(l.id, ze("USER_DISCONNECTED"));
          }),
          r ===
            ((n = this.sessionRequestQueue.queue[0]) == null
              ? void 0
              : n.topic) && (this.sessionRequestQueue.state = Ts.idle),
          o && this.client.events.emit("session_delete", { id: a, topic: r });
      }),
      P(this, "deleteProposal", async (t, n) => {
        if (n)
          try {
            const r = this.client.proposal.get(t),
              i = this.client.core.eventClient.getEvent({
                topic: r.pairingTopic,
              });
            i == null || i.setError($n.proposal_expired);
          } catch {}
        await Promise.all([
          this.client.proposal.delete(t, ze("USER_DISCONNECTED")),
          n ? Promise.resolve() : this.client.core.expirer.del(t),
        ]),
          this.addToRecentlyDeleted(t, "proposal");
      }),
      P(this, "deletePendingSessionRequest", async (t, n, r = !1) => {
        await Promise.all([
          this.client.pendingRequest.delete(t, n),
          r ? Promise.resolve() : this.client.core.expirer.del(t),
        ]),
          this.addToRecentlyDeleted(t, "request"),
          (this.sessionRequestQueue.queue =
            this.sessionRequestQueue.queue.filter((i) => i.id !== t)),
          r &&
            ((this.sessionRequestQueue.state = Ts.idle),
            this.client.events.emit("session_request_expire", { id: t }));
      }),
      P(this, "deletePendingAuthRequest", async (t, n, r = !1) => {
        await Promise.all([
          this.client.auth.requests.delete(t, n),
          r ? Promise.resolve() : this.client.core.expirer.del(t),
        ]);
      }),
      P(this, "setExpiry", async (t, n) => {
        this.client.session.keys.includes(t) &&
          (this.client.core.expirer.set(t, n),
          await this.client.session.update(t, { expiry: n }));
      }),
      P(this, "setProposal", async (t, n) => {
        this.client.core.expirer.set(t, st(it.wc_sessionPropose.req.ttl)),
          await this.client.proposal.set(t, n);
      }),
      P(this, "setAuthRequest", async (t, n) => {
        const { request: r, pairingTopic: i, transportType: o = We.relay } = n;
        this.client.core.expirer.set(t, r.expiryTimestamp),
          await this.client.auth.requests.set(t, {
            authPayload: r.authPayload,
            requester: r.requester,
            expiryTimestamp: r.expiryTimestamp,
            id: t,
            pairingTopic: i,
            verifyContext: r.verifyContext,
            transportType: o,
          });
      }),
      P(this, "setPendingSessionRequest", async (t) => {
        const { id: n, topic: r, params: i, verifyContext: o } = t,
          a = i.request.expiryTimestamp || st(it.wc_sessionRequest.req.ttl);
        this.client.core.expirer.set(n, a),
          await this.client.pendingRequest.set(n, {
            id: n,
            topic: r,
            params: i,
            verifyContext: o,
          });
      }),
      P(this, "sendRequest", async (t) => {
        const {
            topic: n,
            method: r,
            params: i,
            expiry: o,
            relayRpcId: a,
            clientRpcId: c,
            throwOnFailedPublish: l,
            appLink: d,
            tvf: u,
          } = t,
          p = Wn(r, i, c);
        let w;
        const g = !!d;
        try {
          const E = g ? wn : ws;
          w = await this.client.core.crypto.encode(n, p, { encoding: E });
        } catch (E) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(
              `sendRequest() -> core.crypto.encode() for topic ${n} failed`
            ),
            E)
          );
        }
        let m;
        if (EI.includes(r)) {
          const E = Os(JSON.stringify(p)),
            b = Os(w);
          m = await this.client.core.verify.register({ id: b, decryptedId: E });
        }
        const f = it[r].req;
        if (
          ((f.attestation = m),
          o && (f.ttl = o),
          a && (f.id = a),
          this.client.core.history.set(n, p),
          g)
        ) {
          const E = zo(d, n, w);
          await global.Linking.openURL(E, this.client.name);
        } else {
          const E = it[r].req;
          o && (E.ttl = o),
            a && (E.id = a),
            (E.tvf = Ot(He({}, u), { correlationId: p.id })),
            l
              ? ((E.internal = Ot(He({}, E.internal), {
                  throwOnFailedPublish: !0,
                })),
                await this.client.core.relayer.publish(n, w, E))
              : this.client.core.relayer
                  .publish(n, w, E)
                  .catch((b) => this.client.logger.error(b));
        }
        return p.id;
      }),
      P(this, "sendResult", async (t) => {
        const {
            id: n,
            topic: r,
            result: i,
            throwOnFailedPublish: o,
            encodeOpts: a,
            appLink: c,
          } = t,
          l = $a(n, i);
        let d;
        const u = c && typeof (global == null ? void 0 : global.Linking) < "u";
        try {
          const g = u ? wn : ws;
          d = await this.client.core.crypto.encode(
            r,
            l,
            Ot(He({}, a || {}), { encoding: g })
          );
        } catch (g) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(
              `sendResult() -> core.crypto.encode() for topic ${r} failed`
            ),
            g)
          );
        }
        let p, w;
        try {
          p = await this.client.core.history.get(r, n);
          const g = p.request;
          try {
            w = this.getTVFParams(n, g.params, i);
          } catch (m) {
            this.client.logger.warn(
              `sendResult() -> getTVFParams() failed: ${
                m == null ? void 0 : m.message
              }`
            );
          }
        } catch (g) {
          throw (
            (this.client.logger.error(
              `sendResult() -> history.get(${r}, ${n}) failed`
            ),
            g)
          );
        }
        if (u) {
          const g = zo(c, r, d);
          await global.Linking.openURL(g, this.client.name);
        } else {
          const g = p.request.method,
            m = it[g].res;
          (m.tvf = Ot(He({}, w), { correlationId: n })),
            o
              ? ((m.internal = Ot(He({}, m.internal), {
                  throwOnFailedPublish: !0,
                })),
                await this.client.core.relayer.publish(r, d, m))
              : this.client.core.relayer
                  .publish(r, d, m)
                  .catch((f) => this.client.logger.error(f));
        }
        await this.client.core.history.resolve(l);
      }),
      P(this, "sendError", async (t) => {
        const {
            id: n,
            topic: r,
            error: i,
            encodeOpts: o,
            rpcOpts: a,
            appLink: c,
          } = t,
          l = np(n, i);
        let d;
        const u = c && typeof (global == null ? void 0 : global.Linking) < "u";
        try {
          const w = u ? wn : ws;
          d = await this.client.core.crypto.encode(
            r,
            l,
            Ot(He({}, o || {}), { encoding: w })
          );
        } catch (w) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(
              `sendError() -> core.crypto.encode() for topic ${r} failed`
            ),
            w)
          );
        }
        let p;
        try {
          p = await this.client.core.history.get(r, n);
        } catch (w) {
          throw (
            (this.client.logger.error(
              `sendError() -> history.get(${r}, ${n}) failed`
            ),
            w)
          );
        }
        if (u) {
          const w = zo(c, r, d);
          await global.Linking.openURL(w, this.client.name);
        } else {
          const w = p.request.method,
            g = a || it[w].res;
          this.client.core.relayer.publish(r, d, g);
        }
        await this.client.core.history.resolve(l);
      }),
      P(this, "cleanup", async () => {
        const t = [],
          n = [];
        this.client.session.getAll().forEach((r) => {
          let i = !1;
          pn(r.expiry) && (i = !0),
            this.client.core.crypto.keychain.has(r.topic) || (i = !0),
            i && t.push(r.topic);
        }),
          this.client.proposal.getAll().forEach((r) => {
            pn(r.expiryTimestamp) && n.push(r.id);
          }),
          await Promise.all([
            ...t.map((r) => this.deleteSession({ topic: r })),
            ...n.map((r) => this.deleteProposal(r)),
          ]);
      }),
      P(this, "onProviderMessageEvent", async (t) => {
        !this.initialized || this.relayMessageCache.length > 0
          ? this.relayMessageCache.push(t)
          : await this.onRelayMessage(t);
      }),
      P(this, "onRelayEventRequest", async (t) => {
        this.requestQueue.queue.push(t), await this.processRequestsQueue();
      }),
      P(this, "processRequestsQueue", async () => {
        if (this.requestQueue.state === Ts.active) {
          this.client.logger.info("Request queue already active, skipping...");
          return;
        }
        for (
          this.client.logger.info(
            `Request queue starting with ${this.requestQueue.queue.length} requests`
          );
          this.requestQueue.queue.length > 0;

        ) {
          this.requestQueue.state = Ts.active;
          const t = this.requestQueue.queue.shift();
          if (t)
            try {
              await this.processRequest(t);
            } catch (n) {
              this.client.logger.warn(n);
            }
        }
        this.requestQueue.state = Ts.idle;
      }),
      P(this, "processRequest", async (t) => {
        const {
            topic: n,
            payload: r,
            attestation: i,
            transportType: o,
            encryptedId: a,
          } = t,
          c = r.method;
        if (!this.shouldIgnorePairingRequest({ topic: n, requestMethod: c }))
          switch (c) {
            case "wc_sessionPropose":
              return await this.onSessionProposeRequest({
                topic: n,
                payload: r,
                attestation: i,
                encryptedId: a,
              });
            case "wc_sessionSettle":
              return await this.onSessionSettleRequest(n, r);
            case "wc_sessionUpdate":
              return await this.onSessionUpdateRequest(n, r);
            case "wc_sessionExtend":
              return await this.onSessionExtendRequest(n, r);
            case "wc_sessionPing":
              return await this.onSessionPingRequest(n, r);
            case "wc_sessionDelete":
              return await this.onSessionDeleteRequest(n, r);
            case "wc_sessionRequest":
              return await this.onSessionRequest({
                topic: n,
                payload: r,
                attestation: i,
                encryptedId: a,
                transportType: o,
              });
            case "wc_sessionEvent":
              return await this.onSessionEventRequest(n, r);
            case "wc_sessionAuthenticate":
              return await this.onSessionAuthenticateRequest({
                topic: n,
                payload: r,
                attestation: i,
                encryptedId: a,
                transportType: o,
              });
            default:
              return this.client.logger.info(`Unsupported request method ${c}`);
          }
      }),
      P(this, "onRelayEventResponse", async (t) => {
        const { topic: n, payload: r, transportType: i } = t,
          o = (await this.client.core.history.get(n, r.id)).request.method;
        switch (o) {
          case "wc_sessionPropose":
            return this.onSessionProposeResponse(n, r, i);
          case "wc_sessionSettle":
            return this.onSessionSettleResponse(n, r);
          case "wc_sessionUpdate":
            return this.onSessionUpdateResponse(n, r);
          case "wc_sessionExtend":
            return this.onSessionExtendResponse(n, r);
          case "wc_sessionPing":
            return this.onSessionPingResponse(n, r);
          case "wc_sessionRequest":
            return this.onSessionRequestResponse(n, r);
          case "wc_sessionAuthenticate":
            return this.onSessionAuthenticateResponse(n, r);
          default:
            return this.client.logger.info(`Unsupported response method ${o}`);
        }
      }),
      P(this, "onRelayEventUnknownPayload", (t) => {
        const { topic: n } = t,
          { message: r } = F(
            "MISSING_OR_INVALID",
            `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`
          );
        throw new Error(r);
      }),
      P(this, "shouldIgnorePairingRequest", (t) => {
        const { topic: n, requestMethod: r } = t,
          i = this.expectedPairingMethodMap.get(n);
        return !i || i.includes(r)
          ? !1
          : !!(
              i.includes("wc_sessionAuthenticate") &&
              this.client.events.listenerCount("session_authenticate") > 0
            );
      }),
      P(this, "onSessionProposeRequest", async (t) => {
        const { topic: n, payload: r, attestation: i, encryptedId: o } = t,
          { params: a, id: c } = r;
        try {
          const l = this.client.core.eventClient.getEvent({ topic: n });
          this.client.events.listenerCount("session_proposal") === 0 &&
            (console.warn("No listener for session_proposal event"),
            l == null || l.setError(Gs.proposal_listener_not_found)),
            this.isValidConnect(He({}, r.params));
          const d = a.expiryTimestamp || st(it.wc_sessionPropose.req.ttl),
            u = He(
              {
                id: c,
                pairingTopic: n,
                expiryTimestamp: d,
                attestation: i,
                encryptedId: o,
              },
              a
            );
          await this.setProposal(c, u);
          const p = await this.getVerifyContext({
            attestationId: i,
            hash: Os(JSON.stringify(r)),
            encryptedId: o,
            metadata: u.proposer.metadata,
          });
          l == null || l.addTrace(Rs.emit_session_proposal),
            this.client.events.emit("session_proposal", {
              id: c,
              params: u,
              verifyContext: p,
            });
        } catch (l) {
          await this.sendError({
            id: c,
            topic: n,
            error: l,
            rpcOpts: it.wc_sessionPropose.autoReject,
          }),
            this.client.logger.error(l);
        }
      }),
      P(this, "onSessionProposeResponse", async (t, n, r) => {
        const { id: i } = n;
        if (Vs(n)) {
          const { result: o } = n;
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            result: o,
          });
          const a = this.client.proposal.get(i);
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            proposal: a,
          });
          const c = a.proposer.publicKey;
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            selfPublicKey: c,
          });
          const l = o.responderPublicKey;
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            peerPublicKey: l,
          });
          const d = await this.client.core.crypto.generateSharedKey(c, l);
          this.pendingSessions.set(i, {
            sessionTopic: d,
            pairingTopic: t,
            proposalId: i,
            publicKey: c,
          });
          const u = await this.client.core.relayer.subscribe(d, {
            transportType: r,
          });
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            subscriptionId: u,
          }),
            await this.client.core.pairing.activate({ topic: t });
        } else if (xs(n)) {
          await this.deleteProposal(i);
          const o = Oe("session_connect", i);
          if (this.events.listenerCount(o) === 0)
            throw new Error(`emitting ${o} without any listeners, 954`);
          this.events.emit(o, { error: n.error });
        }
      }),
      P(this, "onSessionSettleRequest", async (t, n) => {
        const { id: r, params: i } = n;
        try {
          this.isValidSessionSettleRequest(i);
          const {
              relay: o,
              controller: a,
              expiry: c,
              namespaces: l,
              sessionProperties: d,
              scopedProperties: u,
              sessionConfig: p,
            } = n.params,
            w = [...this.pendingSessions.values()].find(
              (f) => f.sessionTopic === t
            );
          if (!w)
            return this.client.logger.error(
              `Pending session not found for topic ${t}`
            );
          const g = this.client.proposal.get(w.proposalId),
            m = Ot(
              He(
                He(
                  He(
                    {
                      topic: t,
                      relay: o,
                      expiry: c,
                      namespaces: l,
                      acknowledged: !0,
                      pairingTopic: w.pairingTopic,
                      requiredNamespaces: g.requiredNamespaces,
                      optionalNamespaces: g.optionalNamespaces,
                      controller: a.publicKey,
                      self: {
                        publicKey: w.publicKey,
                        metadata: this.client.metadata,
                      },
                      peer: { publicKey: a.publicKey, metadata: a.metadata },
                    },
                    d && { sessionProperties: d }
                  ),
                  u && { scopedProperties: u }
                ),
                p && { sessionConfig: p }
              ),
              { transportType: We.relay }
            );
          await this.client.session.set(m.topic, m),
            await this.setExpiry(m.topic, m.expiry),
            await this.client.core.pairing.updateMetadata({
              topic: w.pairingTopic,
              metadata: m.peer.metadata,
            }),
            this.client.events.emit("session_connect", { session: m }),
            this.events.emit(Oe("session_connect", w.proposalId), {
              session: m,
            }),
            this.pendingSessions.delete(w.proposalId),
            this.deleteProposal(w.proposalId, !1),
            this.cleanupDuplicatePairings(m),
            await this.sendResult({ id: n.id, topic: t, result: !0 });
        } catch (o) {
          await this.sendError({ id: r, topic: t, error: o }),
            this.client.logger.error(o);
        }
      }),
      P(this, "onSessionSettleResponse", async (t, n) => {
        const { id: r } = n;
        Vs(n)
          ? (await this.client.session.update(t, { acknowledged: !0 }),
            this.events.emit(Oe("session_approve", r), {}))
          : xs(n) &&
            (await this.client.session.delete(t, ze("USER_DISCONNECTED")),
            this.events.emit(Oe("session_approve", r), { error: n.error }));
      }),
      P(this, "onSessionUpdateRequest", async (t, n) => {
        const { params: r, id: i } = n;
        try {
          const o = `${t}_session_update`,
            a = Ei.get(o);
          if (a && this.isRequestOutOfSync(a, i)) {
            this.client.logger.warn(`Discarding out of sync request - ${i}`),
              this.sendError({
                id: i,
                topic: t,
                error: ze("INVALID_UPDATE_REQUEST"),
              });
            return;
          }
          this.isValidUpdate(He({ topic: t }, r));
          try {
            Ei.set(o, i),
              await this.client.session.update(t, { namespaces: r.namespaces }),
              await this.sendResult({ id: i, topic: t, result: !0 });
          } catch (c) {
            throw (Ei.delete(o), c);
          }
          this.client.events.emit("session_update", {
            id: i,
            topic: t,
            params: r,
          });
        } catch (o) {
          await this.sendError({ id: i, topic: t, error: o }),
            this.client.logger.error(o);
        }
      }),
      P(
        this,
        "isRequestOutOfSync",
        (t, n) => n.toString().slice(0, -3) < t.toString().slice(0, -3)
      ),
      P(this, "onSessionUpdateResponse", (t, n) => {
        const { id: r } = n,
          i = Oe("session_update", r);
        if (this.events.listenerCount(i) === 0)
          throw new Error(`emitting ${i} without any listeners`);
        Vs(n)
          ? this.events.emit(Oe("session_update", r), {})
          : xs(n) &&
            this.events.emit(Oe("session_update", r), { error: n.error });
      }),
      P(this, "onSessionExtendRequest", async (t, n) => {
        const { id: r } = n;
        try {
          this.isValidExtend({ topic: t }),
            await this.setExpiry(t, st(Er)),
            await this.sendResult({ id: r, topic: t, result: !0 }),
            this.client.events.emit("session_extend", { id: r, topic: t });
        } catch (i) {
          await this.sendError({ id: r, topic: t, error: i }),
            this.client.logger.error(i);
        }
      }),
      P(this, "onSessionExtendResponse", (t, n) => {
        const { id: r } = n,
          i = Oe("session_extend", r);
        if (this.events.listenerCount(i) === 0)
          throw new Error(`emitting ${i} without any listeners`);
        Vs(n)
          ? this.events.emit(Oe("session_extend", r), {})
          : xs(n) &&
            this.events.emit(Oe("session_extend", r), { error: n.error });
      }),
      P(this, "onSessionPingRequest", async (t, n) => {
        const { id: r } = n;
        try {
          this.isValidPing({ topic: t }),
            await this.sendResult({
              id: r,
              topic: t,
              result: !0,
              throwOnFailedPublish: !0,
            }),
            this.client.events.emit("session_ping", { id: r, topic: t });
        } catch (i) {
          await this.sendError({ id: r, topic: t, error: i }),
            this.client.logger.error(i);
        }
      }),
      P(this, "onSessionPingResponse", (t, n) => {
        const { id: r } = n,
          i = Oe("session_ping", r);
        setTimeout(() => {
          if (this.events.listenerCount(i) === 0)
            throw new Error(`emitting ${i} without any listeners 2176`);
          Vs(n)
            ? this.events.emit(Oe("session_ping", r), {})
            : xs(n) &&
              this.events.emit(Oe("session_ping", r), { error: n.error });
        }, 500);
      }),
      P(this, "onSessionDeleteRequest", async (t, n) => {
        const { id: r } = n;
        try {
          this.isValidDisconnect({ topic: t, reason: n.params }),
            Promise.all([
              new Promise((i) => {
                this.client.core.relayer.once(ot.publish, async () => {
                  i(await this.deleteSession({ topic: t, id: r }));
                });
              }),
              this.sendResult({ id: r, topic: t, result: !0 }),
              this.cleanupPendingSentRequestsForTopic({
                topic: t,
                error: ze("USER_DISCONNECTED"),
              }),
            ]).catch((i) => this.client.logger.error(i));
        } catch (i) {
          this.client.logger.error(i);
        }
      }),
      P(this, "onSessionRequest", async (t) => {
        var n, r, i;
        const {
            topic: o,
            payload: a,
            attestation: c,
            encryptedId: l,
            transportType: d,
          } = t,
          { id: u, params: p } = a;
        try {
          await this.isValidRequest(He({ topic: o }, p));
          const w = this.client.session.get(o),
            g = await this.getVerifyContext({
              attestationId: c,
              hash: Os(JSON.stringify(Wn("wc_sessionRequest", p, u))),
              encryptedId: l,
              metadata: w.peer.metadata,
              transportType: d,
            }),
            m = { id: u, topic: o, params: p, verifyContext: g };
          await this.setPendingSessionRequest(m),
            d === We.link_mode &&
              (n = w.peer.metadata.redirect) != null &&
              n.universal &&
              this.client.core.addLinkModeSupportedApp(
                (r = w.peer.metadata.redirect) == null ? void 0 : r.universal
              ),
            (i = this.client.signConfig) != null && i.disableRequestQueue
              ? this.emitSessionRequest(m)
              : (this.addSessionRequestToSessionRequestQueue(m),
                this.processSessionRequestQueue());
        } catch (w) {
          await this.sendError({ id: u, topic: o, error: w }),
            this.client.logger.error(w);
        }
      }),
      P(this, "onSessionRequestResponse", (t, n) => {
        const { id: r } = n,
          i = Oe("session_request", r);
        if (this.events.listenerCount(i) === 0)
          throw new Error(`emitting ${i} without any listeners`);
        Vs(n)
          ? this.events.emit(Oe("session_request", r), { result: n.result })
          : xs(n) &&
            this.events.emit(Oe("session_request", r), { error: n.error });
      }),
      P(this, "onSessionEventRequest", async (t, n) => {
        const { id: r, params: i } = n;
        try {
          const o = `${t}_session_event_${i.event.name}`,
            a = Ei.get(o);
          if (a && this.isRequestOutOfSync(a, r)) {
            this.client.logger.info(`Discarding out of sync request - ${r}`);
            return;
          }
          this.isValidEmit(He({ topic: t }, i)),
            this.client.events.emit("session_event", {
              id: r,
              topic: t,
              params: i,
            }),
            Ei.set(o, r);
        } catch (o) {
          await this.sendError({ id: r, topic: t, error: o }),
            this.client.logger.error(o);
        }
      }),
      P(this, "onSessionAuthenticateResponse", (t, n) => {
        const { id: r } = n;
        this.client.logger.trace({
          type: "method",
          method: "onSessionAuthenticateResponse",
          topic: t,
          payload: n,
        }),
          Vs(n)
            ? this.events.emit(Oe("session_request", r), { result: n.result })
            : xs(n) &&
              this.events.emit(Oe("session_request", r), { error: n.error });
      }),
      P(this, "onSessionAuthenticateRequest", async (t) => {
        var n;
        const {
          topic: r,
          payload: i,
          attestation: o,
          encryptedId: a,
          transportType: c,
        } = t;
        try {
          const { requester: l, authPayload: d, expiryTimestamp: u } = i.params,
            p = await this.getVerifyContext({
              attestationId: o,
              hash: Os(JSON.stringify(i)),
              encryptedId: a,
              metadata: l.metadata,
              transportType: c,
            }),
            w = {
              requester: l,
              pairingTopic: r,
              id: i.id,
              authPayload: d,
              verifyContext: p,
              expiryTimestamp: u,
            };
          await this.setAuthRequest(i.id, {
            request: w,
            pairingTopic: r,
            transportType: c,
          }),
            c === We.link_mode &&
              (n = l.metadata.redirect) != null &&
              n.universal &&
              this.client.core.addLinkModeSupportedApp(
                l.metadata.redirect.universal
              ),
            this.client.events.emit("session_authenticate", {
              topic: r,
              params: i.params,
              id: i.id,
              verifyContext: p,
            });
        } catch (l) {
          this.client.logger.error(l);
          const d = i.params.requester.publicKey,
            u = await this.client.core.crypto.generateKeyPair(),
            p = this.getAppLinkIfEnabled(i.params.requester.metadata, c),
            w = { type: Js, receiverPublicKey: d, senderPublicKey: u };
          await this.sendError({
            id: i.id,
            topic: r,
            error: l,
            encodeOpts: w,
            rpcOpts: it.wc_sessionAuthenticate.autoReject,
            appLink: p,
          });
        }
      }),
      P(this, "addSessionRequestToSessionRequestQueue", (t) => {
        this.sessionRequestQueue.queue.push(t);
      }),
      P(this, "cleanupAfterResponse", (t) => {
        this.deletePendingSessionRequest(t.response.id, {
          message: "fulfilled",
          code: 0,
        }),
          setTimeout(() => {
            (this.sessionRequestQueue.state = Ts.idle),
              this.processSessionRequestQueue();
          }, j.toMiliseconds(this.requestQueueDelay));
      }),
      P(
        this,
        "cleanupPendingSentRequestsForTopic",
        ({ topic: t, error: n }) => {
          const r = this.client.core.history.pending;
          r.length > 0 &&
            r
              .filter(
                (i) => i.topic === t && i.request.method === "wc_sessionRequest"
              )
              .forEach((i) => {
                const o = i.request.id,
                  a = Oe("session_request", o);
                if (this.events.listenerCount(a) === 0)
                  throw new Error(`emitting ${a} without any listeners`);
                this.events.emit(Oe("session_request", i.request.id), {
                  error: n,
                });
              });
        }
      ),
      P(this, "processSessionRequestQueue", () => {
        if (this.sessionRequestQueue.state === Ts.active) {
          this.client.logger.info("session request queue is already active.");
          return;
        }
        const t = this.sessionRequestQueue.queue[0];
        if (!t) {
          this.client.logger.info("session request queue is empty.");
          return;
        }
        try {
          (this.sessionRequestQueue.state = Ts.active),
            this.emitSessionRequest(t);
        } catch (n) {
          this.client.logger.error(n);
        }
      }),
      P(this, "emitSessionRequest", (t) => {
        this.client.events.emit("session_request", t);
      }),
      P(this, "onPairingCreated", (t) => {
        if (
          (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods),
          t.active)
        )
          return;
        const n = this.client.proposal
          .getAll()
          .find((r) => r.pairingTopic === t.topic);
        n &&
          this.onSessionProposeRequest({
            topic: t.topic,
            payload: Wn(
              "wc_sessionPropose",
              Ot(He({}, n), {
                requiredNamespaces: n.requiredNamespaces,
                optionalNamespaces: n.optionalNamespaces,
                relays: n.relays,
                proposer: n.proposer,
                sessionProperties: n.sessionProperties,
                scopedProperties: n.scopedProperties,
              }),
              n.id
            ),
            attestation: n.attestation,
            encryptedId: n.encryptedId,
          });
      }),
      P(this, "isValidConnect", async (t) => {
        if (!Ut(t)) {
          const { message: l } = F(
            "MISSING_OR_INVALID",
            `connect() params: ${JSON.stringify(t)}`
          );
          throw new Error(l);
        }
        const {
          pairingTopic: n,
          requiredNamespaces: r,
          optionalNamespaces: i,
          sessionProperties: o,
          scopedProperties: a,
          relays: c,
        } = t;
        if ((pt(n) || (await this.isValidPairingTopic(n)), !iC(c))) {
          const { message: l } = F(
            "MISSING_OR_INVALID",
            `connect() relays: ${c}`
          );
          throw new Error(l);
        }
        if (!pt(r) && vn(r) !== 0) {
          const l =
            "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
          ["fatal", "error", "silent"].includes(this.client.logger.level)
            ? console.warn(l)
            : this.client.logger.warn(l),
            this.validateNamespaces(r, "requiredNamespaces");
        }
        if (
          (!pt(i) &&
            vn(i) !== 0 &&
            this.validateNamespaces(i, "optionalNamespaces"),
          pt(o) || this.validateSessionProps(o, "sessionProperties"),
          !pt(a))
        ) {
          this.validateSessionProps(a, "scopedProperties");
          const l = Object.keys(r || {}).concat(Object.keys(i || {}));
          if (!Object.keys(a).every((d) => l.includes(d)))
            throw new Error(
              `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(
                a
              )}, required/optional namespaces: ${JSON.stringify(l)}`
            );
        }
      }),
      P(this, "validateNamespaces", (t, n) => {
        const r = rC(t, "connect()", n);
        if (r) throw new Error(r.message);
      }),
      P(this, "isValidApprove", async (t) => {
        if (!Ut(t))
          throw new Error(
            F("MISSING_OR_INVALID", `approve() params: ${t}`).message
          );
        const {
          id: n,
          namespaces: r,
          relayProtocol: i,
          sessionProperties: o,
          scopedProperties: a,
        } = t;
        this.checkRecentlyDeleted(n), await this.isValidProposalId(n);
        const c = this.client.proposal.get(n),
          l = Ec(r, "approve()");
        if (l) throw new Error(l.message);
        const d = Lu(c.requiredNamespaces, r, "approve()");
        if (d) throw new Error(d.message);
        if (!Xe(i, !0)) {
          const { message: u } = F(
            "MISSING_OR_INVALID",
            `approve() relayProtocol: ${i}`
          );
          throw new Error(u);
        }
        if (
          (pt(o) || this.validateSessionProps(o, "sessionProperties"), !pt(a))
        ) {
          this.validateSessionProps(a, "scopedProperties");
          const u = new Set(Object.keys(r));
          if (!Object.keys(a).every((p) => u.has(p)))
            throw new Error(
              `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(
                a
              )}, approved namespaces: ${Array.from(u).join(", ")}`
            );
        }
      }),
      P(this, "isValidReject", async (t) => {
        if (!Ut(t)) {
          const { message: i } = F(
            "MISSING_OR_INVALID",
            `reject() params: ${t}`
          );
          throw new Error(i);
        }
        const { id: n, reason: r } = t;
        if (
          (this.checkRecentlyDeleted(n),
          await this.isValidProposalId(n),
          !aC(r))
        ) {
          const { message: i } = F(
            "MISSING_OR_INVALID",
            `reject() reason: ${JSON.stringify(r)}`
          );
          throw new Error(i);
        }
      }),
      P(this, "isValidSessionSettleRequest", (t) => {
        if (!Ut(t)) {
          const { message: l } = F(
            "MISSING_OR_INVALID",
            `onSessionSettleRequest() params: ${t}`
          );
          throw new Error(l);
        }
        const { relay: n, controller: r, namespaces: i, expiry: o } = t;
        if (!Uf(n)) {
          const { message: l } = F(
            "MISSING_OR_INVALID",
            "onSessionSettleRequest() relay protocol should be a string"
          );
          throw new Error(l);
        }
        const a = X_(r, "onSessionSettleRequest()");
        if (a) throw new Error(a.message);
        const c = Ec(i, "onSessionSettleRequest()");
        if (c) throw new Error(c.message);
        if (pn(o)) {
          const { message: l } = F("EXPIRED", "onSessionSettleRequest()");
          throw new Error(l);
        }
      }),
      P(this, "isValidUpdate", async (t) => {
        if (!Ut(t)) {
          const { message: c } = F(
            "MISSING_OR_INVALID",
            `update() params: ${t}`
          );
          throw new Error(c);
        }
        const { topic: n, namespaces: r } = t;
        this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
        const i = this.client.session.get(n),
          o = Ec(r, "update()");
        if (o) throw new Error(o.message);
        const a = Lu(i.requiredNamespaces, r, "update()");
        if (a) throw new Error(a.message);
      }),
      P(this, "isValidExtend", async (t) => {
        if (!Ut(t)) {
          const { message: r } = F(
            "MISSING_OR_INVALID",
            `extend() params: ${t}`
          );
          throw new Error(r);
        }
        const { topic: n } = t;
        this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      }),
      P(this, "isValidRequest", async (t) => {
        if (!Ut(t)) {
          const { message: c } = F(
            "MISSING_OR_INVALID",
            `request() params: ${t}`
          );
          throw new Error(c);
        }
        const { topic: n, request: r, chainId: i, expiry: o } = t;
        this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
        const { namespaces: a } = this.client.session.get(n);
        if (!Du(a, i)) {
          const { message: c } = F(
            "MISSING_OR_INVALID",
            `request() chainId: ${i}`
          );
          throw new Error(c);
        }
        if (!cC(r)) {
          const { message: c } = F(
            "MISSING_OR_INVALID",
            `request() ${JSON.stringify(r)}`
          );
          throw new Error(c);
        }
        if (!uC(a, i, r.method)) {
          const { message: c } = F(
            "MISSING_OR_INVALID",
            `request() method: ${r.method}`
          );
          throw new Error(c);
        }
        if (o && !gC(o, Sc)) {
          const { message: c } = F(
            "MISSING_OR_INVALID",
            `request() expiry: ${o}. Expiry must be a number (in seconds) between ${Sc.min} and ${Sc.max}`
          );
          throw new Error(c);
        }
      }),
      P(this, "isValidRespond", async (t) => {
        var n;
        if (!Ut(t)) {
          const { message: o } = F(
            "MISSING_OR_INVALID",
            `respond() params: ${t}`
          );
          throw new Error(o);
        }
        const { topic: r, response: i } = t;
        try {
          await this.isValidSessionTopic(r);
        } catch (o) {
          throw (
            ((n = t == null ? void 0 : t.response) != null &&
              n.id &&
              this.cleanupAfterResponse(t),
            o)
          );
        }
        if (!lC(i)) {
          const { message: o } = F(
            "MISSING_OR_INVALID",
            `respond() response: ${JSON.stringify(i)}`
          );
          throw new Error(o);
        }
      }),
      P(this, "isValidPing", async (t) => {
        if (!Ut(t)) {
          const { message: r } = F("MISSING_OR_INVALID", `ping() params: ${t}`);
          throw new Error(r);
        }
        const { topic: n } = t;
        await this.isValidSessionOrPairingTopic(n);
      }),
      P(this, "isValidEmit", async (t) => {
        if (!Ut(t)) {
          const { message: a } = F("MISSING_OR_INVALID", `emit() params: ${t}`);
          throw new Error(a);
        }
        const { topic: n, event: r, chainId: i } = t;
        await this.isValidSessionTopic(n);
        const { namespaces: o } = this.client.session.get(n);
        if (!Du(o, i)) {
          const { message: a } = F(
            "MISSING_OR_INVALID",
            `emit() chainId: ${i}`
          );
          throw new Error(a);
        }
        if (!dC(r)) {
          const { message: a } = F(
            "MISSING_OR_INVALID",
            `emit() event: ${JSON.stringify(r)}`
          );
          throw new Error(a);
        }
        if (!hC(o, i, r.name)) {
          const { message: a } = F(
            "MISSING_OR_INVALID",
            `emit() event: ${JSON.stringify(r)}`
          );
          throw new Error(a);
        }
      }),
      P(this, "isValidDisconnect", async (t) => {
        if (!Ut(t)) {
          const { message: r } = F(
            "MISSING_OR_INVALID",
            `disconnect() params: ${t}`
          );
          throw new Error(r);
        }
        const { topic: n } = t;
        await this.isValidSessionOrPairingTopic(n);
      }),
      P(this, "isValidAuthenticate", (t) => {
        const { chains: n, uri: r, domain: i, nonce: o } = t;
        if (!Array.isArray(n) || n.length === 0)
          throw new Error("chains is required and must be a non-empty array");
        if (!Xe(r, !1)) throw new Error("uri is required parameter");
        if (!Xe(i, !1)) throw new Error("domain is required parameter");
        if (!Xe(o, !1)) throw new Error("nonce is required parameter");
        if ([...new Set(n.map((c) => Fr(c).namespace))].length > 1)
          throw new Error(
            "Multi-namespace requests are not supported. Please request single namespace only."
          );
        const { namespace: a } = Fr(n[0]);
        if (a !== "eip155")
          throw new Error(
            "Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains."
          );
      }),
      P(this, "getVerifyContext", async (t) => {
        const {
            attestationId: n,
            hash: r,
            encryptedId: i,
            metadata: o,
            transportType: a,
          } = t,
          c = {
            verified: {
              verifyUrl: o.verifyUrl || Hi,
              validation: "UNKNOWN",
              origin: o.url || "",
            },
          };
        try {
          if (a === We.link_mode) {
            const d = this.getAppLinkIfEnabled(o, a);
            return (
              (c.verified.validation =
                d && new URL(d).origin === new URL(o.url).origin
                  ? "VALID"
                  : "INVALID"),
              c
            );
          }
          const l = await this.client.core.verify.resolve({
            attestationId: n,
            hash: r,
            encryptedId: i,
            verifyUrl: o.verifyUrl,
          });
          l &&
            ((c.verified.origin = l.origin),
            (c.verified.isScam = l.isScam),
            (c.verified.validation =
              l.origin === new URL(o.url).origin ? "VALID" : "INVALID"));
        } catch (l) {
          this.client.logger.warn(l);
        }
        return (
          this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`), c
        );
      }),
      P(this, "validateSessionProps", (t, n) => {
        Object.values(t).forEach((r, i) => {
          if (r == null) {
            const { message: o } = F(
              "MISSING_OR_INVALID",
              `${n} must contain an existing value for each key. Received: ${r} for key ${
                Object.keys(t)[i]
              }`
            );
            throw new Error(o);
          }
        });
      }),
      P(this, "getPendingAuthRequest", (t) => {
        const n = this.client.auth.requests.get(t);
        return typeof n == "object" ? n : void 0;
      }),
      P(this, "addToRecentlyDeleted", (t, n) => {
        if (
          (this.recentlyDeletedMap.set(t, n),
          this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
        ) {
          let r = 0;
          const i = this.recentlyDeletedLimit / 2;
          for (const o of this.recentlyDeletedMap.keys()) {
            if (r++ >= i) break;
            this.recentlyDeletedMap.delete(o);
          }
        }
      }),
      P(this, "checkRecentlyDeleted", (t) => {
        const n = this.recentlyDeletedMap.get(t);
        if (n) {
          const { message: r } = F(
            "MISSING_OR_INVALID",
            `Record was recently deleted - ${n}: ${t}`
          );
          throw new Error(r);
        }
      }),
      P(this, "isLinkModeEnabled", (t, n) => {
        var r, i, o, a, c, l, d, u, p;
        return !t || n !== We.link_mode
          ? !1
          : ((i = (r = this.client.metadata) == null ? void 0 : r.redirect) ==
            null
              ? void 0
              : i.linkMode) === !0 &&
              ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) ==
              null
                ? void 0
                : a.universal) !== void 0 &&
              ((l = (c = this.client.metadata) == null ? void 0 : c.redirect) ==
              null
                ? void 0
                : l.universal) !== "" &&
              ((d = t == null ? void 0 : t.redirect) == null
                ? void 0
                : d.universal) !== void 0 &&
              ((u = t == null ? void 0 : t.redirect) == null
                ? void 0
                : u.universal) !== "" &&
              ((p = t == null ? void 0 : t.redirect) == null
                ? void 0
                : p.linkMode) === !0 &&
              this.client.core.linkModeSupportedApps.includes(
                t.redirect.universal
              ) &&
              typeof (global == null ? void 0 : global.Linking) < "u";
      }),
      P(this, "getAppLinkIfEnabled", (t, n) => {
        var r;
        return this.isLinkModeEnabled(t, n)
          ? (r = t == null ? void 0 : t.redirect) == null
            ? void 0
            : r.universal
          : void 0;
      }),
      P(this, "handleLinkModeMessage", ({ url: t }) => {
        if (!t || !t.includes("wc_ev") || !t.includes("topic")) return;
        const n = Zd(t, "topic") || "",
          r = decodeURIComponent(Zd(t, "wc_ev") || ""),
          i = this.client.session.keys.includes(n);
        i && this.client.session.update(n, { transportType: We.link_mode }),
          this.client.core.dispatchEnvelope({
            topic: n,
            message: r,
            sessionExists: i,
          });
      }),
      P(this, "registerLinkModeListeners", async () => {
        var t;
        if (
          Gl() ||
          (kn() && (t = this.client.metadata.redirect) != null && t.linkMode)
        ) {
          const n = global == null ? void 0 : global.Linking;
          if (typeof n < "u") {
            n.addEventListener(
              "url",
              this.handleLinkModeMessage,
              this.client.name
            );
            const r = await n.getInitialURL();
            r &&
              setTimeout(() => {
                this.handleLinkModeMessage({ url: r });
              }, 50);
          }
        }
      }),
      P(this, "getTVFParams", (t, n, r) => {
        var i, o, a;
        if (!((i = n.request) != null && i.method)) return {};
        const c = {
          correlationId: t,
          rpcMethods: [n.request.method],
          chainId: n.chainId,
        };
        try {
          const l = this.extractTxHashesFromResult(n.request, r);
          (c.txHashes = l),
            (c.contractAddresses = this.isValidContractData(n.request.params)
              ? [
                  (a = (o = n.request.params) == null ? void 0 : o[0]) == null
                    ? void 0
                    : a.to,
                ]
              : []);
        } catch (l) {
          this.client.logger.warn("Error getting TVF params", l);
        }
        return c;
      }),
      P(this, "isValidContractData", (t) => {
        var n;
        if (!t) return !1;
        try {
          const r =
            (t == null ? void 0 : t.data) ||
            ((n = t == null ? void 0 : t[0]) == null ? void 0 : n.data);
          if (!r.startsWith("0x")) return !1;
          const i = r.slice(2);
          return /^[0-9a-fA-F]*$/.test(i) ? i.length % 2 === 0 : !1;
        } catch {}
        return !1;
      }),
      P(this, "extractTxHashesFromResult", (t, n) => {
        var r;
        try {
          if (!n) return [];
          const i = t.method,
            o = wI[i];
          if (i === "sui_signTransaction") return [Mb(n.transactionBytes)];
          if (i === "near_signTransaction") return [ru(n)];
          if (i === "near_signTransactions") return n.map((c) => ru(c));
          if (i === "xrpl_signTransactionFor" || i === "xrpl_signTransaction")
            return [(r = n.tx_json) == null ? void 0 : r.hash];
          if (i === "polkadot_signTransaction")
            return [
              xC({
                transaction: t.params.transactionPayload,
                signature: n.signature,
              }),
            ];
          if (i === "algo_signTxn")
            return Xs(n) ? n.map((c) => iu(c)) : [iu(n)];
          if (i === "cosmos_signDirect") return [Fb(n)];
          if (typeof n == "string") return [n];
          const a = n[o.key];
          if (Xs(a))
            return i === "solana_signAllTransactions" ? a.map((c) => Lb(c)) : a;
          if (typeof a == "string") return [a];
        } catch (i) {
          this.client.logger.warn("Error extracting tx hashes from result", i);
        }
        return [];
      });
  }
  async processPendingMessageEvents() {
    try {
      const e = this.client.session.keys,
        t = this.client.core.relayer.messages.getWithoutAck(e);
      for (const [n, r] of Object.entries(t))
        for (const i of r)
          try {
            await this.onProviderMessageEvent({
              topic: n,
              message: i,
              publishedAt: Date.now(),
            });
          } catch {
            this.client.logger.warn(
              `Error processing pending message event for topic: ${n}, message: ${i}`
            );
          }
    } catch (e) {
      this.client.logger.warn("processPendingMessageEvents failed", e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(ot.message, (e) => {
      this.onProviderMessageEvent(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: t, message: n, attestation: r, transportType: i } = e,
      { publicKey: o } = this.client.auth.authKeys.keys.includes(sa)
        ? this.client.auth.authKeys.get(sa)
        : { publicKey: void 0 };
    try {
      const a = await this.client.core.crypto.decode(t, n, {
        receiverPublicKey: o,
        encoding: i === We.link_mode ? wn : ws,
      });
      Ll(a)
        ? (this.client.core.history.set(t, a),
          await this.onRelayEventRequest({
            topic: t,
            payload: a,
            attestation: r,
            transportType: i,
            encryptedId: Os(n),
          }))
        : Ml(a)
        ? (await this.client.core.history.resolve(a),
          await this.onRelayEventResponse({
            topic: t,
            payload: a,
            transportType: i,
          }),
          this.client.core.history.delete(t, a.id))
        : await this.onRelayEventUnknownPayload({
            topic: t,
            payload: a,
            transportType: i,
          }),
        await this.client.core.relayer.messages.ack(t, n);
    } catch (a) {
      this.client.logger.error(a);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(ns.expired, async (e) => {
      const { topic: t, id: n } = jp(e.target);
      if (n && this.client.pendingRequest.keys.includes(n))
        return await this.deletePendingSessionRequest(n, F("EXPIRED"), !0);
      if (n && this.client.auth.requests.keys.includes(n))
        return await this.deletePendingAuthRequest(n, F("EXPIRED"), !0);
      t
        ? this.client.session.keys.includes(t) &&
          (await this.deleteSession({ topic: t, expirerHasDeleted: !0 }),
          this.client.events.emit("session_expire", { topic: t }))
        : n &&
          (await this.deleteProposal(n, !0),
          this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(qn.create, (e) =>
      this.onPairingCreated(e)
    ),
      this.client.core.pairing.events.on(qn.delete, (e) => {
        this.addToRecentlyDeleted(e.topic, "pairing");
      });
  }
  isValidPairingTopic(e) {
    if (!Xe(e, !1)) {
      const { message: t } = F(
        "MISSING_OR_INVALID",
        `pairing topic should be a string: ${e}`
      );
      throw new Error(t);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: t } = F(
        "NO_MATCHING_KEY",
        `pairing topic doesn't exist: ${e}`
      );
      throw new Error(t);
    }
    if (pn(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: t } = F("EXPIRED", `pairing topic: ${e}`);
      throw new Error(t);
    }
  }
  async isValidSessionTopic(e) {
    if (!Xe(e, !1)) {
      const { message: t } = F(
        "MISSING_OR_INVALID",
        `session topic should be a string: ${e}`
      );
      throw new Error(t);
    }
    if ((this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e))) {
      const { message: t } = F(
        "NO_MATCHING_KEY",
        `session topic doesn't exist: ${e}`
      );
      throw new Error(t);
    }
    if (pn(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: t } = F("EXPIRED", `session topic: ${e}`);
      throw new Error(t);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: t } = F(
        "MISSING_OR_INVALID",
        `session topic does not exist in keychain: ${e}`
      );
      throw (await this.deleteSession({ topic: e }), new Error(t));
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if ((this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (Xe(e, !1)) {
      const { message: t } = F(
        "NO_MATCHING_KEY",
        `session or pairing topic doesn't exist: ${e}`
      );
      throw new Error(t);
    } else {
      const { message: t } = F(
        "MISSING_OR_INVALID",
        `session or pairing topic should be a string: ${e}`
      );
      throw new Error(t);
    }
  }
  async isValidProposalId(e) {
    if (!oC(e)) {
      const { message: t } = F(
        "MISSING_OR_INVALID",
        `proposal id should be a number: ${e}`
      );
      throw new Error(t);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: t } = F(
        "NO_MATCHING_KEY",
        `proposal id doesn't exist: ${e}`
      );
      throw new Error(t);
    }
    if (pn(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: t } = F("EXPIRED", `proposal id: ${e}`);
      throw new Error(t);
    }
  }
}
class PI extends hr {
  constructor(e, t) {
    super(e, t, fI, cd), (this.core = e), (this.logger = t);
  }
}
let OI = class extends hr {
  constructor(e, t) {
    super(e, t, gI, cd), (this.core = e), (this.logger = t);
  }
};
class kI extends hr {
  constructor(e, t) {
    super(e, t, yI, cd, (n) => n.id), (this.core = e), (this.logger = t);
  }
}
class UI extends hr {
  constructor(e, t) {
    super(e, t, CI, Va, () => sa), (this.core = e), (this.logger = t);
  }
}
class $I extends hr {
  constructor(e, t) {
    super(e, t, vI, Va), (this.core = e), (this.logger = t);
  }
}
class DI extends hr {
  constructor(e, t) {
    super(e, t, AI, Va, (n) => n.id), (this.core = e), (this.logger = t);
  }
}
var LI = Object.defineProperty,
  MI = (s, e, t) =>
    e in s
      ? LI(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Nc = (s, e, t) => MI(s, typeof e != "symbol" ? e + "" : e, t);
class BI {
  constructor(e, t) {
    (this.core = e),
      (this.logger = t),
      Nc(this, "authKeys"),
      Nc(this, "pairingTopics"),
      Nc(this, "requests"),
      (this.authKeys = new UI(this.core, this.logger)),
      (this.pairingTopics = new $I(this.core, this.logger)),
      (this.requests = new DI(this.core, this.logger));
  }
  async init() {
    await this.authKeys.init(),
      await this.pairingTopics.init(),
      await this.requests.init();
  }
}
var FI = Object.defineProperty,
  jI = (s, e, t) =>
    e in s
      ? FI(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  _e = (s, e, t) => jI(s, typeof e != "symbol" ? e + "" : e, t);
let qI = class tg extends Uw {
  constructor(e) {
    super(e),
      _e(this, "protocol", Xf),
      _e(this, "version", Qf),
      _e(this, "name", Ic.name),
      _e(this, "metadata"),
      _e(this, "core"),
      _e(this, "logger"),
      _e(this, "events", new cr.EventEmitter()),
      _e(this, "engine"),
      _e(this, "session"),
      _e(this, "proposal"),
      _e(this, "pendingRequest"),
      _e(this, "auth"),
      _e(this, "signConfig"),
      _e(this, "on", (n, r) => this.events.on(n, r)),
      _e(this, "once", (n, r) => this.events.once(n, r)),
      _e(this, "off", (n, r) => this.events.off(n, r)),
      _e(this, "removeListener", (n, r) => this.events.removeListener(n, r)),
      _e(this, "removeAllListeners", (n) => this.events.removeAllListeners(n)),
      _e(this, "connect", async (n) => {
        try {
          return await this.engine.connect(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "pair", async (n) => {
        try {
          return await this.engine.pair(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "approve", async (n) => {
        try {
          return await this.engine.approve(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "reject", async (n) => {
        try {
          return await this.engine.reject(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "update", async (n) => {
        try {
          return await this.engine.update(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "extend", async (n) => {
        try {
          return await this.engine.extend(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "request", async (n) => {
        try {
          return await this.engine.request(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "respond", async (n) => {
        try {
          return await this.engine.respond(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "ping", async (n) => {
        try {
          return await this.engine.ping(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "emit", async (n) => {
        try {
          return await this.engine.emit(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "disconnect", async (n) => {
        try {
          return await this.engine.disconnect(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "find", (n) => {
        try {
          return this.engine.find(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "getPendingSessionRequests", () => {
        try {
          return this.engine.getPendingSessionRequests();
        } catch (n) {
          throw (this.logger.error(n.message), n);
        }
      }),
      _e(this, "authenticate", async (n, r) => {
        try {
          return await this.engine.authenticate(n, r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      _e(this, "formatAuthMessage", (n) => {
        try {
          return this.engine.formatAuthMessage(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "approveSessionAuthenticate", async (n) => {
        try {
          return await this.engine.approveSessionAuthenticate(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      _e(this, "rejectSessionAuthenticate", async (n) => {
        try {
          return await this.engine.rejectSessionAuthenticate(n);
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      (this.name = (e == null ? void 0 : e.name) || Ic.name),
      (this.metadata = xE(e == null ? void 0 : e.metadata)),
      (this.signConfig = e == null ? void 0 : e.signConfig);
    const t =
      typeof (e == null ? void 0 : e.logger) < "u" &&
      typeof (e == null ? void 0 : e.logger) != "string"
        ? e.logger
        : Dl(ti({ level: (e == null ? void 0 : e.logger) || Ic.logger }));
    (this.core = (e == null ? void 0 : e.core) || new pI(e)),
      (this.logger = _t(t, this.name)),
      (this.session = new OI(this.core, this.logger)),
      (this.proposal = new PI(this.core, this.logger)),
      (this.pendingRequest = new kI(this.core, this.logger)),
      (this.engine = new xI(this)),
      (this.auth = new BI(this.core, this.logger));
  }
  static async init(e) {
    const t = new tg(e);
    return await t.initialize(), t;
  }
  get context() {
    return Yt(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(),
        await this.session.init(),
        await this.proposal.init(),
        await this.pendingRequest.init(),
        await this.auth.init(),
        await this.engine.init(),
        this.logger.info("SignClient Initialization Success"),
        setTimeout(() => {
          this.engine.processRelayMessageCache();
        }, j.toMiliseconds(j.ONE_SECOND));
    } catch (e) {
      throw (
        (this.logger.info("SignClient Initialization Failure"),
        this.logger.error(e.message),
        e)
      );
    }
  }
};
const ph = "error",
  HI = "wss://relay.walletconnect.org",
  WI = "wc",
  zI = "universal_provider",
  Ko = `${WI}@2:${zI}:`,
  sg = "https://rpc.walletconnect.org/v1/",
  Or = "generic",
  VI = `${sg}bundler`,
  ls = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function ld(s) {
  return s == null || (typeof s != "object" && typeof s != "function");
}
function ng(s) {
  return Object.getOwnPropertySymbols(s).filter((e) =>
    Object.prototype.propertyIsEnumerable.call(s, e)
  );
}
function rg(s) {
  return s == null
    ? s === void 0
      ? "[object Undefined]"
      : "[object Null]"
    : Object.prototype.toString.call(s);
}
const KI = "[object RegExp]",
  ig = "[object String]",
  og = "[object Number]",
  ag = "[object Boolean]",
  cg = "[object Arguments]",
  GI = "[object Symbol]",
  YI = "[object Date]",
  ZI = "[object Map]",
  JI = "[object Set]",
  XI = "[object Array]",
  QI = "[object ArrayBuffer]",
  eS = "[object Object]",
  tS = "[object DataView]",
  sS = "[object Uint8Array]",
  nS = "[object Uint8ClampedArray]",
  rS = "[object Uint16Array]",
  iS = "[object Uint32Array]",
  oS = "[object Int8Array]",
  aS = "[object Int16Array]",
  cS = "[object Int32Array]",
  lS = "[object Float32Array]",
  dS = "[object Float64Array]";
function dd(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function uS(s, e) {
  return Mr(s, void 0, s, new Map(), e);
}
function Mr(s, e, t, n = new Map(), r = void 0) {
  const i = r == null ? void 0 : r(s, e, t, n);
  if (i != null) return i;
  if (ld(s)) return s;
  if (n.has(s)) return n.get(s);
  if (Array.isArray(s)) {
    const o = new Array(s.length);
    n.set(s, o);
    for (let a = 0; a < s.length; a++) o[a] = Mr(s[a], a, t, n, r);
    return (
      Object.hasOwn(s, "index") && (o.index = s.index),
      Object.hasOwn(s, "input") && (o.input = s.input),
      o
    );
  }
  if (s instanceof Date) return new Date(s.getTime());
  if (s instanceof RegExp) {
    const o = new RegExp(s.source, s.flags);
    return (o.lastIndex = s.lastIndex), o;
  }
  if (s instanceof Map) {
    const o = new Map();
    n.set(s, o);
    for (const [a, c] of s) o.set(a, Mr(c, a, t, n, r));
    return o;
  }
  if (s instanceof Set) {
    const o = new Set();
    n.set(s, o);
    for (const a of s) o.add(Mr(a, void 0, t, n, r));
    return o;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(s)) return s.subarray();
  if (dd(s)) {
    const o = new (Object.getPrototypeOf(s).constructor)(s.length);
    n.set(s, o);
    for (let a = 0; a < s.length; a++) o[a] = Mr(s[a], a, t, n, r);
    return o;
  }
  if (
    s instanceof ArrayBuffer ||
    (typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer)
  )
    return s.slice(0);
  if (s instanceof DataView) {
    const o = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
    return n.set(s, o), Hn(o, s, t, n, r), o;
  }
  if (typeof File < "u" && s instanceof File) {
    const o = new File([s], s.name, { type: s.type });
    return n.set(s, o), Hn(o, s, t, n, r), o;
  }
  if (s instanceof Blob) {
    const o = new Blob([s], { type: s.type });
    return n.set(s, o), Hn(o, s, t, n, r), o;
  }
  if (s instanceof Error) {
    const o = new s.constructor();
    return (
      n.set(s, o),
      (o.message = s.message),
      (o.name = s.name),
      (o.stack = s.stack),
      (o.cause = s.cause),
      Hn(o, s, t, n, r),
      o
    );
  }
  if (typeof s == "object" && hS(s)) {
    const o = Object.create(Object.getPrototypeOf(s));
    return n.set(s, o), Hn(o, s, t, n, r), o;
  }
  return s;
}
function Hn(s, e, t = s, n, r) {
  const i = [...Object.keys(e), ...ng(e)];
  for (let o = 0; o < i.length; o++) {
    const a = i[o],
      c = Object.getOwnPropertyDescriptor(s, a);
    (c == null || c.writable) && (s[a] = Mr(e[a], a, t, n, r));
  }
}
function hS(s) {
  switch (rg(s)) {
    case cg:
    case XI:
    case QI:
    case tS:
    case ag:
    case YI:
    case lS:
    case dS:
    case oS:
    case aS:
    case cS:
    case ZI:
    case og:
    case eS:
    case KI:
    case JI:
    case ig:
    case GI:
    case sS:
    case nS:
    case rS:
    case iS:
      return !0;
    default:
      return !1;
  }
}
function pS(s, e) {
  return uS(s, (t, n, r, i) => {
    if (typeof s == "object")
      switch (Object.prototype.toString.call(s)) {
        case og:
        case ig:
        case ag: {
          const o = new s.constructor(s == null ? void 0 : s.valueOf());
          return Hn(o, s), o;
        }
        case cg: {
          const o = {};
          return (
            Hn(o, s),
            (o.length = s.length),
            (o[Symbol.iterator] = s[Symbol.iterator]),
            o
          );
        }
        default:
          return;
      }
  });
}
function fh(s) {
  return pS(s);
}
function gh(s) {
  return s !== null && typeof s == "object" && rg(s) === "[object Arguments]";
}
function mh(s) {
  return typeof s == "object" && s !== null;
}
function fS() {}
function gS(s) {
  return dd(s);
}
function mS(s) {
  var t;
  if (typeof s != "object" || s == null) return !1;
  if (Object.getPrototypeOf(s) === null) return !0;
  if (Object.prototype.toString.call(s) !== "[object Object]") {
    const n = s[Symbol.toStringTag];
    return n == null ||
      !(
        (t = Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)) != null &&
        t.writable
      )
      ? !1
      : s.toString() === `[object ${n}]`;
  }
  let e = s;
  for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(s) === e;
}
function wS(s) {
  if (ld(s)) return s;
  if (
    Array.isArray(s) ||
    dd(s) ||
    s instanceof ArrayBuffer ||
    (typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer)
  )
    return s.slice(0);
  const e = Object.getPrototypeOf(s),
    t = e.constructor;
  if (s instanceof Date || s instanceof Map || s instanceof Set)
    return new t(s);
  if (s instanceof RegExp) {
    const n = new t(s);
    return (n.lastIndex = s.lastIndex), n;
  }
  if (s instanceof DataView) return new t(s.buffer.slice(0));
  if (s instanceof Error) {
    const n = new t(s.message);
    return (n.stack = s.stack), (n.name = s.name), (n.cause = s.cause), n;
  }
  if (typeof File < "u" && s instanceof File)
    return new t([s], s.name, { type: s.type, lastModified: s.lastModified });
  if (typeof s == "object") {
    const n = Object.create(e);
    return Object.assign(n, s);
  }
  return s;
}
function yS(s, ...e) {
  const t = e.slice(0, -1),
    n = e[e.length - 1];
  let r = s;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    r = Al(r, o, n, new Map());
  }
  return r;
}
function Al(s, e, t, n) {
  if ((ld(s) && (s = Object(s)), e == null || typeof e != "object")) return s;
  if (n.has(e)) return wS(n.get(e));
  if ((n.set(e, s), Array.isArray(e))) {
    e = e.slice();
    for (let i = 0; i < e.length; i++) e[i] = e[i] ?? void 0;
  }
  const r = [...Object.keys(e), ...ng(e)];
  for (let i = 0; i < r.length; i++) {
    const o = r[i];
    let a = e[o],
      c = s[o];
    if (
      (gh(a) && (a = { ...a }),
      gh(c) && (c = { ...c }),
      typeof Buffer < "u" && Buffer.isBuffer(a) && (a = fh(a)),
      Array.isArray(a))
    )
      if (typeof c == "object" && c != null) {
        const d = [],
          u = Reflect.ownKeys(c);
        for (let p = 0; p < u.length; p++) {
          const w = u[p];
          d[w] = c[w];
        }
        c = d;
      } else c = [];
    const l = t(c, a, o, s, e, n);
    l != null
      ? (s[o] = l)
      : Array.isArray(a) || (mh(c) && mh(a))
      ? (s[o] = Al(c, a, t, n))
      : c == null && mS(a)
      ? (s[o] = Al({}, a, t, n))
      : c == null && gS(a)
      ? (s[o] = fh(a))
      : (c === void 0 || a !== void 0) && (s[o] = a);
  }
  return s;
}
function ES(s, ...e) {
  return yS(s, ...e, fS);
}
var bS = Object.defineProperty,
  _S = Object.defineProperties,
  CS = Object.getOwnPropertyDescriptors,
  wh = Object.getOwnPropertySymbols,
  vS = Object.prototype.hasOwnProperty,
  AS = Object.prototype.propertyIsEnumerable,
  yh = (s, e, t) =>
    e in s
      ? bS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Go = (s, e) => {
    for (var t in e || (e = {})) vS.call(e, t) && yh(s, t, e[t]);
    if (wh) for (var t of wh(e)) AS.call(e, t) && yh(s, t, e[t]);
    return s;
  },
  IS = (s, e) => _S(s, CS(e));
function Gt(s, e, t) {
  var n;
  const r = Fr(s);
  return (
    ((n = e.rpcMap) == null ? void 0 : n[r.reference]) ||
    `${sg}?chainId=${r.namespace}:${r.reference}&projectId=${t}`
  );
}
function pr(s) {
  return s.includes(":") ? s.split(":")[1] : s;
}
function lg(s) {
  return s.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function SS(s, e) {
  const t = Object.keys(e.namespaces).filter((r) => r.includes(s));
  if (!t.length) return [];
  const n = [];
  return (
    t.forEach((r) => {
      const i = e.namespaces[r].accounts;
      n.push(...i);
    }),
    n
  );
}
function Yo(s = {}, e = {}) {
  const t = Eh(s),
    n = Eh(e);
  return ES(t, n);
}
function Eh(s) {
  var e, t, n, r, i;
  const o = {};
  if (!vn(s)) return o;
  for (const [a, c] of Object.entries(s)) {
    const l = Wa(a) ? [a] : c.chains,
      d = c.methods || [],
      u = c.events || [],
      p = c.rpcMap || {},
      w = Lr(a);
    (o[w] = IS(Go(Go({}, o[w]), c), {
      chains: Ds(l, (e = o[w]) == null ? void 0 : e.chains),
      methods: Ds(d, (t = o[w]) == null ? void 0 : t.methods),
      events: Ds(u, (n = o[w]) == null ? void 0 : n.events),
    })),
      (vn(p) || vn(((r = o[w]) == null ? void 0 : r.rpcMap) || {})) &&
        (o[w].rpcMap = Go(Go({}, p), (i = o[w]) == null ? void 0 : i.rpcMap));
  }
  return o;
}
function bh(s) {
  return s.includes(":") ? s.split(":")[2] : s;
}
function _h(s) {
  const e = {};
  for (const [t, n] of Object.entries(s)) {
    const r = n.methods || [],
      i = n.events || [],
      o = n.accounts || [],
      a = Wa(t) ? [t] : n.chains ? n.chains : lg(n.accounts);
    e[t] = { chains: a, methods: r, events: i, accounts: o };
  }
  return e;
}
function Tc(s) {
  return typeof s == "number"
    ? s
    : s.includes("0x")
    ? parseInt(s, 16)
    : ((s = s.includes(":") ? s.split(":")[1] : s),
      isNaN(Number(s)) ? s : Number(s));
}
const dg = {},
  Re = (s) => dg[s],
  Rc = (s, e) => {
    dg[s] = e;
  };
var NS = Object.defineProperty,
  TS = (s, e, t) =>
    e in s
      ? NS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  br = (s, e, t) => TS(s, typeof e != "symbol" ? e + "" : e, t);
class RS {
  constructor(e) {
    br(this, "name", "polkadot"),
      br(this, "client"),
      br(this, "httpProviders"),
      br(this, "events"),
      br(this, "namespace"),
      br(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t),
      (this.chainId = e),
      this.events.emit(ls.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? e
          .filter((t) => t.split(":")[1] === this.chainId.toString())
          .map((t) => t.split(":")[2]) || []
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        var n;
        const r = pr(t);
        e[r] = this.createHttpProvider(
          r,
          (n = this.namespace.rpcMap) == null ? void 0 : n[t]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || Gt(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Re("disableProviderPing")));
  }
}
var xS = Object.defineProperty,
  PS = Object.defineProperties,
  OS = Object.getOwnPropertyDescriptors,
  Ch = Object.getOwnPropertySymbols,
  kS = Object.prototype.hasOwnProperty,
  US = Object.prototype.propertyIsEnumerable,
  Il = (s, e, t) =>
    e in s
      ? xS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  vh = (s, e) => {
    for (var t in e || (e = {})) kS.call(e, t) && Il(s, t, e[t]);
    if (Ch) for (var t of Ch(e)) US.call(e, t) && Il(s, t, e[t]);
    return s;
  },
  Ah = (s, e) => PS(s, OS(e)),
  _r = (s, e, t) => Il(s, typeof e != "symbol" ? e + "" : e, t);
class $S {
  constructor(e) {
    _r(this, "name", "eip155"),
      _r(this, "client"),
      _r(this, "chainId"),
      _r(this, "namespace"),
      _r(this, "httpProviders"),
      _r(this, "events"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.httpProviders = this.createHttpProviders()),
      (this.chainId = parseInt(this.getDefaultChain()));
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e);
    }
    return this.namespace.methods.includes(e.request.method)
      ? await this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), t),
      (this.chainId = parseInt(e)),
      this.events.emit(ls.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, t) {
    const n =
      t || Gt(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Re("disableProviderPing")));
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        var n;
        const r = parseInt(pr(t));
        e[r] = this.createHttpProvider(
          r,
          (n = this.namespace.rpcMap) == null ? void 0 : n[t]
        );
      }),
      e
    );
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((t) => t.split(":")[1] === this.chainId.toString())
              .map((t) => t.split(":")[2])
          ),
        ]
      : [];
  }
  getHttpProvider() {
    const e = this.chainId,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  async handleSwitchChain(e) {
    var t, n;
    let r = e.request.params
      ? (t = e.request.params[0]) == null
        ? void 0
        : t.chainId
      : "0x0";
    r = r.startsWith("0x") ? r : `0x${r}`;
    const i = parseInt(r, 16);
    if (this.isChainApproved(i)) this.setDefaultChain(`${i}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
      await this.client.request({
        topic: e.topic,
        request: { method: e.request.method, params: [{ chainId: r }] },
        chainId: (n = this.namespace.chains) == null ? void 0 : n[0],
      }),
        this.setDefaultChain(`${i}`);
    else
      throw new Error(
        `Failed to switch to chain 'eip155:${i}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
      );
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
  async getCapabilities(e) {
    var t, n, r, i, o;
    const a =
        (n = (t = e.request) == null ? void 0 : t.params) == null
          ? void 0
          : n[0],
      c =
        ((i = (r = e.request) == null ? void 0 : r.params) == null
          ? void 0
          : i[1]) || [],
      l = `${a}${c.join(",")}`;
    if (!a)
      throw new Error(
        "Missing address parameter in `wallet_getCapabilities` request"
      );
    const d = this.client.session.get(e.topic),
      u =
        ((o = d == null ? void 0 : d.sessionProperties) == null
          ? void 0
          : o.capabilities) || {};
    if (u != null && u[l]) return u == null ? void 0 : u[l];
    const p = await this.client.request(e);
    try {
      await this.client.session.update(e.topic, {
        sessionProperties: Ah(vh({}, d.sessionProperties || {}), {
          capabilities: Ah(vh({}, u || {}), { [l]: p }),
        }),
      });
    } catch (w) {
      console.warn("Failed to update session with capabilities", w);
    }
    return p;
  }
  async getCallStatus(e) {
    var t, n;
    const r = this.client.session.get(e.topic),
      i = (t = r.sessionProperties) == null ? void 0 : t.bundler_name;
    if (i) {
      const a = this.getBundlerUrl(e.chainId, i);
      try {
        return await this.getUserOperationReceipt(a, e);
      } catch (c) {
        console.warn("Failed to fetch call status from bundler", c, a);
      }
    }
    const o = (n = r.sessionProperties) == null ? void 0 : n.bundler_url;
    if (o)
      try {
        return await this.getUserOperationReceipt(o, e);
      } catch (a) {
        console.warn("Failed to fetch call status from custom bundler", a, o);
      }
    if (this.namespace.methods.includes(e.request.method))
      return await this.client.request(e);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e, t) {
    var n;
    const r = new URL(e),
      i = await fetch(r, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(
          Wn("eth_getUserOperationReceipt", [
            (n = t.request.params) == null ? void 0 : n[0],
          ])
        ),
      });
    if (!i.ok)
      throw new Error(`Failed to fetch user operation receipt - ${i.status}`);
    return await i.json();
  }
  getBundlerUrl(e, t) {
    return `${VI}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;
  }
}
var DS = Object.defineProperty,
  LS = (s, e, t) =>
    e in s
      ? DS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Cr = (s, e, t) => LS(s, typeof e != "symbol" ? e + "" : e, t);
class MS {
  constructor(e) {
    Cr(this, "name", "solana"),
      Cr(this, "client"),
      Cr(this, "httpProviders"),
      Cr(this, "events"),
      Cr(this, "namespace"),
      Cr(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t),
      (this.chainId = e),
      this.events.emit(ls.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((t) => t.split(":")[1] === this.chainId.toString())
              .map((t) => t.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        var n;
        const r = pr(t);
        e[r] = this.createHttpProvider(
          r,
          (n = this.namespace.rpcMap) == null ? void 0 : n[t]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || Gt(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Re("disableProviderPing")));
  }
}
var BS = Object.defineProperty,
  FS = (s, e, t) =>
    e in s
      ? BS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  vr = (s, e, t) => FS(s, typeof e != "symbol" ? e + "" : e, t);
class jS {
  constructor(e) {
    vr(this, "name", "cosmos"),
      vr(this, "client"),
      vr(this, "httpProviders"),
      vr(this, "events"),
      vr(this, "namespace"),
      vr(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t),
      (this.chainId = e),
      this.events.emit(
        ls.DEFAULT_CHAIN_CHANGED,
        `${this.name}:${this.chainId}`
      );
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((t) => t.split(":")[1] === this.chainId.toString())
              .map((t) => t.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        var n;
        const r = pr(t);
        e[r] = this.createHttpProvider(
          r,
          (n = this.namespace.rpcMap) == null ? void 0 : n[t]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || Gt(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Re("disableProviderPing")));
  }
}
var qS = Object.defineProperty,
  HS = (s, e, t) =>
    e in s
      ? qS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Ar = (s, e, t) => HS(s, typeof e != "symbol" ? e + "" : e, t);
class WS {
  constructor(e) {
    Ar(this, "name", "algorand"),
      Ar(this, "client"),
      Ar(this, "httpProviders"),
      Ar(this, "events"),
      Ar(this, "namespace"),
      Ar(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (!this.httpProviders[e]) {
      const n =
        t ||
        Gt(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    (this.chainId = e),
      this.events.emit(
        ls.DEFAULT_CHAIN_CHANGED,
        `${this.name}:${this.chainId}`
      );
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((t) => t.split(":")[1] === this.chainId.toString())
              .map((t) => t.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        var n;
        e[t] = this.createHttpProvider(
          t,
          (n = this.namespace.rpcMap) == null ? void 0 : n[t]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || Gt(e, this.namespace, this.client.core.projectId);
    return typeof n > "u"
      ? void 0
      : new cs(new As(n, Re("disableProviderPing")));
  }
}
var zS = Object.defineProperty,
  VS = (s, e, t) =>
    e in s
      ? zS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Ir = (s, e, t) => VS(s, typeof e != "symbol" ? e + "" : e, t);
class KS {
  constructor(e) {
    Ir(this, "name", "cip34"),
      Ir(this, "client"),
      Ir(this, "httpProviders"),
      Ir(this, "events"),
      Ir(this, "namespace"),
      Ir(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t),
      (this.chainId = e),
      this.events.emit(
        ls.DEFAULT_CHAIN_CHANGED,
        `${this.name}:${this.chainId}`
      );
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((t) => t.split(":")[1] === this.chainId.toString())
              .map((t) => t.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        const n = this.getCardanoRPCUrl(t),
          r = pr(t);
        e[r] = this.createHttpProvider(r, n);
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  getCardanoRPCUrl(e) {
    const t = this.namespace.rpcMap;
    if (t) return t[e];
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || this.getCardanoRPCUrl(e);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Re("disableProviderPing")));
  }
}
var GS = Object.defineProperty,
  YS = (s, e, t) =>
    e in s
      ? GS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Sr = (s, e, t) => YS(s, typeof e != "symbol" ? e + "" : e, t);
class ZS {
  constructor(e) {
    Sr(this, "name", "elrond"),
      Sr(this, "client"),
      Sr(this, "httpProviders"),
      Sr(this, "events"),
      Sr(this, "namespace"),
      Sr(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t),
      (this.chainId = e),
      this.events.emit(ls.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((t) => t.split(":")[1] === this.chainId.toString())
              .map((t) => t.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        var n;
        const r = pr(t);
        e[r] = this.createHttpProvider(
          r,
          (n = this.namespace.rpcMap) == null ? void 0 : n[t]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || Gt(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Re("disableProviderPing")));
  }
}
var JS = Object.defineProperty,
  XS = (s, e, t) =>
    e in s
      ? JS(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Nr = (s, e, t) => XS(s, typeof e != "symbol" ? e + "" : e, t);
class QS {
  constructor(e) {
    Nr(this, "name", "multiversx"),
      Nr(this, "client"),
      Nr(this, "httpProviders"),
      Nr(this, "events"),
      Nr(this, "namespace"),
      Nr(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t),
      (this.chainId = e),
      this.events.emit(ls.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((t) => t.split(":")[1] === this.chainId.toString())
              .map((t) => t.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        var n;
        const r = pr(t);
        e[r] = this.createHttpProvider(
          r,
          (n = this.namespace.rpcMap) == null ? void 0 : n[t]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || Gt(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Re("disableProviderPing")));
  }
}
var eN = Object.defineProperty,
  tN = (s, e, t) =>
    e in s
      ? eN(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Tr = (s, e, t) => tN(s, typeof e != "symbol" ? e + "" : e, t);
class sN {
  constructor(e) {
    Tr(this, "name", "near"),
      Tr(this, "client"),
      Tr(this, "httpProviders"),
      Tr(this, "events"),
      Tr(this, "namespace"),
      Tr(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (((this.chainId = e), !this.httpProviders[e])) {
      const n = t || Gt(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(ls.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? e
          .filter((t) => t.split(":")[1] === this.chainId.toString())
          .map((t) => t.split(":")[2]) || []
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        var n;
        e[t] = this.createHttpProvider(
          t,
          (n = this.namespace.rpcMap) == null ? void 0 : n[t]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || Gt(e, this.namespace);
    return typeof n > "u"
      ? void 0
      : new cs(new As(n, Re("disableProviderPing")));
  }
}
var nN = Object.defineProperty,
  rN = (s, e, t) =>
    e in s
      ? nN(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Rr = (s, e, t) => rN(s, typeof e != "symbol" ? e + "" : e, t);
class iN {
  constructor(e) {
    Rr(this, "name", "tezos"),
      Rr(this, "client"),
      Rr(this, "httpProviders"),
      Rr(this, "events"),
      Rr(this, "namespace"),
      Rr(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (((this.chainId = e), !this.httpProviders[e])) {
      const n = t || Gt(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(ls.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? e
          .filter((t) => t.split(":")[1] === this.chainId.toString())
          .map((t) => t.split(":")[2]) || []
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((t) => {
        e[t] = this.createHttpProvider(t);
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || Gt(e, this.namespace);
    return typeof n > "u" ? void 0 : new cs(new As(n));
  }
}
var oN = Object.defineProperty,
  aN = (s, e, t) =>
    e in s
      ? oN(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  xr = (s, e, t) => aN(s, typeof e != "symbol" ? e + "" : e, t);
class cN {
  constructor(e) {
    xr(this, "name", Or),
      xr(this, "client"),
      xr(this, "httpProviders"),
      xr(this, "events"),
      xr(this, "namespace"),
      xr(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Re("events")),
      (this.client = Re("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    (this.namespace.chains = [
      ...new Set((this.namespace.chains || []).concat(e.chains || [])),
    ]),
      (this.namespace.accounts = [
        ...new Set((this.namespace.accounts || []).concat(e.accounts || [])),
      ]),
      (this.namespace.methods = [
        ...new Set((this.namespace.methods || []).concat(e.methods || [])),
      ]),
      (this.namespace.events = [
        ...new Set((this.namespace.events || []).concat(e.events || [])),
      ]),
      (this.httpProviders = this.createHttpProviders());
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider(e.chainId).request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t),
      (this.chainId = e),
      this.events.emit(ls.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((t) => t.split(":")[1] === this.chainId.toString())
              .map((t) => t.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    var e, t;
    const n = {};
    return (
      (t = (e = this.namespace) == null ? void 0 : e.accounts) == null ||
        t.forEach((r) => {
          const i = Fr(r);
          n[`${i.namespace}:${i.reference}`] = this.createHttpProvider(r);
        }),
      n
    );
  }
  getHttpProvider(e) {
    const t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || Gt(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Re("disableProviderPing")));
  }
}
var lN = Object.defineProperty,
  dN = Object.defineProperties,
  uN = Object.getOwnPropertyDescriptors,
  Ih = Object.getOwnPropertySymbols,
  hN = Object.prototype.hasOwnProperty,
  pN = Object.prototype.propertyIsEnumerable,
  Sl = (s, e, t) =>
    e in s
      ? lN(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (s[e] = t),
  Zo = (s, e) => {
    for (var t in e || (e = {})) hN.call(e, t) && Sl(s, t, e[t]);
    if (Ih) for (var t of Ih(e)) pN.call(e, t) && Sl(s, t, e[t]);
    return s;
  },
  xc = (s, e) => dN(s, uN(e)),
  es = (s, e, t) => Sl(s, typeof e != "symbol" ? e + "" : e, t);
let fN = class ug {
    constructor(e) {
      es(this, "client"),
        es(this, "namespaces"),
        es(this, "optionalNamespaces"),
        es(this, "sessionProperties"),
        es(this, "scopedProperties"),
        es(this, "events", new Bl()),
        es(this, "rpcProviders", {}),
        es(this, "session"),
        es(this, "providerOpts"),
        es(this, "logger"),
        es(this, "uri"),
        es(this, "disableProviderPing", !1),
        (this.providerOpts = e),
        (this.logger =
          typeof (e == null ? void 0 : e.logger) < "u" &&
          typeof (e == null ? void 0 : e.logger) != "string"
            ? e.logger
            : Dl(ti({ level: (e == null ? void 0 : e.logger) || ph }))),
        (this.disableProviderPing =
          (e == null ? void 0 : e.disableProviderPing) || !1);
    }
    static async init(e) {
      const t = new ug(e);
      return await t.initialize(), t;
    }
    async request(e, t, n) {
      const [r, i] = this.validateChain(t);
      if (!this.session)
        throw new Error("Please call connect() before request()");
      return await this.getProvider(r).request({
        request: Zo({}, e),
        chainId: `${r}:${i}`,
        topic: this.session.topic,
        expiry: n,
      });
    }
    sendAsync(e, t, n, r) {
      const i = new Date().getTime();
      this.request(e, n, r)
        .then((o) => t(null, $a(i, o)))
        .catch((o) => t(o, void 0));
    }
    async enable() {
      if (!this.client) throw new Error("Sign Client not initialized");
      return (
        this.session ||
          (await this.connect({
            namespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties,
          })),
        await this.requestAccounts()
      );
    }
    async disconnect() {
      var e;
      if (!this.session)
        throw new Error("Please call connect() before enable()");
      await this.client.disconnect({
        topic: (e = this.session) == null ? void 0 : e.topic,
        reason: ze("USER_DISCONNECTED"),
      }),
        await this.cleanup();
    }
    async connect(e) {
      if (!this.client) throw new Error("Sign Client not initialized");
      if (
        (this.setNamespaces(e),
        await this.cleanupPendingPairings(),
        !e.skipPairing)
      )
        return await this.pair(e.pairingTopic);
    }
    async authenticate(e, t) {
      if (!this.client) throw new Error("Sign Client not initialized");
      this.setNamespaces(e), await this.cleanupPendingPairings();
      const { uri: n, response: r } = await this.client.authenticate(e, t);
      n && ((this.uri = n), this.events.emit("display_uri", n));
      const i = await r();
      if (((this.session = i.session), this.session)) {
        const o = _h(this.session.namespaces);
        (this.namespaces = Yo(this.namespaces, o)),
          await this.persist("namespaces", this.namespaces),
          this.onConnect();
      }
      return i;
    }
    on(e, t) {
      this.events.on(e, t);
    }
    once(e, t) {
      this.events.once(e, t);
    }
    removeListener(e, t) {
      this.events.removeListener(e, t);
    }
    off(e, t) {
      this.events.off(e, t);
    }
    get isWalletConnect() {
      return !0;
    }
    async pair(e) {
      const { uri: t, approval: n } = await this.client.connect({
        pairingTopic: e,
        requiredNamespaces: this.namespaces,
        optionalNamespaces: this.optionalNamespaces,
        sessionProperties: this.sessionProperties,
        scopedProperties: this.scopedProperties,
      });
      t && ((this.uri = t), this.events.emit("display_uri", t));
      const r = await n();
      this.session = r;
      const i = _h(r.namespaces);
      return (
        (this.namespaces = Yo(this.namespaces, i)),
        await this.persist("namespaces", this.namespaces),
        await this.persist("optionalNamespaces", this.optionalNamespaces),
        this.onConnect(),
        this.session
      );
    }
    setDefaultChain(e, t) {
      try {
        if (!this.session) return;
        const [n, r] = this.validateChain(e),
          i = this.getProvider(n);
        i.name === Or
          ? i.setDefaultChain(`${n}:${r}`, t)
          : i.setDefaultChain(r, t);
      } catch (n) {
        if (!/Please call connect/.test(n.message)) throw n;
      }
    }
    async cleanupPendingPairings(e = {}) {
      this.logger.info("Cleaning up inactive pairings...");
      const t = this.client.pairing.getAll();
      if (Xs(t)) {
        for (const n of t)
          e.deletePairings
            ? this.client.core.expirer.set(n.topic, 0)
            : await this.client.core.relayer.subscriber.unsubscribe(n.topic);
        this.logger.info(`Inactive pairings cleared: ${t.length}`);
      }
    }
    abortPairingAttempt() {
      this.logger.warn(
        "abortPairingAttempt is deprecated. This is now a no-op."
      );
    }
    async checkStorage() {
      (this.namespaces = (await this.getFromStore("namespaces")) || {}),
        (this.optionalNamespaces =
          (await this.getFromStore("optionalNamespaces")) || {}),
        this.session && this.createProviders();
    }
    async initialize() {
      this.logger.trace("Initialized"),
        await this.createClient(),
        await this.checkStorage(),
        this.registerEventListeners();
    }
    async createClient() {
      var e, t;
      if (
        ((this.client =
          this.providerOpts.client ||
          (await qI.init({
            core: this.providerOpts.core,
            logger: this.providerOpts.logger || ph,
            relayUrl: this.providerOpts.relayUrl || HI,
            projectId: this.providerOpts.projectId,
            metadata: this.providerOpts.metadata,
            storageOptions: this.providerOpts.storageOptions,
            storage: this.providerOpts.storage,
            name: this.providerOpts.name,
            customStoragePrefix: this.providerOpts.customStoragePrefix,
            telemetryEnabled: this.providerOpts.telemetryEnabled,
          }))),
        this.providerOpts.session)
      )
        try {
          this.session = this.client.session.get(
            this.providerOpts.session.topic
          );
        } catch (n) {
          throw (
            (this.logger.error("Failed to get session", n),
            new Error(
              `The provided session: ${
                (t = (e = this.providerOpts) == null ? void 0 : e.session) ==
                null
                  ? void 0
                  : t.topic
              } doesn't exist in the Sign client`
            ))
          );
        }
      else {
        const n = this.client.session.getAll();
        this.session = n[0];
      }
      this.logger.trace("SignClient Initialized");
    }
    createProviders() {
      if (!this.client) throw new Error("Sign Client not initialized");
      if (!this.session)
        throw new Error(
          "Session not initialized. Please call connect() before enable()"
        );
      const e = [
        ...new Set(Object.keys(this.session.namespaces).map((t) => Lr(t))),
      ];
      Rc("client", this.client),
        Rc("events", this.events),
        Rc("disableProviderPing", this.disableProviderPing),
        e.forEach((t) => {
          if (!this.session) return;
          const n = SS(t, this.session),
            r = lg(n),
            i = Yo(this.namespaces, this.optionalNamespaces),
            o = xc(Zo({}, i[t]), { accounts: n, chains: r });
          switch (t) {
            case "eip155":
              this.rpcProviders[t] = new $S({ namespace: o });
              break;
            case "algorand":
              this.rpcProviders[t] = new WS({ namespace: o });
              break;
            case "solana":
              this.rpcProviders[t] = new MS({ namespace: o });
              break;
            case "cosmos":
              this.rpcProviders[t] = new jS({ namespace: o });
              break;
            case "polkadot":
              this.rpcProviders[t] = new RS({ namespace: o });
              break;
            case "cip34":
              this.rpcProviders[t] = new KS({ namespace: o });
              break;
            case "elrond":
              this.rpcProviders[t] = new ZS({ namespace: o });
              break;
            case "multiversx":
              this.rpcProviders[t] = new QS({ namespace: o });
              break;
            case "near":
              this.rpcProviders[t] = new sN({ namespace: o });
              break;
            case "tezos":
              this.rpcProviders[t] = new iN({ namespace: o });
              break;
            default:
              this.rpcProviders[Or]
                ? this.rpcProviders[Or].updateNamespace(o)
                : (this.rpcProviders[Or] = new cN({ namespace: o }));
          }
        });
    }
    registerEventListeners() {
      if (typeof this.client > "u")
        throw new Error("Sign Client is not initialized");
      this.client.on("session_ping", (e) => {
        var t;
        const { topic: n } = e;
        n === ((t = this.session) == null ? void 0 : t.topic) &&
          this.events.emit("session_ping", e);
      }),
        this.client.on("session_event", (e) => {
          var t;
          const { params: n, topic: r } = e;
          if (r !== ((t = this.session) == null ? void 0 : t.topic)) return;
          const { event: i } = n;
          if (i.name === "accountsChanged") {
            const o = i.data;
            o && Xs(o) && this.events.emit("accountsChanged", o.map(bh));
          } else if (i.name === "chainChanged") {
            const o = n.chainId,
              a = n.event.data,
              c = Lr(o),
              l = Tc(o) !== Tc(a) ? `${c}:${Tc(a)}` : o;
            this.onChainChanged(l);
          } else this.events.emit(i.name, i.data);
          this.events.emit("session_event", e);
        }),
        this.client.on("session_update", ({ topic: e, params: t }) => {
          var n, r;
          if (e !== ((n = this.session) == null ? void 0 : n.topic)) return;
          const { namespaces: i } = t,
            o = (r = this.client) == null ? void 0 : r.session.get(e);
          (this.session = xc(Zo({}, o), { namespaces: i })),
            this.onSessionUpdate(),
            this.events.emit("session_update", { topic: e, params: t });
        }),
        this.client.on("session_delete", async (e) => {
          var t;
          e.topic === ((t = this.session) == null ? void 0 : t.topic) &&
            (await this.cleanup(),
            this.events.emit("session_delete", e),
            this.events.emit(
              "disconnect",
              xc(Zo({}, ze("USER_DISCONNECTED")), { data: e.topic })
            ));
        }),
        this.on(ls.DEFAULT_CHAIN_CHANGED, (e) => {
          this.onChainChanged(e, !0);
        });
    }
    getProvider(e) {
      return this.rpcProviders[e] || this.rpcProviders[Or];
    }
    onSessionUpdate() {
      Object.keys(this.rpcProviders).forEach((e) => {
        var t;
        this.getProvider(e).updateNamespace(
          (t = this.session) == null ? void 0 : t.namespaces[e]
        );
      });
    }
    setNamespaces(e) {
      const {
        namespaces: t = {},
        optionalNamespaces: n = {},
        sessionProperties: r,
        scopedProperties: i,
      } = e;
      (this.optionalNamespaces = Yo(t, n)),
        (this.sessionProperties = r),
        (this.scopedProperties = i);
    }
    validateChain(e) {
      const [t, n] = (e == null ? void 0 : e.split(":")) || ["", ""];
      if (!this.namespaces || !Object.keys(this.namespaces).length)
        return [t, n];
      if (
        t &&
        !Object.keys(this.namespaces || {})
          .map((o) => Lr(o))
          .includes(t)
      )
        throw new Error(
          `Namespace '${t}' is not configured. Please call connect() first with namespace config.`
        );
      if (t && n) return [t, n];
      const r = Lr(Object.keys(this.namespaces)[0]),
        i = this.rpcProviders[r].getDefaultChain();
      return [r, i];
    }
    async requestAccounts() {
      const [e] = this.validateChain();
      return await this.getProvider(e).requestAccounts();
    }
    async onChainChanged(e, t = !1) {
      if (!this.namespaces) return;
      const [n, r] = this.validateChain(e);
      if (!r) return;
      this.updateNamespaceChain(n, r), this.events.emit("chainChanged", r);
      const i = this.getProvider(n).getDefaultChain();
      t || this.getProvider(n).setDefaultChain(r),
        this.emitAccountsChangedOnChainChange({
          namespace: n,
          previousChainId: i,
          newChainId: e,
        }),
        await this.persist("namespaces", this.namespaces);
    }
    emitAccountsChangedOnChainChange({
      namespace: e,
      previousChainId: t,
      newChainId: n,
    }) {
      var r, i;
      try {
        if (t === n) return;
        const o =
          (i = (r = this.session) == null ? void 0 : r.namespaces[e]) == null
            ? void 0
            : i.accounts;
        if (!o) return;
        const a = o.filter((c) => c.includes(`${n}:`)).map(bh);
        if (!Xs(a)) return;
        this.events.emit("accountsChanged", a);
      } catch (o) {
        this.logger.warn("Failed to emit accountsChanged on chain change", o);
      }
    }
    updateNamespaceChain(e, t) {
      if (!this.namespaces) return;
      const n = this.namespaces[e] ? e : `${e}:${t}`,
        r = { chains: [], methods: [], events: [], defaultChain: t };
      this.namespaces[n]
        ? this.namespaces[n] && (this.namespaces[n].defaultChain = t)
        : (this.namespaces[n] = r);
    }
    onConnect() {
      this.createProviders(),
        this.events.emit("connect", { session: this.session });
    }
    async cleanup() {
      (this.namespaces = void 0),
        (this.optionalNamespaces = void 0),
        (this.sessionProperties = void 0),
        await this.deleteFromStore("namespaces"),
        await this.deleteFromStore("optionalNamespaces"),
        await this.deleteFromStore("sessionProperties"),
        (this.session = void 0),
        await this.cleanupPendingPairings({ deletePairings: !0 }),
        await this.cleanupStorage();
    }
    async persist(e, t) {
      var n;
      const r = ((n = this.session) == null ? void 0 : n.topic) || "";
      await this.client.core.storage.setItem(`${Ko}/${e}${r}`, t);
    }
    async getFromStore(e) {
      var t;
      const n = ((t = this.session) == null ? void 0 : t.topic) || "";
      return await this.client.core.storage.getItem(`${Ko}/${e}${n}`);
    }
    async deleteFromStore(e) {
      var t;
      const n = ((t = this.session) == null ? void 0 : t.topic) || "";
      await this.client.core.storage.removeItem(`${Ko}/${e}${n}`);
    }
    async cleanupStorage() {
      var e;
      try {
        if (((e = this.client) == null ? void 0 : e.session.length) > 0) return;
        const t = await this.client.core.storage.getKeys();
        for (const n of t)
          n.startsWith(Ko) && (await this.client.core.storage.removeItem(n));
      } catch (t) {
        this.logger.warn("Failed to cleanup storage", t);
      }
    }
  },
  Ln = null;
const ms = {
    getSIWX() {
      return R.state.siwx;
    },
    async initializeIfEnabled() {
      var i;
      const s = R.state.siwx,
        e = y.getActiveCaipAddress();
      if (!(s && e)) return;
      const [t, n, r] = e.split(":");
      if (y.checkIfSupportedNetwork(t))
        try {
          if ((Ln && (await Ln), (await s.getSessions(`${t}:${n}`, r)).length))
            return;
          await Ne.open({ view: "SIWXSignMessage" });
        } catch (o) {
          console.error("SIWXUtil:initializeIfEnabled", o),
            Ue.sendEvent({
              type: "track",
              event: "SIWX_AUTH_ERROR",
              properties: this.getSIWXEventProperties(),
            }),
            await ((i = H._getClient()) == null
              ? void 0
              : i.disconnect().catch(console.error)),
            de.reset("Connect"),
            ks.showError(
              "A problem occurred while trying initialize authentication"
            );
        }
    },
    async requestSignMessage() {
      const s = R.state.siwx,
        e = ne.getPlainAddress(y.getActiveCaipAddress()),
        t = y.getActiveCaipNetwork(),
        n = H._getClient();
      if (!s) throw new Error("SIWX is not enabled");
      if (!e) throw new Error("No ActiveCaipAddress found");
      if (!t) throw new Error("No ActiveCaipNetwork or client found");
      if (!n) throw new Error("No ConnectionController client found");
      try {
        const r = await s.createMessage({
            chainId: t.caipNetworkId,
            accountAddress: e,
          }),
          i = r.toString();
        q.getConnectorId(t.chainNamespace) === S.CONNECTOR_ID.AUTH &&
          de.pushTransactionStack({});
        const a = await n.signMessage(i);
        await s.addSession({ data: r, message: i, signature: a }),
          y.setLastConnectedSIWECaipNetwork(t),
          Ne.close(),
          Ue.sendEvent({
            type: "track",
            event: "SIWX_AUTH_SUCCESS",
            properties: this.getSIWXEventProperties(),
          });
      } catch (r) {
        const i = this.getSIWXEventProperties();
        (!Ne.state.open || de.state.view === "ApproveTransaction") &&
          (await Ne.open({ view: "SIWXSignMessage" })),
          ks.showError("Error signing message"),
          Ue.sendEvent({
            type: "track",
            event: "SIWX_AUTH_ERROR",
            properties: i,
          }),
          console.error("SWIXUtil:requestSignMessage", r);
      }
    },
    async cancelSignMessage() {
      var s;
      try {
        const e = this.getSIWX();
        if (
          (s = e == null ? void 0 : e.getRequired) == null ? void 0 : s.call(e)
        ) {
          const n = y.getLastConnectedSIWECaipNetwork();
          if (n) {
            const r = await (e == null
              ? void 0
              : e.getSessions(
                  n == null ? void 0 : n.caipNetworkId,
                  ne.getPlainAddress(y.getActiveCaipAddress()) || ""
                ));
            r && r.length > 0
              ? await y.switchActiveNetwork(n)
              : await H.disconnect();
          } else await H.disconnect();
        } else Ne.close();
        Ne.close(),
          Ue.sendEvent({
            event: "CLICK_CANCEL_SIWX",
            type: "track",
            properties: this.getSIWXEventProperties(),
          });
      } catch (e) {
        console.error("SIWXUtil:cancelSignMessage", e);
      }
    },
    async getAllSessions() {
      const s = this.getSIWX(),
        e = y.getAllRequestedCaipNetworks(),
        t = [];
      return (
        await Promise.all(
          e.map(async (n) => {
            const r = await (s == null
              ? void 0
              : s.getSessions(
                  n.caipNetworkId,
                  ne.getPlainAddress(y.getActiveCaipAddress()) || ""
                ));
            r && t.push(...r);
          })
        ),
        t
      );
    },
    async getSessions() {
      const s = R.state.siwx,
        e = ne.getPlainAddress(y.getActiveCaipAddress()),
        t = y.getActiveCaipNetwork();
      return s && e && t ? s.getSessions(t.caipNetworkId, e) : [];
    },
    async isSIWXCloseDisabled() {
      var e;
      const s = this.getSIWX();
      if (s) {
        const t = de.state.view === "ApproveTransaction",
          n = de.state.view === "SIWXSignMessage";
        if (t || n)
          return (
            ((e = s.getRequired) == null ? void 0 : e.call(s)) &&
            (await this.getSessions()).length === 0
          );
      }
      return !1;
    },
    async authConnectorAuthenticate({
      authConnector: s,
      chainId: e,
      socialUri: t,
      preferredAccountType: n,
      chainNamespace: r,
    }) {
      var l;
      const i = ms.getSIWX();
      if (!i || !r.includes(S.CHAIN.EVM)) {
        const d = await s.connect({
          chainId: e,
          socialUri: t,
          preferredAccountType: n,
        });
        return { address: d.address, chainId: d.chainId, accounts: d.accounts };
      }
      const o = await i.createMessage({
          chainId:
            ((l = y.getActiveCaipNetwork()) == null
              ? void 0
              : l.caipNetworkId) || "",
          accountAddress: "<<AccountAddress>>",
        }),
        a = {
          accountAddress: o.accountAddress,
          chainId: o.chainId,
          domain: o.domain,
          uri: o.uri,
          version: o.version,
          nonce: o.nonce,
          notBefore: o.notBefore,
          statement: o.statement,
          resources: o.resources,
          requestId: o.requestId,
          issuedAt: o.issuedAt,
          expirationTime: o.expirationTime,
          serializedMessage: o.toString(),
        },
        c = await s.connect({
          chainId: e,
          socialUri: t,
          siwxMessage: a,
          preferredAccountType: n,
        });
      return (
        (a.accountAddress = c.address),
        (a.serializedMessage = c.message || ""),
        c.signature &&
          c.message &&
          (await ms.addEmbeddedWalletSession(a, c.message, c.signature)),
        { address: c.address, chainId: c.chainId, accounts: c.accounts }
      );
    },
    async addEmbeddedWalletSession(s, e, t) {
      if (Ln) return Ln;
      const n = ms.getSIWX();
      return n
        ? ((Ln = n
            .addSession({ data: s, message: e, signature: t })
            .finally(() => {
              Ln = null;
            })),
          Ln)
        : Promise.resolve();
    },
    async universalProviderAuthenticate({
      universalProvider: s,
      chains: e,
      methods: t,
    }) {
      var a, c, l;
      const n = ms.getSIWX(),
        r = new Set(e.map((d) => d.split(":")[0]));
      if (!n || r.size !== 1 || !r.has("eip155")) return !1;
      const i = await n.createMessage({
          chainId:
            ((a = y.getActiveCaipNetwork()) == null
              ? void 0
              : a.caipNetworkId) || "",
          accountAddress: "",
        }),
        o = await s.authenticate({
          nonce: i.nonce,
          domain: i.domain,
          uri: i.uri,
          exp: i.expirationTime,
          iat: i.issuedAt,
          nbf: i.notBefore,
          requestId: i.requestId,
          version: i.version,
          resources: i.resources,
          statement: i.statement,
          chainId: i.chainId,
          methods: t,
          chains: [i.chainId, ...e.filter((d) => d !== i.chainId)],
        });
      if (
        (ks.showLoading("Authenticating...", { autoClose: !1 }),
        se.setConnectedWalletInfo(
          {
            ...o.session.peer.metadata,
            name: o.session.peer.metadata.name,
            icon: (c = o.session.peer.metadata.icons) == null ? void 0 : c[0],
            type: "WALLET_CONNECT",
          },
          Array.from(r)[0]
        ),
        (l = o == null ? void 0 : o.auths) != null && l.length)
      ) {
        const d = o.auths.map((u) => {
          const p = s.client.formatAuthMessage({ request: u.p, iss: u.p.iss });
          return {
            data: {
              ...u.p,
              accountAddress: u.p.iss.split(":").slice(-1).join(""),
              chainId: u.p.iss.split(":").slice(2, 4).join(":"),
              uri: u.p.aud,
              version: u.p.version || i.version,
              expirationTime: u.p.exp,
              issuedAt: u.p.iat,
              notBefore: u.p.nbf,
            },
            message: p,
            signature: u.s.s,
            cacao: u,
          };
        });
        try {
          await n.setSessions(d),
            Ue.sendEvent({
              type: "track",
              event: "SIWX_AUTH_SUCCESS",
              properties: ms.getSIWXEventProperties(),
            });
        } catch (u) {
          throw (
            (console.error(
              "SIWX:universalProviderAuth - failed to set sessions",
              u
            ),
            Ue.sendEvent({
              type: "track",
              event: "SIWX_AUTH_ERROR",
              properties: ms.getSIWXEventProperties(),
            }),
            await s.disconnect().catch(console.error),
            u)
          );
        } finally {
          ks.hide();
        }
      }
      return !0;
    },
    getSIWXEventProperties() {
      var e;
      const s = y.state.activeChain;
      if (!s)
        throw new Error(
          "SIWXUtil:getSIWXEventProperties - namespace is required"
        );
      return {
        network:
          ((e = y.state.activeCaipNetwork) == null
            ? void 0
            : e.caipNetworkId) || "",
        isSmartAccount: Cs(s) === nt.ACCOUNT_TYPES.SMART_ACCOUNT,
      };
    },
    async clearSessions() {
      const s = this.getSIWX();
      s && (await s.setSessions([]));
    },
  },
  zt = {
    EIP155: S.CHAIN.EVM,
    CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
    CONNECTOR_TYPE_INJECTED: "INJECTED",
    CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
    CONNECTOR_TYPE_AUTH: "AUTH",
  },
  io = {
    NetworkImageIds: {
      1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
      42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
      43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
      56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
      250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
      10: "ab9c186a-c52f-464b-2906-ca59d760a400",
      137: "41d04d42-da3b-4453-8506-668cc0727900",
      5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
      295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
      11155111: "e909ea0a-f92a-4512-c8fc-748044ea6800",
      84532: "a18a7ecd-e307-4360-4746-283182228e00",
      1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
      130: "2257980a-3463-48c6-cbac-a42d2a956e00",
      10143: "0a728e83-bacb-46db-7844-948f05434900",
      100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
      9001: "f926ff41-260d-4028-635e-91913fc28e00",
      324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
      314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
      4689: "34e68754-e536-40da-c153-6ef2e7188a00",
      1088: "3897a66d-40b9-4833-162f-a2c90531c900",
      1284: "161038da-44ae-4ec7-1208-0ea569454b00",
      1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
      7777777: "845c60df-d429-4991-e687-91ae45791600",
      42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
      8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
      1313161554: "3ff73439-a619-4894-9262-4470c773a100",
      2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
      2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
      80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
      2741: "fc2427d1-5af9-4a9c-8da5-6f94627cd900",
      "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":
        "a1b58899-f671-4276-6a5e-56ca5bd59700",
      "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z":
        "a1b58899-f671-4276-6a5e-56ca5bd59700",
      EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700",
      "000000000019d6689c085ae165831e93":
        "0b4838db-0161-4ffe-022d-532bf03dba00",
      "000000000933ea01ad0ee984209779ba":
        "39354064-d79b-420b-065d-f980c4b78200",
    },
    ConnectorImageIds: {
      [S.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
      [S.CONNECTOR_ID.COINBASE_SDK]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
      [S.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
      [S.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
      [S.CONNECTOR_ID.WALLET_CONNECT]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
      [S.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00",
    },
    ConnectorNamesMap: {
      [S.CONNECTOR_ID.INJECTED]: "Browser Wallet",
      [S.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
      [S.CONNECTOR_ID.COINBASE]: "Coinbase",
      [S.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
      [S.CONNECTOR_ID.LEDGER]: "Ledger",
      [S.CONNECTOR_ID.SAFE]: "Safe",
    },
  },
  At = {
    getCaipTokens(s) {
      if (!s) return;
      const e = {};
      return (
        Object.entries(s).forEach(([t, n]) => {
          e[`${zt.EIP155}:${t}`] = n;
        }),
        e
      );
    },
    isLowerCaseMatch(s, e) {
      return (
        (s == null ? void 0 : s.toLowerCase()) ===
        (e == null ? void 0 : e.toLowerCase())
      );
    },
    getActiveNamespaceConnectedToAuth() {
      const s = y.state.activeChain;
      return S.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
        (e) => q.getConnectorId(e) === S.CONNECTOR_ID.AUTH && e === s
      );
    },
    withRetry({ conditionFn: s, intervalMs: e, maxRetries: t }) {
      let n = 0;
      return new Promise((r) => {
        async function i() {
          return (
            (n += 1),
            (await s()) ? r(!0) : n >= t ? r(!1) : (setTimeout(i, e), null)
          );
        }
        i();
      });
    },
  },
  gN = new AbortController(),
  vt = {
    EmbeddedWalletAbortController: gN,
    UniversalProviderErrors: {
      UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
        message: "Unauthorized: origin not allowed",
        alertErrorKey: "INVALID_APP_CONFIGURATION",
      },
      JWT_VALIDATION_ERROR: {
        message: "JWT validation error: JWT Token is not yet valid",
        alertErrorKey: "JWT_TOKEN_NOT_VALID",
      },
      INVALID_KEY: {
        message: "Unauthorized: invalid key",
        alertErrorKey: "INVALID_PROJECT_ID",
      },
    },
    ALERT_ERRORS: {
      SWITCH_NETWORK_NOT_FOUND: {
        shortMessage: "Network Not Found",
        longMessage:
          "Network not found - please make sure it is included in 'networks' array in createAppKit function",
      },
      INVALID_APP_CONFIGURATION: {
        shortMessage: "Invalid App Configuration",
        longMessage: () =>
          `Origin ${
            mN() ? window.origin : "unknown"
          } not found on Allowlist - update configuration on cloud.reown.com`,
      },
      IFRAME_LOAD_FAILED: {
        shortMessage: "Network Error - Could not load embedded wallet",
        longMessage: () =>
          "There was an issue loading the embedded wallet. Please try again later.",
      },
      IFRAME_REQUEST_TIMEOUT: {
        shortMessage: "Embedded Wallet Request Timed Out",
        longMessage: () =>
          "There was an issue doing the request to the embedded wallet. Please try again later.",
      },
      UNVERIFIED_DOMAIN: {
        shortMessage: "Invalid App Configuration",
        longMessage: () =>
          "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com",
      },
      JWT_TOKEN_NOT_VALID: {
        shortMessage: "Session Expired",
        longMessage:
          "Invalid session found on UniversalProvider - please check your time settings and connect again",
      },
      INVALID_PROJECT_ID: {
        shortMessage: "Invalid App Configuration",
        longMessage: "Invalid Project ID - update configuration",
      },
      PROJECT_ID_NOT_CONFIGURED: {
        shortMessage: "Project ID Not Configured",
        longMessage:
          "Project ID Not Configured - update configuration on cloud.reown.com",
      },
      SERVER_ERROR_APP_CONFIGURATION: {
        shortMessage: "Server Error",
        longMessage: (s) => `Failed to get App Configuration ${s || ""}`,
      },
      RATE_LIMITED_APP_CONFIGURATION: {
        shortMessage: "Rate Limited",
        longMessage: "Rate limited when trying to get the App Configuration",
      },
    },
  };
function mN() {
  return typeof window < "u";
}
const wN = {
    createLogger(s, e = "error") {
      const t = ti({ level: e }),
        { logger: n } = $l({ opts: t });
      return (
        (n.error = (...r) => {
          for (const i of r)
            if (i instanceof Error) {
              s(i, ...r);
              return;
            }
          s(void 0, ...r);
        }),
        n
      );
    },
  },
  yN = "rpc.walletconnect.org";
function Sh(s, e) {
  const t = new URL("https://rpc.walletconnect.org/v1/");
  return (
    t.searchParams.set("chainId", s),
    t.searchParams.set("projectId", e),
    t.toString()
  );
}
const Pc = [
    "near:mainnet",
    "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    "eip155:1101",
    "eip155:56",
    "eip155:42161",
    "eip155:7777777",
    "eip155:59144",
    "eip155:324",
    "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    "eip155:5000",
    "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
    "eip155:80084",
    "eip155:5003",
    "eip155:100",
    "eip155:8453",
    "eip155:42220",
    "eip155:1313161555",
    "eip155:17000",
    "eip155:1",
    "eip155:300",
    "eip155:1313161554",
    "eip155:1329",
    "eip155:84532",
    "eip155:421614",
    "eip155:11155111",
    "eip155:8217",
    "eip155:43114",
    "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
    "eip155:999999999",
    "eip155:11155420",
    "eip155:80002",
    "eip155:97",
    "eip155:43113",
    "eip155:137",
    "eip155:10",
    "eip155:1301",
    "bip122:000000000019d6689c085ae165831e93",
    "bip122:000000000933ea01ad0ee984209779ba",
  ],
  kr = {
    extendRpcUrlWithProjectId(s, e) {
      let t = !1;
      try {
        t = new URL(s).host === yN;
      } catch {
        t = !1;
      }
      if (t) {
        const n = new URL(s);
        return (
          n.searchParams.has("projectId") || n.searchParams.set("projectId", e),
          n.toString()
        );
      }
      return s;
    },
    isCaipNetwork(s) {
      return "chainNamespace" in s && "caipNetworkId" in s;
    },
    getChainNamespace(s) {
      return this.isCaipNetwork(s) ? s.chainNamespace : S.CHAIN.EVM;
    },
    getCaipNetworkId(s) {
      return this.isCaipNetwork(s) ? s.caipNetworkId : `${S.CHAIN.EVM}:${s.id}`;
    },
    getDefaultRpcUrl(s, e, t) {
      var r, i, o;
      const n =
        (o =
          (i = (r = s.rpcUrls) == null ? void 0 : r.default) == null
            ? void 0
            : i.http) == null
          ? void 0
          : o[0];
      return Pc.includes(e) ? Sh(e, t) : n || "";
    },
    extendCaipNetwork(
      s,
      { customNetworkImageUrls: e, projectId: t, customRpcUrls: n }
    ) {
      var p, w, g, m, f;
      const r = this.getChainNamespace(s),
        i = this.getCaipNetworkId(s),
        o = (p = s.rpcUrls.default.http) == null ? void 0 : p[0],
        a = this.getDefaultRpcUrl(s, i, t),
        c =
          ((m =
            (g =
              (w = s == null ? void 0 : s.rpcUrls) == null
                ? void 0
                : w.chainDefault) == null
              ? void 0
              : g.http) == null
            ? void 0
            : m[0]) || o,
        l =
          ((f = n == null ? void 0 : n[i]) == null
            ? void 0
            : f.map((E) => E.url)) || [],
        d = [...l, a],
        u = [...l];
      return (
        c && !u.includes(c) && u.push(c),
        {
          ...s,
          chainNamespace: r,
          caipNetworkId: i,
          assets: {
            imageId: io.NetworkImageIds[s.id],
            imageUrl: e == null ? void 0 : e[s.id],
          },
          rpcUrls: {
            ...s.rpcUrls,
            default: { http: d },
            chainDefault: { http: u },
          },
        }
      );
    },
    extendCaipNetworks(
      s,
      { customNetworkImageUrls: e, projectId: t, customRpcUrls: n }
    ) {
      return s.map((r) =>
        kr.extendCaipNetwork(r, {
          customNetworkImageUrls: e,
          customRpcUrls: n,
          projectId: t,
        })
      );
    },
    getViemTransport(s, e, t) {
      var r, i, o;
      const n = [];
      return (
        t == null ||
          t.forEach((a) => {
            n.push($o(a.url, a.config));
          }),
        Pc.includes(s.caipNetworkId) &&
          n.push(
            $o(Sh(s.caipNetworkId, e), {
              fetchOptions: { headers: { "Content-Type": "text/plain" } },
            })
          ),
        (o =
          (i =
            (r = s == null ? void 0 : s.rpcUrls) == null
              ? void 0
              : r.default) == null
            ? void 0
            : i.http) == null ||
          o.forEach((a) => {
            n.push($o(a));
          }),
        _d(n)
      );
    },
    extendWagmiTransports(s, e, t) {
      if (Pc.includes(s.caipNetworkId)) {
        const n = this.getDefaultRpcUrl(s, s.caipNetworkId, e);
        return _d([t, $o(n)]);
      }
      return t;
    },
    getUnsupportedNetwork(s) {
      return {
        id: s.split(":")[1],
        caipNetworkId: s,
        name: S.UNSUPPORTED_NETWORK_NAME,
        chainNamespace: s.split(":")[0],
        nativeCurrency: { name: "", decimals: 0, symbol: "" },
        rpcUrls: { default: { http: [] } },
      };
    },
    getCaipNetworkFromStorage(s) {
      var c;
      const e = M.getActiveCaipNetworkId(),
        t = y.getAllRequestedCaipNetworks(),
        n = Array.from(
          ((c = y.state.chains) == null ? void 0 : c.keys()) || []
        ),
        r = e == null ? void 0 : e.split(":")[0],
        i = r ? n.includes(r) : !1,
        o = t == null ? void 0 : t.find((l) => l.caipNetworkId === e);
      return i && !o && e
        ? this.getUnsupportedNetwork(e)
        : o || s || (t == null ? void 0 : t[0]);
    },
  },
  Ca = {
    eip155: void 0,
    solana: void 0,
    polkadot: void 0,
    bip122: void 0,
    cosmos: void 0,
  },
  kt = qe({ providers: { ...Ca }, providerIds: { ...Ca } }),
  Le = {
    state: kt,
    subscribeKey(s, e) {
      return Ct(kt, s, e);
    },
    subscribe(s) {
      return ft(kt, () => {
        s(kt);
      });
    },
    subscribeProviders(s) {
      return ft(kt.providers, () => s(kt.providers));
    },
    setProvider(s, e) {
      s && e && (kt.providers[s] = Qn(e));
    },
    getProvider(s) {
      if (s) return kt.providers[s];
    },
    setProviderId(s, e) {
      e && (kt.providerIds[s] = e);
    },
    getProviderId(s) {
      if (s) return kt.providerIds[s];
    },
    reset() {
      (kt.providers = { ...Ca }), (kt.providerIds = { ...Ca });
    },
    resetChain(s) {
      (kt.providers[s] = void 0), (kt.providerIds[s] = void 0);
    },
  },
  Nh = {
    transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
    signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u,
  },
  ht = {
    set(s, e) {
      Vt.isClient && localStorage.setItem(`${te.STORAGE_KEY}${s}`, e);
    },
    get(s) {
      return Vt.isClient ? localStorage.getItem(`${te.STORAGE_KEY}${s}`) : null;
    },
    delete(s, e) {
      Vt.isClient &&
        (e
          ? localStorage.removeItem(s)
          : localStorage.removeItem(`${te.STORAGE_KEY}${s}`));
    },
  },
  Jo = 30 * 1e3,
  Vt = {
    checkIfAllowedToTriggerEmail() {
      const s = ht.get(te.LAST_EMAIL_LOGIN_TIME);
      if (s) {
        const e = Date.now() - Number(s);
        if (e < Jo) {
          const t = Math.ceil((Jo - e) / 1e3);
          throw new Error(`Please try again after ${t} seconds`);
        }
      }
    },
    getTimeToNextEmailLogin() {
      const s = ht.get(te.LAST_EMAIL_LOGIN_TIME);
      if (s) {
        const e = Date.now() - Number(s);
        if (e < Jo) return Math.ceil((Jo - e) / 1e3);
      }
      return 0;
    },
    checkIfRequestExists(s) {
      return (
        nt.NOT_SAFE_RPC_METHODS.includes(s.method) ||
        nt.SAFE_RPC_METHODS.includes(s.method)
      );
    },
    getResponseType(s) {
      return typeof s == "string" &&
        ((s == null ? void 0 : s.match(Nh.transactionHash)) ||
          (s == null ? void 0 : s.match(Nh.signedMessage)))
        ? te.RPC_RESPONSE_TYPE_TX
        : te.RPC_RESPONSE_TYPE_OBJECT;
    },
    checkIfRequestIsSafe(s) {
      return nt.SAFE_RPC_METHODS.includes(s.method);
    },
    isClient: typeof window < "u",
  };
var Te;
(function (s) {
  s.assertEqual = (r) => r;
  function e(r) {}
  s.assertIs = e;
  function t(r) {
    throw new Error();
  }
  (s.assertNever = t),
    (s.arrayToEnum = (r) => {
      const i = {};
      for (const o of r) i[o] = o;
      return i;
    }),
    (s.getValidEnumValues = (r) => {
      const i = s.objectKeys(r).filter((a) => typeof r[r[a]] != "number"),
        o = {};
      for (const a of i) o[a] = r[a];
      return s.objectValues(o);
    }),
    (s.objectValues = (r) =>
      s.objectKeys(r).map(function (i) {
        return r[i];
      })),
    (s.objectKeys =
      typeof Object.keys == "function"
        ? (r) => Object.keys(r)
        : (r) => {
            const i = [];
            for (const o in r)
              Object.prototype.hasOwnProperty.call(r, o) && i.push(o);
            return i;
          }),
    (s.find = (r, i) => {
      for (const o of r) if (i(o)) return o;
    }),
    (s.isInteger =
      typeof Number.isInteger == "function"
        ? (r) => Number.isInteger(r)
        : (r) => typeof r == "number" && isFinite(r) && Math.floor(r) === r);
  function n(r, i = " | ") {
    return r.map((o) => (typeof o == "string" ? `'${o}'` : o)).join(i);
  }
  (s.joinValues = n),
    (s.jsonStringifyReplacer = (r, i) =>
      typeof i == "bigint" ? i.toString() : i);
})(Te || (Te = {}));
var Nl;
(function (s) {
  s.mergeShapes = (e, t) => ({ ...e, ...t });
})(Nl || (Nl = {}));
const G = Te.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  yn = (s) => {
    switch (typeof s) {
      case "undefined":
        return G.undefined;
      case "string":
        return G.string;
      case "number":
        return isNaN(s) ? G.nan : G.number;
      case "boolean":
        return G.boolean;
      case "function":
        return G.function;
      case "bigint":
        return G.bigint;
      case "symbol":
        return G.symbol;
      case "object":
        return Array.isArray(s)
          ? G.array
          : s === null
          ? G.null
          : s.then &&
            typeof s.then == "function" &&
            s.catch &&
            typeof s.catch == "function"
          ? G.promise
          : typeof Map < "u" && s instanceof Map
          ? G.map
          : typeof Set < "u" && s instanceof Set
          ? G.set
          : typeof Date < "u" && s instanceof Date
          ? G.date
          : G.object;
      default:
        return G.unknown;
    }
  },
  D = Te.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  EN = (s) => JSON.stringify(s, null, 2).replace(/"([^"]+)":/g, "$1:");
class bs extends Error {
  constructor(e) {
    super(),
      (this.issues = []),
      (this.addIssue = (n) => {
        this.issues = [...this.issues, n];
      }),
      (this.addIssues = (n = []) => {
        this.issues = [...this.issues, ...n];
      });
    const t = new.target.prototype;
    Object.setPrototypeOf
      ? Object.setPrototypeOf(this, t)
      : (this.__proto__ = t),
      (this.name = "ZodError"),
      (this.issues = e);
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const t =
        e ||
        function (i) {
          return i.message;
        },
      n = { _errors: [] },
      r = (i) => {
        for (const o of i.issues)
          if (o.code === "invalid_union") o.unionErrors.map(r);
          else if (o.code === "invalid_return_type") r(o.returnTypeError);
          else if (o.code === "invalid_arguments") r(o.argumentsError);
          else if (o.path.length === 0) n._errors.push(t(o));
          else {
            let a = n,
              c = 0;
            for (; c < o.path.length; ) {
              const l = o.path[c];
              c === o.path.length - 1
                ? ((a[l] = a[l] || { _errors: [] }), a[l]._errors.push(t(o)))
                : (a[l] = a[l] || { _errors: [] }),
                (a = a[l]),
                c++;
            }
          }
      };
    return r(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Te.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = {},
      n = [];
    for (const r of this.issues)
      r.path.length > 0
        ? ((t[r.path[0]] = t[r.path[0]] || []), t[r.path[0]].push(e(r)))
        : n.push(e(r));
    return { formErrors: n, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}
bs.create = (s) => new bs(s);
const oo = (s, e) => {
  let t;
  switch (s.code) {
    case D.invalid_type:
      s.received === G.undefined
        ? (t = "Required")
        : (t = `Expected ${s.expected}, received ${s.received}`);
      break;
    case D.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(
        s.expected,
        Te.jsonStringifyReplacer
      )}`;
      break;
    case D.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${Te.joinValues(s.keys, ", ")}`;
      break;
    case D.invalid_union:
      t = "Invalid input";
      break;
    case D.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${Te.joinValues(s.options)}`;
      break;
    case D.invalid_enum_value:
      t = `Invalid enum value. Expected ${Te.joinValues(
        s.options
      )}, received '${s.received}'`;
      break;
    case D.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case D.invalid_return_type:
      t = "Invalid function return type";
      break;
    case D.invalid_date:
      t = "Invalid date";
      break;
    case D.invalid_string:
      typeof s.validation == "object"
        ? "includes" in s.validation
          ? ((t = `Invalid input: must include "${s.validation.includes}"`),
            typeof s.validation.position == "number" &&
              (t = `${t} at one or more positions greater than or equal to ${s.validation.position}`))
          : "startsWith" in s.validation
          ? (t = `Invalid input: must start with "${s.validation.startsWith}"`)
          : "endsWith" in s.validation
          ? (t = `Invalid input: must end with "${s.validation.endsWith}"`)
          : Te.assertNever(s.validation)
        : s.validation !== "regex"
        ? (t = `Invalid ${s.validation}`)
        : (t = "Invalid");
      break;
    case D.too_small:
      s.type === "array"
        ? (t = `Array must contain ${
            s.exact ? "exactly" : s.inclusive ? "at least" : "more than"
          } ${s.minimum} element(s)`)
        : s.type === "string"
        ? (t = `String must contain ${
            s.exact ? "exactly" : s.inclusive ? "at least" : "over"
          } ${s.minimum} character(s)`)
        : s.type === "number"
        ? (t = `Number must be ${
            s.exact
              ? "exactly equal to "
              : s.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${s.minimum}`)
        : s.type === "date"
        ? (t = `Date must be ${
            s.exact
              ? "exactly equal to "
              : s.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${new Date(Number(s.minimum))}`)
        : (t = "Invalid input");
      break;
    case D.too_big:
      s.type === "array"
        ? (t = `Array must contain ${
            s.exact ? "exactly" : s.inclusive ? "at most" : "less than"
          } ${s.maximum} element(s)`)
        : s.type === "string"
        ? (t = `String must contain ${
            s.exact ? "exactly" : s.inclusive ? "at most" : "under"
          } ${s.maximum} character(s)`)
        : s.type === "number"
        ? (t = `Number must be ${
            s.exact
              ? "exactly"
              : s.inclusive
              ? "less than or equal to"
              : "less than"
          } ${s.maximum}`)
        : s.type === "bigint"
        ? (t = `BigInt must be ${
            s.exact
              ? "exactly"
              : s.inclusive
              ? "less than or equal to"
              : "less than"
          } ${s.maximum}`)
        : s.type === "date"
        ? (t = `Date must be ${
            s.exact
              ? "exactly"
              : s.inclusive
              ? "smaller than or equal to"
              : "smaller than"
          } ${new Date(Number(s.maximum))}`)
        : (t = "Invalid input");
      break;
    case D.custom:
      t = "Invalid input";
      break;
    case D.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case D.not_multiple_of:
      t = `Number must be a multiple of ${s.multipleOf}`;
      break;
    case D.not_finite:
      t = "Number must be finite";
      break;
    default:
      (t = e.defaultError), Te.assertNever(s);
  }
  return { message: t };
};
let hg = oo;
function bN(s) {
  hg = s;
}
function va() {
  return hg;
}
const Aa = (s) => {
    const { data: e, path: t, errorMaps: n, issueData: r } = s,
      i = [...t, ...(r.path || [])],
      o = { ...r, path: i };
    let a = "";
    const c = n
      .filter((l) => !!l)
      .slice()
      .reverse();
    for (const l of c) a = l(o, { data: e, defaultError: a }).message;
    return { ...r, path: i, message: r.message || a };
  },
  _N = [];
function X(s, e) {
  const t = Aa({
    issueData: e,
    data: s.data,
    path: s.path,
    errorMaps: [s.common.contextualErrorMap, s.schemaErrorMap, va(), oo].filter(
      (n) => !!n
    ),
  });
  s.common.issues.push(t);
}
class bt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const n = [];
    for (const r of t) {
      if (r.status === "aborted") return pe;
      r.status === "dirty" && e.dirty(), n.push(r.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, t) {
    const n = [];
    for (const r of t) n.push({ key: await r.key, value: await r.value });
    return bt.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, t) {
    const n = {};
    for (const r of t) {
      const { key: i, value: o } = r;
      if (i.status === "aborted" || o.status === "aborted") return pe;
      i.status === "dirty" && e.dirty(),
        o.status === "dirty" && e.dirty(),
        i.value !== "__proto__" &&
          (typeof o.value < "u" || r.alwaysSet) &&
          (n[i.value] = o.value);
    }
    return { status: e.value, value: n };
  }
}
const pe = Object.freeze({ status: "aborted" }),
  pg = (s) => ({ status: "dirty", value: s }),
  Nt = (s) => ({ status: "valid", value: s }),
  Tl = (s) => s.status === "aborted",
  Rl = (s) => s.status === "dirty",
  ao = (s) => s.status === "valid",
  Ia = (s) => typeof Promise < "u" && s instanceof Promise;
var ie;
(function (s) {
  (s.errToObj = (e) => (typeof e == "string" ? { message: e } : e || {})),
    (s.toString = (e) =>
      typeof e == "string" ? e : e == null ? void 0 : e.message);
})(ie || (ie = {}));
class Bs {
  constructor(e, t, n, r) {
    (this._cachedPath = []),
      (this.parent = e),
      (this.data = t),
      (this._path = n),
      (this._key = r);
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    );
  }
}
const Th = (s, e) => {
  if (ao(e)) return { success: !0, data: e.value };
  if (!s.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error) return this._error;
      const t = new bs(s.common.issues);
      return (this._error = t), this._error;
    },
  };
};
function ge(s) {
  if (!s) return {};
  const {
    errorMap: e,
    invalid_type_error: t,
    required_error: n,
    description: r,
  } = s;
  if (e && (t || n))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    );
  return e
    ? { errorMap: e, description: r }
    : {
        errorMap: (o, a) =>
          o.code !== "invalid_type"
            ? { message: a.defaultError }
            : typeof a.data > "u"
            ? { message: n ?? a.defaultError }
            : { message: t ?? a.defaultError },
        description: r,
      };
}
class me {
  constructor(e) {
    (this.spa = this.safeParseAsync),
      (this._def = e),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this));
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return yn(e.data);
  }
  _getOrReturnCtx(e, t) {
    return (
      t || {
        common: e.parent.common,
        data: e.data,
        parsedType: yn(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent,
      }
    );
  }
  _processInputParams(e) {
    return {
      status: new bt(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: yn(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent,
      },
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (Ia(t)) throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const n = this.safeParse(e, t);
    if (n.success) return n.data;
    throw n.error;
  }
  safeParse(e, t) {
    var n;
    const r = {
        common: {
          issues: [],
          async:
            (n = t == null ? void 0 : t.async) !== null && n !== void 0
              ? n
              : !1,
          contextualErrorMap: t == null ? void 0 : t.errorMap,
        },
        path: (t == null ? void 0 : t.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: yn(e),
      },
      i = this._parseSync({ data: e, path: r.path, parent: r });
    return Th(r, i);
  }
  async parseAsync(e, t) {
    const n = await this.safeParseAsync(e, t);
    if (n.success) return n.data;
    throw n.error;
  }
  async safeParseAsync(e, t) {
    const n = {
        common: {
          issues: [],
          contextualErrorMap: t == null ? void 0 : t.errorMap,
          async: !0,
        },
        path: (t == null ? void 0 : t.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: yn(e),
      },
      r = this._parse({ data: e, path: n.path, parent: n }),
      i = await (Ia(r) ? r : Promise.resolve(r));
    return Th(n, i);
  }
  refine(e, t) {
    const n = (r) =>
      typeof t == "string" || typeof t > "u"
        ? { message: t }
        : typeof t == "function"
        ? t(r)
        : t;
    return this._refinement((r, i) => {
      const o = e(r),
        a = () => i.addIssue({ code: D.custom, ...n(r) });
      return typeof Promise < "u" && o instanceof Promise
        ? o.then((c) => (c ? !0 : (a(), !1)))
        : o
        ? !0
        : (a(), !1);
    });
  }
  refinement(e, t) {
    return this._refinement((n, r) =>
      e(n) ? !0 : (r.addIssue(typeof t == "function" ? t(n, r) : t), !1)
    );
  }
  _refinement(e) {
    return new vs({
      schema: this,
      typeName: ue.ZodEffects,
      effect: { type: "refinement", refinement: e },
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return Qs.create(this, this._def);
  }
  nullable() {
    return ir.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return _s.create(this, this._def);
  }
  promise() {
    return Yr.create(this, this._def);
  }
  or(e) {
    return ho.create([this, e], this._def);
  }
  and(e) {
    return po.create(this, e, this._def);
  }
  transform(e) {
    return new vs({
      ...ge(this._def),
      schema: this,
      typeName: ue.ZodEffects,
      effect: { type: "transform", transform: e },
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new yo({
      ...ge(this._def),
      innerType: this,
      defaultValue: t,
      typeName: ue.ZodDefault,
    });
  }
  brand() {
    return new gg({ typeName: ue.ZodBranded, type: this, ...ge(this._def) });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new Ra({
      ...ge(this._def),
      innerType: this,
      catchValue: t,
      typeName: ue.ZodCatch,
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({ ...this._def, description: e });
  }
  pipe(e) {
    return Oo.create(this, e);
  }
  readonly() {
    return Pa.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const CN = /^c[^\s-]{8,}$/i,
  vN = /^[a-z][a-z0-9]*$/,
  AN = /^[0-9A-HJKMNP-TV-Z]{26}$/,
  IN =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  SN =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  NN = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Oc;
const TN =
    /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
  RN =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  xN = (s) =>
    s.precision
      ? s.offset
        ? new RegExp(
            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${s.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
          )
        : new RegExp(
            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${s.precision}}Z$`
          )
      : s.precision === 0
      ? s.offset
        ? new RegExp(
            "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$"
          )
        : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$")
      : s.offset
      ? new RegExp(
          "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"
        )
      : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function PN(s, e) {
  return !!(
    ((e === "v4" || !e) && TN.test(s)) ||
    ((e === "v6" || !e) && RN.test(s))
  );
}
class ys extends me {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = String(e.data)),
      this._getType(e) !== G.string)
    ) {
      const i = this._getOrReturnCtx(e);
      return (
        X(i, {
          code: D.invalid_type,
          expected: G.string,
          received: i.parsedType,
        }),
        pe
      );
    }
    const n = new bt();
    let r;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value &&
          ((r = this._getOrReturnCtx(e, r)),
          X(r, {
            code: D.too_small,
            minimum: i.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i.message,
          }),
          n.dirty());
      else if (i.kind === "max")
        e.data.length > i.value &&
          ((r = this._getOrReturnCtx(e, r)),
          X(r, {
            code: D.too_big,
            maximum: i.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i.message,
          }),
          n.dirty());
      else if (i.kind === "length") {
        const o = e.data.length > i.value,
          a = e.data.length < i.value;
        (o || a) &&
          ((r = this._getOrReturnCtx(e, r)),
          o
            ? X(r, {
                code: D.too_big,
                maximum: i.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i.message,
              })
            : a &&
              X(r, {
                code: D.too_small,
                minimum: i.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i.message,
              }),
          n.dirty());
      } else if (i.kind === "email")
        SN.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          X(r, {
            validation: "email",
            code: D.invalid_string,
            message: i.message,
          }),
          n.dirty());
      else if (i.kind === "emoji")
        Oc || (Oc = new RegExp(NN, "u")),
          Oc.test(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            X(r, {
              validation: "emoji",
              code: D.invalid_string,
              message: i.message,
            }),
            n.dirty());
      else if (i.kind === "uuid")
        IN.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          X(r, {
            validation: "uuid",
            code: D.invalid_string,
            message: i.message,
          }),
          n.dirty());
      else if (i.kind === "cuid")
        CN.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          X(r, {
            validation: "cuid",
            code: D.invalid_string,
            message: i.message,
          }),
          n.dirty());
      else if (i.kind === "cuid2")
        vN.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          X(r, {
            validation: "cuid2",
            code: D.invalid_string,
            message: i.message,
          }),
          n.dirty());
      else if (i.kind === "ulid")
        AN.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          X(r, {
            validation: "ulid",
            code: D.invalid_string,
            message: i.message,
          }),
          n.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          (r = this._getOrReturnCtx(e, r)),
            X(r, {
              validation: "url",
              code: D.invalid_string,
              message: i.message,
            }),
            n.dirty();
        }
      else
        i.kind === "regex"
          ? ((i.regex.lastIndex = 0),
            i.regex.test(e.data) ||
              ((r = this._getOrReturnCtx(e, r)),
              X(r, {
                validation: "regex",
                code: D.invalid_string,
                message: i.message,
              }),
              n.dirty()))
          : i.kind === "trim"
          ? (e.data = e.data.trim())
          : i.kind === "includes"
          ? e.data.includes(i.value, i.position) ||
            ((r = this._getOrReturnCtx(e, r)),
            X(r, {
              code: D.invalid_string,
              validation: { includes: i.value, position: i.position },
              message: i.message,
            }),
            n.dirty())
          : i.kind === "toLowerCase"
          ? (e.data = e.data.toLowerCase())
          : i.kind === "toUpperCase"
          ? (e.data = e.data.toUpperCase())
          : i.kind === "startsWith"
          ? e.data.startsWith(i.value) ||
            ((r = this._getOrReturnCtx(e, r)),
            X(r, {
              code: D.invalid_string,
              validation: { startsWith: i.value },
              message: i.message,
            }),
            n.dirty())
          : i.kind === "endsWith"
          ? e.data.endsWith(i.value) ||
            ((r = this._getOrReturnCtx(e, r)),
            X(r, {
              code: D.invalid_string,
              validation: { endsWith: i.value },
              message: i.message,
            }),
            n.dirty())
          : i.kind === "datetime"
          ? xN(i).test(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            X(r, {
              code: D.invalid_string,
              validation: "datetime",
              message: i.message,
            }),
            n.dirty())
          : i.kind === "ip"
          ? PN(e.data, i.version) ||
            ((r = this._getOrReturnCtx(e, r)),
            X(r, {
              validation: "ip",
              code: D.invalid_string,
              message: i.message,
            }),
            n.dirty())
          : Te.assertNever(i);
    return { status: n.value, value: e.data };
  }
  _regex(e, t, n) {
    return this.refinement((r) => e.test(r), {
      validation: t,
      code: D.invalid_string,
      ...ie.errToObj(n),
    });
  }
  _addCheck(e) {
    return new ys({ ...this._def, checks: [...this._def.checks, e] });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...ie.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...ie.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...ie.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...ie.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...ie.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...ie.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...ie.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...ie.errToObj(e) });
  }
  datetime(e) {
    var t;
    return typeof e == "string"
      ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          message: e,
        })
      : this._addCheck({
          kind: "datetime",
          precision:
            typeof (e == null ? void 0 : e.precision) > "u"
              ? null
              : e == null
              ? void 0
              : e.precision,
          offset:
            (t = e == null ? void 0 : e.offset) !== null && t !== void 0
              ? t
              : !1,
          ...ie.errToObj(e == null ? void 0 : e.message),
        });
  }
  regex(e, t) {
    return this._addCheck({ kind: "regex", regex: e, ...ie.errToObj(t) });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ...ie.errToObj(t == null ? void 0 : t.message),
    });
  }
  startsWith(e, t) {
    return this._addCheck({ kind: "startsWith", value: e, ...ie.errToObj(t) });
  }
  endsWith(e, t) {
    return this._addCheck({ kind: "endsWith", value: e, ...ie.errToObj(t) });
  }
  min(e, t) {
    return this._addCheck({ kind: "min", value: e, ...ie.errToObj(t) });
  }
  max(e, t) {
    return this._addCheck({ kind: "max", value: e, ...ie.errToObj(t) });
  }
  length(e, t) {
    return this._addCheck({ kind: "length", value: e, ...ie.errToObj(t) });
  }
  nonempty(e) {
    return this.min(1, ie.errToObj(e));
  }
  trim() {
    return new ys({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    });
  }
  toLowerCase() {
    return new ys({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    });
  }
  toUpperCase() {
    return new ys({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
ys.create = (s) => {
  var e;
  return new ys({
    checks: [],
    typeName: ue.ZodString,
    coerce:
      (e = s == null ? void 0 : s.coerce) !== null && e !== void 0 ? e : !1,
    ...ge(s),
  });
};
function ON(s, e) {
  const t = (s.toString().split(".")[1] || "").length,
    n = (e.toString().split(".")[1] || "").length,
    r = t > n ? t : n,
    i = parseInt(s.toFixed(r).replace(".", "")),
    o = parseInt(e.toFixed(r).replace(".", ""));
  return (i % o) / Math.pow(10, r);
}
class xn extends me {
  constructor() {
    super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf);
  }
  _parse(e) {
    if (
      (this._def.coerce && (e.data = Number(e.data)),
      this._getType(e) !== G.number)
    ) {
      const i = this._getOrReturnCtx(e);
      return (
        X(i, {
          code: D.invalid_type,
          expected: G.number,
          received: i.parsedType,
        }),
        pe
      );
    }
    let n;
    const r = new bt();
    for (const i of this._def.checks)
      i.kind === "int"
        ? Te.isInteger(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          X(n, {
            code: D.invalid_type,
            expected: "integer",
            received: "float",
            message: i.message,
          }),
          r.dirty())
        : i.kind === "min"
        ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          X(n, {
            code: D.too_small,
            minimum: i.value,
            type: "number",
            inclusive: i.inclusive,
            exact: !1,
            message: i.message,
          }),
          r.dirty())
        : i.kind === "max"
        ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          X(n, {
            code: D.too_big,
            maximum: i.value,
            type: "number",
            inclusive: i.inclusive,
            exact: !1,
            message: i.message,
          }),
          r.dirty())
        : i.kind === "multipleOf"
        ? ON(e.data, i.value) !== 0 &&
          ((n = this._getOrReturnCtx(e, n)),
          X(n, {
            code: D.not_multiple_of,
            multipleOf: i.value,
            message: i.message,
          }),
          r.dirty())
        : i.kind === "finite"
        ? Number.isFinite(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          X(n, { code: D.not_finite, message: i.message }),
          r.dirty())
        : Te.assertNever(i);
    return { status: r.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, ie.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, ie.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, ie.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, ie.toString(t));
  }
  setLimit(e, t, n, r) {
    return new xn({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: t, inclusive: n, message: ie.toString(r) },
      ],
    });
  }
  _addCheck(e) {
    return new xn({ ...this._def, checks: [...this._def.checks, e] });
  }
  int(e) {
    return this._addCheck({ kind: "int", message: ie.toString(e) });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ie.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ie.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ie.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ie.toString(e),
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ie.toString(t),
    });
  }
  finite(e) {
    return this._addCheck({ kind: "finite", message: ie.toString(e) });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ie.toString(e),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ie.toString(e),
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find(
      (e) =>
        e.kind === "int" || (e.kind === "multipleOf" && Te.isInteger(e.value))
    );
  }
  get isFinite() {
    let e = null,
      t = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min"
        ? (t === null || n.value > t) && (t = n.value)
        : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
}
xn.create = (s) =>
  new xn({
    checks: [],
    typeName: ue.ZodNumber,
    coerce: (s == null ? void 0 : s.coerce) || !1,
    ...ge(s),
  });
class Pn extends me {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte);
  }
  _parse(e) {
    if (
      (this._def.coerce && (e.data = BigInt(e.data)),
      this._getType(e) !== G.bigint)
    ) {
      const i = this._getOrReturnCtx(e);
      return (
        X(i, {
          code: D.invalid_type,
          expected: G.bigint,
          received: i.parsedType,
        }),
        pe
      );
    }
    let n;
    const r = new bt();
    for (const i of this._def.checks)
      i.kind === "min"
        ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          X(n, {
            code: D.too_small,
            type: "bigint",
            minimum: i.value,
            inclusive: i.inclusive,
            message: i.message,
          }),
          r.dirty())
        : i.kind === "max"
        ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          X(n, {
            code: D.too_big,
            type: "bigint",
            maximum: i.value,
            inclusive: i.inclusive,
            message: i.message,
          }),
          r.dirty())
        : i.kind === "multipleOf"
        ? e.data % i.value !== BigInt(0) &&
          ((n = this._getOrReturnCtx(e, n)),
          X(n, {
            code: D.not_multiple_of,
            multipleOf: i.value,
            message: i.message,
          }),
          r.dirty())
        : Te.assertNever(i);
    return { status: r.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, ie.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, ie.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, ie.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, ie.toString(t));
  }
  setLimit(e, t, n, r) {
    return new Pn({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: t, inclusive: n, message: ie.toString(r) },
      ],
    });
  }
  _addCheck(e) {
    return new Pn({ ...this._def, checks: [...this._def.checks, e] });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ie.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ie.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ie.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ie.toString(e),
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ie.toString(t),
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
Pn.create = (s) => {
  var e;
  return new Pn({
    checks: [],
    typeName: ue.ZodBigInt,
    coerce:
      (e = s == null ? void 0 : s.coerce) !== null && e !== void 0 ? e : !1,
    ...ge(s),
  });
};
class co extends me {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = !!e.data), this._getType(e) !== G.boolean)
    ) {
      const n = this._getOrReturnCtx(e);
      return (
        X(n, {
          code: D.invalid_type,
          expected: G.boolean,
          received: n.parsedType,
        }),
        pe
      );
    }
    return Nt(e.data);
  }
}
co.create = (s) =>
  new co({
    typeName: ue.ZodBoolean,
    coerce: (s == null ? void 0 : s.coerce) || !1,
    ...ge(s),
  });
class nr extends me {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = new Date(e.data)),
      this._getType(e) !== G.date)
    ) {
      const i = this._getOrReturnCtx(e);
      return (
        X(i, {
          code: D.invalid_type,
          expected: G.date,
          received: i.parsedType,
        }),
        pe
      );
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return X(i, { code: D.invalid_date }), pe;
    }
    const n = new bt();
    let r;
    for (const i of this._def.checks)
      i.kind === "min"
        ? e.data.getTime() < i.value &&
          ((r = this._getOrReturnCtx(e, r)),
          X(r, {
            code: D.too_small,
            message: i.message,
            inclusive: !0,
            exact: !1,
            minimum: i.value,
            type: "date",
          }),
          n.dirty())
        : i.kind === "max"
        ? e.data.getTime() > i.value &&
          ((r = this._getOrReturnCtx(e, r)),
          X(r, {
            code: D.too_big,
            message: i.message,
            inclusive: !0,
            exact: !1,
            maximum: i.value,
            type: "date",
          }),
          n.dirty())
        : Te.assertNever(i);
    return { status: n.value, value: new Date(e.data.getTime()) };
  }
  _addCheck(e) {
    return new nr({ ...this._def, checks: [...this._def.checks, e] });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: ie.toString(t),
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: ie.toString(t),
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
}
nr.create = (s) =>
  new nr({
    checks: [],
    coerce: (s == null ? void 0 : s.coerce) || !1,
    typeName: ue.ZodDate,
    ...ge(s),
  });
class Sa extends me {
  _parse(e) {
    if (this._getType(e) !== G.symbol) {
      const n = this._getOrReturnCtx(e);
      return (
        X(n, {
          code: D.invalid_type,
          expected: G.symbol,
          received: n.parsedType,
        }),
        pe
      );
    }
    return Nt(e.data);
  }
}
Sa.create = (s) => new Sa({ typeName: ue.ZodSymbol, ...ge(s) });
class lo extends me {
  _parse(e) {
    if (this._getType(e) !== G.undefined) {
      const n = this._getOrReturnCtx(e);
      return (
        X(n, {
          code: D.invalid_type,
          expected: G.undefined,
          received: n.parsedType,
        }),
        pe
      );
    }
    return Nt(e.data);
  }
}
lo.create = (s) => new lo({ typeName: ue.ZodUndefined, ...ge(s) });
class uo extends me {
  _parse(e) {
    if (this._getType(e) !== G.null) {
      const n = this._getOrReturnCtx(e);
      return (
        X(n, {
          code: D.invalid_type,
          expected: G.null,
          received: n.parsedType,
        }),
        pe
      );
    }
    return Nt(e.data);
  }
}
uo.create = (s) => new uo({ typeName: ue.ZodNull, ...ge(s) });
class Gr extends me {
  constructor() {
    super(...arguments), (this._any = !0);
  }
  _parse(e) {
    return Nt(e.data);
  }
}
Gr.create = (s) => new Gr({ typeName: ue.ZodAny, ...ge(s) });
class Jn extends me {
  constructor() {
    super(...arguments), (this._unknown = !0);
  }
  _parse(e) {
    return Nt(e.data);
  }
}
Jn.create = (s) => new Jn({ typeName: ue.ZodUnknown, ...ge(s) });
class sn extends me {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return (
      X(t, { code: D.invalid_type, expected: G.never, received: t.parsedType }),
      pe
    );
  }
}
sn.create = (s) => new sn({ typeName: ue.ZodNever, ...ge(s) });
class Na extends me {
  _parse(e) {
    if (this._getType(e) !== G.undefined) {
      const n = this._getOrReturnCtx(e);
      return (
        X(n, {
          code: D.invalid_type,
          expected: G.void,
          received: n.parsedType,
        }),
        pe
      );
    }
    return Nt(e.data);
  }
}
Na.create = (s) => new Na({ typeName: ue.ZodVoid, ...ge(s) });
class _s extends me {
  _parse(e) {
    const { ctx: t, status: n } = this._processInputParams(e),
      r = this._def;
    if (t.parsedType !== G.array)
      return (
        X(t, {
          code: D.invalid_type,
          expected: G.array,
          received: t.parsedType,
        }),
        pe
      );
    if (r.exactLength !== null) {
      const o = t.data.length > r.exactLength.value,
        a = t.data.length < r.exactLength.value;
      (o || a) &&
        (X(t, {
          code: o ? D.too_big : D.too_small,
          minimum: a ? r.exactLength.value : void 0,
          maximum: o ? r.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: r.exactLength.message,
        }),
        n.dirty());
    }
    if (
      (r.minLength !== null &&
        t.data.length < r.minLength.value &&
        (X(t, {
          code: D.too_small,
          minimum: r.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: r.minLength.message,
        }),
        n.dirty()),
      r.maxLength !== null &&
        t.data.length > r.maxLength.value &&
        (X(t, {
          code: D.too_big,
          maximum: r.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: r.maxLength.message,
        }),
        n.dirty()),
      t.common.async)
    )
      return Promise.all(
        [...t.data].map((o, a) => r.type._parseAsync(new Bs(t, o, t.path, a)))
      ).then((o) => bt.mergeArray(n, o));
    const i = [...t.data].map((o, a) =>
      r.type._parseSync(new Bs(t, o, t.path, a))
    );
    return bt.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new _s({
      ...this._def,
      minLength: { value: e, message: ie.toString(t) },
    });
  }
  max(e, t) {
    return new _s({
      ...this._def,
      maxLength: { value: e, message: ie.toString(t) },
    });
  }
  length(e, t) {
    return new _s({
      ...this._def,
      exactLength: { value: e, message: ie.toString(t) },
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
_s.create = (s, e) =>
  new _s({
    type: s,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ue.ZodArray,
    ...ge(e),
  });
function Ur(s) {
  if (s instanceof Ke) {
    const e = {};
    for (const t in s.shape) {
      const n = s.shape[t];
      e[t] = Qs.create(Ur(n));
    }
    return new Ke({ ...s._def, shape: () => e });
  } else
    return s instanceof _s
      ? new _s({ ...s._def, type: Ur(s.element) })
      : s instanceof Qs
      ? Qs.create(Ur(s.unwrap()))
      : s instanceof ir
      ? ir.create(Ur(s.unwrap()))
      : s instanceof Fs
      ? Fs.create(s.items.map((e) => Ur(e)))
      : s;
}
class Ke extends me {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend);
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const e = this._def.shape(),
      t = Te.objectKeys(e);
    return (this._cached = { shape: e, keys: t });
  }
  _parse(e) {
    if (this._getType(e) !== G.object) {
      const l = this._getOrReturnCtx(e);
      return (
        X(l, {
          code: D.invalid_type,
          expected: G.object,
          received: l.parsedType,
        }),
        pe
      );
    }
    const { status: n, ctx: r } = this._processInputParams(e),
      { shape: i, keys: o } = this._getCached(),
      a = [];
    if (
      !(this._def.catchall instanceof sn && this._def.unknownKeys === "strip")
    )
      for (const l in r.data) o.includes(l) || a.push(l);
    const c = [];
    for (const l of o) {
      const d = i[l],
        u = r.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: d._parse(new Bs(r, u, r.path, l)),
        alwaysSet: l in r.data,
      });
    }
    if (this._def.catchall instanceof sn) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const d of a)
          c.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: r.data[d] },
          });
      else if (l === "strict")
        a.length > 0 &&
          (X(r, { code: D.unrecognized_keys, keys: a }), n.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const d of a) {
        const u = r.data[d];
        c.push({
          key: { status: "valid", value: d },
          value: l._parse(new Bs(r, u, r.path, d)),
          alwaysSet: d in r.data,
        });
      }
    }
    return r.common.async
      ? Promise.resolve()
          .then(async () => {
            const l = [];
            for (const d of c) {
              const u = await d.key;
              l.push({ key: u, value: await d.value, alwaysSet: d.alwaysSet });
            }
            return l;
          })
          .then((l) => bt.mergeObjectSync(n, l))
      : bt.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return (
      ie.errToObj,
      new Ke({
        ...this._def,
        unknownKeys: "strict",
        ...(e !== void 0
          ? {
              errorMap: (t, n) => {
                var r, i, o, a;
                const c =
                  (o =
                    (i = (r = this._def).errorMap) === null || i === void 0
                      ? void 0
                      : i.call(r, t, n).message) !== null && o !== void 0
                    ? o
                    : n.defaultError;
                return t.code === "unrecognized_keys"
                  ? {
                      message:
                        (a = ie.errToObj(e).message) !== null && a !== void 0
                          ? a
                          : c,
                    }
                  : { message: c };
              },
            }
          : {}),
      })
    );
  }
  strip() {
    return new Ke({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new Ke({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(e) {
    return new Ke({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...e }),
    });
  }
  merge(e) {
    return new Ke({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
      typeName: ue.ZodObject,
    });
  }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  catchall(e) {
    return new Ke({ ...this._def, catchall: e });
  }
  pick(e) {
    const t = {};
    return (
      Te.objectKeys(e).forEach((n) => {
        e[n] && this.shape[n] && (t[n] = this.shape[n]);
      }),
      new Ke({ ...this._def, shape: () => t })
    );
  }
  omit(e) {
    const t = {};
    return (
      Te.objectKeys(this.shape).forEach((n) => {
        e[n] || (t[n] = this.shape[n]);
      }),
      new Ke({ ...this._def, shape: () => t })
    );
  }
  deepPartial() {
    return Ur(this);
  }
  partial(e) {
    const t = {};
    return (
      Te.objectKeys(this.shape).forEach((n) => {
        const r = this.shape[n];
        e && !e[n] ? (t[n] = r) : (t[n] = r.optional());
      }),
      new Ke({ ...this._def, shape: () => t })
    );
  }
  required(e) {
    const t = {};
    return (
      Te.objectKeys(this.shape).forEach((n) => {
        if (e && !e[n]) t[n] = this.shape[n];
        else {
          let i = this.shape[n];
          for (; i instanceof Qs; ) i = i._def.innerType;
          t[n] = i;
        }
      }),
      new Ke({ ...this._def, shape: () => t })
    );
  }
  keyof() {
    return fg(Te.objectKeys(this.shape));
  }
}
Ke.create = (s, e) =>
  new Ke({
    shape: () => s,
    unknownKeys: "strip",
    catchall: sn.create(),
    typeName: ue.ZodObject,
    ...ge(e),
  });
Ke.strictCreate = (s, e) =>
  new Ke({
    shape: () => s,
    unknownKeys: "strict",
    catchall: sn.create(),
    typeName: ue.ZodObject,
    ...ge(e),
  });
Ke.lazycreate = (s, e) =>
  new Ke({
    shape: s,
    unknownKeys: "strip",
    catchall: sn.create(),
    typeName: ue.ZodObject,
    ...ge(e),
  });
class ho extends me {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e),
      n = this._def.options;
    function r(i) {
      for (const a of i) if (a.result.status === "valid") return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return t.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((a) => new bs(a.ctx.common.issues));
      return X(t, { code: D.invalid_union, unionErrors: o }), pe;
    }
    if (t.common.async)
      return Promise.all(
        n.map(async (i) => {
          const o = { ...t, common: { ...t.common, issues: [] }, parent: null };
          return {
            result: await i._parseAsync({
              data: t.data,
              path: t.path,
              parent: o,
            }),
            ctx: o,
          };
        })
      ).then(r);
    {
      let i;
      const o = [];
      for (const c of n) {
        const l = { ...t, common: { ...t.common, issues: [] }, parent: null },
          d = c._parseSync({ data: t.data, path: t.path, parent: l });
        if (d.status === "valid") return d;
        d.status === "dirty" && !i && (i = { result: d, ctx: l }),
          l.common.issues.length && o.push(l.common.issues);
      }
      if (i) return t.common.issues.push(...i.ctx.common.issues), i.result;
      const a = o.map((c) => new bs(c));
      return X(t, { code: D.invalid_union, unionErrors: a }), pe;
    }
  }
  get options() {
    return this._def.options;
  }
}
ho.create = (s, e) => new ho({ options: s, typeName: ue.ZodUnion, ...ge(e) });
const na = (s) =>
  s instanceof go
    ? na(s.schema)
    : s instanceof vs
    ? na(s.innerType())
    : s instanceof mo
    ? [s.value]
    : s instanceof On
    ? s.options
    : s instanceof wo
    ? Object.keys(s.enum)
    : s instanceof yo
    ? na(s._def.innerType)
    : s instanceof lo
    ? [void 0]
    : s instanceof uo
    ? [null]
    : null;
class Ka extends me {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== G.object)
      return (
        X(t, {
          code: D.invalid_type,
          expected: G.object,
          received: t.parsedType,
        }),
        pe
      );
    const n = this.discriminator,
      r = t.data[n],
      i = this.optionsMap.get(r);
    return i
      ? t.common.async
        ? i._parseAsync({ data: t.data, path: t.path, parent: t })
        : i._parseSync({ data: t.data, path: t.path, parent: t })
      : (X(t, {
          code: D.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [n],
        }),
        pe);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(e, t, n) {
    const r = new Map();
    for (const i of t) {
      const o = na(i.shape[e]);
      if (!o)
        throw new Error(
          `A discriminator value for key \`${e}\` could not be extracted from all schema options`
        );
      for (const a of o) {
        if (r.has(a))
          throw new Error(
            `Discriminator property ${String(e)} has duplicate value ${String(
              a
            )}`
          );
        r.set(a, i);
      }
    }
    return new Ka({
      typeName: ue.ZodDiscriminatedUnion,
      discriminator: e,
      options: t,
      optionsMap: r,
      ...ge(n),
    });
  }
}
function xl(s, e) {
  const t = yn(s),
    n = yn(e);
  if (s === e) return { valid: !0, data: s };
  if (t === G.object && n === G.object) {
    const r = Te.objectKeys(e),
      i = Te.objectKeys(s).filter((a) => r.indexOf(a) !== -1),
      o = { ...s, ...e };
    for (const a of i) {
      const c = xl(s[a], e[a]);
      if (!c.valid) return { valid: !1 };
      o[a] = c.data;
    }
    return { valid: !0, data: o };
  } else if (t === G.array && n === G.array) {
    if (s.length !== e.length) return { valid: !1 };
    const r = [];
    for (let i = 0; i < s.length; i++) {
      const o = s[i],
        a = e[i],
        c = xl(o, a);
      if (!c.valid) return { valid: !1 };
      r.push(c.data);
    }
    return { valid: !0, data: r };
  } else
    return t === G.date && n === G.date && +s == +e
      ? { valid: !0, data: s }
      : { valid: !1 };
}
class po extends me {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e),
      r = (i, o) => {
        if (Tl(i) || Tl(o)) return pe;
        const a = xl(i.value, o.value);
        return a.valid
          ? ((Rl(i) || Rl(o)) && t.dirty(), { status: t.value, value: a.data })
          : (X(n, { code: D.invalid_intersection_types }), pe);
      };
    return n.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          }),
        ]).then(([i, o]) => r(i, o))
      : r(
          this._def.left._parseSync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseSync({ data: n.data, path: n.path, parent: n })
        );
  }
}
po.create = (s, e, t) =>
  new po({ left: s, right: e, typeName: ue.ZodIntersection, ...ge(t) });
class Fs extends me {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== G.array)
      return (
        X(n, {
          code: D.invalid_type,
          expected: G.array,
          received: n.parsedType,
        }),
        pe
      );
    if (n.data.length < this._def.items.length)
      return (
        X(n, {
          code: D.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        pe
      );
    !this._def.rest &&
      n.data.length > this._def.items.length &&
      (X(n, {
        code: D.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
      t.dirty());
    const i = [...n.data]
      .map((o, a) => {
        const c = this._def.items[a] || this._def.rest;
        return c ? c._parse(new Bs(n, o, n.path, a)) : null;
      })
      .filter((o) => !!o);
    return n.common.async
      ? Promise.all(i).then((o) => bt.mergeArray(t, o))
      : bt.mergeArray(t, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Fs({ ...this._def, rest: e });
  }
}
Fs.create = (s, e) => {
  if (!Array.isArray(s))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Fs({ items: s, typeName: ue.ZodTuple, rest: null, ...ge(e) });
};
class fo extends me {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== G.object)
      return (
        X(n, {
          code: D.invalid_type,
          expected: G.object,
          received: n.parsedType,
        }),
        pe
      );
    const r = [],
      i = this._def.keyType,
      o = this._def.valueType;
    for (const a in n.data)
      r.push({
        key: i._parse(new Bs(n, a, n.path, a)),
        value: o._parse(new Bs(n, n.data[a], n.path, a)),
      });
    return n.common.async
      ? bt.mergeObjectAsync(t, r)
      : bt.mergeObjectSync(t, r);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, t, n) {
    return t instanceof me
      ? new fo({ keyType: e, valueType: t, typeName: ue.ZodRecord, ...ge(n) })
      : new fo({
          keyType: ys.create(),
          valueType: e,
          typeName: ue.ZodRecord,
          ...ge(t),
        });
  }
}
class Ta extends me {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== G.map)
      return (
        X(n, { code: D.invalid_type, expected: G.map, received: n.parsedType }),
        pe
      );
    const r = this._def.keyType,
      i = this._def.valueType,
      o = [...n.data.entries()].map(([a, c], l) => ({
        key: r._parse(new Bs(n, a, n.path, [l, "key"])),
        value: i._parse(new Bs(n, c, n.path, [l, "value"])),
      }));
    if (n.common.async) {
      const a = new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const l = await c.key,
            d = await c.value;
          if (l.status === "aborted" || d.status === "aborted") return pe;
          (l.status === "dirty" || d.status === "dirty") && t.dirty(),
            a.set(l.value, d.value);
        }
        return { status: t.value, value: a };
      });
    } else {
      const a = new Map();
      for (const c of o) {
        const l = c.key,
          d = c.value;
        if (l.status === "aborted" || d.status === "aborted") return pe;
        (l.status === "dirty" || d.status === "dirty") && t.dirty(),
          a.set(l.value, d.value);
      }
      return { status: t.value, value: a };
    }
  }
}
Ta.create = (s, e, t) =>
  new Ta({ valueType: e, keyType: s, typeName: ue.ZodMap, ...ge(t) });
class rr extends me {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== G.set)
      return (
        X(n, { code: D.invalid_type, expected: G.set, received: n.parsedType }),
        pe
      );
    const r = this._def;
    r.minSize !== null &&
      n.data.size < r.minSize.value &&
      (X(n, {
        code: D.too_small,
        minimum: r.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: r.minSize.message,
      }),
      t.dirty()),
      r.maxSize !== null &&
        n.data.size > r.maxSize.value &&
        (X(n, {
          code: D.too_big,
          maximum: r.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: r.maxSize.message,
        }),
        t.dirty());
    const i = this._def.valueType;
    function o(c) {
      const l = new Set();
      for (const d of c) {
        if (d.status === "aborted") return pe;
        d.status === "dirty" && t.dirty(), l.add(d.value);
      }
      return { status: t.value, value: l };
    }
    const a = [...n.data.values()].map((c, l) =>
      i._parse(new Bs(n, c, n.path, l))
    );
    return n.common.async ? Promise.all(a).then((c) => o(c)) : o(a);
  }
  min(e, t) {
    return new rr({
      ...this._def,
      minSize: { value: e, message: ie.toString(t) },
    });
  }
  max(e, t) {
    return new rr({
      ...this._def,
      maxSize: { value: e, message: ie.toString(t) },
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
rr.create = (s, e) =>
  new rr({
    valueType: s,
    minSize: null,
    maxSize: null,
    typeName: ue.ZodSet,
    ...ge(e),
  });
class jr extends me {
  constructor() {
    super(...arguments), (this.validate = this.implement);
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== G.function)
      return (
        X(t, {
          code: D.invalid_type,
          expected: G.function,
          received: t.parsedType,
        }),
        pe
      );
    function n(a, c) {
      return Aa({
        data: a,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          va(),
          oo,
        ].filter((l) => !!l),
        issueData: { code: D.invalid_arguments, argumentsError: c },
      });
    }
    function r(a, c) {
      return Aa({
        data: a,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          va(),
          oo,
        ].filter((l) => !!l),
        issueData: { code: D.invalid_return_type, returnTypeError: c },
      });
    }
    const i = { errorMap: t.common.contextualErrorMap },
      o = t.data;
    if (this._def.returns instanceof Yr) {
      const a = this;
      return Nt(async function (...c) {
        const l = new bs([]),
          d = await a._def.args.parseAsync(c, i).catch((w) => {
            throw (l.addIssue(n(c, w)), l);
          }),
          u = await Reflect.apply(o, this, d);
        return await a._def.returns._def.type.parseAsync(u, i).catch((w) => {
          throw (l.addIssue(r(u, w)), l);
        });
      });
    } else {
      const a = this;
      return Nt(function (...c) {
        const l = a._def.args.safeParse(c, i);
        if (!l.success) throw new bs([n(c, l.error)]);
        const d = Reflect.apply(o, this, l.data),
          u = a._def.returns.safeParse(d, i);
        if (!u.success) throw new bs([r(d, u.error)]);
        return u.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new jr({ ...this._def, args: Fs.create(e).rest(Jn.create()) });
  }
  returns(e) {
    return new jr({ ...this._def, returns: e });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, t, n) {
    return new jr({
      args: e || Fs.create([]).rest(Jn.create()),
      returns: t || Jn.create(),
      typeName: ue.ZodFunction,
      ...ge(n),
    });
  }
}
class go extends me {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}
go.create = (s, e) => new go({ getter: s, typeName: ue.ZodLazy, ...ge(e) });
class mo extends me {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return (
        X(t, {
          received: t.data,
          code: D.invalid_literal,
          expected: this._def.value,
        }),
        pe
      );
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
mo.create = (s, e) => new mo({ value: s, typeName: ue.ZodLiteral, ...ge(e) });
function fg(s, e) {
  return new On({ values: s, typeName: ue.ZodEnum, ...ge(e) });
}
class On extends me {
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e),
        n = this._def.values;
      return (
        X(t, {
          expected: Te.joinValues(n),
          received: t.parsedType,
          code: D.invalid_type,
        }),
        pe
      );
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const t = this._getOrReturnCtx(e),
        n = this._def.values;
      return (
        X(t, { received: t.data, code: D.invalid_enum_value, options: n }), pe
      );
    }
    return Nt(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values) e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values) e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values) e[t] = t;
    return e;
  }
  extract(e) {
    return On.create(e);
  }
  exclude(e) {
    return On.create(this.options.filter((t) => !e.includes(t)));
  }
}
On.create = fg;
class wo extends me {
  _parse(e) {
    const t = Te.getValidEnumValues(this._def.values),
      n = this._getOrReturnCtx(e);
    if (n.parsedType !== G.string && n.parsedType !== G.number) {
      const r = Te.objectValues(t);
      return (
        X(n, {
          expected: Te.joinValues(r),
          received: n.parsedType,
          code: D.invalid_type,
        }),
        pe
      );
    }
    if (t.indexOf(e.data) === -1) {
      const r = Te.objectValues(t);
      return (
        X(n, { received: n.data, code: D.invalid_enum_value, options: r }), pe
      );
    }
    return Nt(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
wo.create = (s, e) =>
  new wo({ values: s, typeName: ue.ZodNativeEnum, ...ge(e) });
class Yr extends me {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== G.promise && t.common.async === !1)
      return (
        X(t, {
          code: D.invalid_type,
          expected: G.promise,
          received: t.parsedType,
        }),
        pe
      );
    const n = t.parsedType === G.promise ? t.data : Promise.resolve(t.data);
    return Nt(
      n.then((r) =>
        this._def.type.parseAsync(r, {
          path: t.path,
          errorMap: t.common.contextualErrorMap,
        })
      )
    );
  }
}
Yr.create = (s, e) => new Yr({ type: s, typeName: ue.ZodPromise, ...ge(e) });
class vs extends me {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ue.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e),
      r = this._def.effect || null,
      i = {
        addIssue: (o) => {
          X(n, o), o.fatal ? t.abort() : t.dirty();
        },
        get path() {
          return n.path;
        },
      };
    if (((i.addIssue = i.addIssue.bind(i)), r.type === "preprocess")) {
      const o = r.transform(n.data, i);
      return n.common.issues.length
        ? { status: "dirty", value: n.data }
        : n.common.async
        ? Promise.resolve(o).then((a) =>
            this._def.schema._parseAsync({ data: a, path: n.path, parent: n })
          )
        : this._def.schema._parseSync({ data: o, path: n.path, parent: n });
    }
    if (r.type === "refinement") {
      const o = (a) => {
        const c = r.refinement(a, i);
        if (n.common.async) return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return a;
      };
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        return a.status === "aborted"
          ? pe
          : (a.status === "dirty" && t.dirty(),
            o(a.value),
            { status: t.value, value: a.value });
      } else
        return this._def.schema
          ._parseAsync({ data: n.data, path: n.path, parent: n })
          .then((a) =>
            a.status === "aborted"
              ? pe
              : (a.status === "dirty" && t.dirty(),
                o(a.value).then(() => ({ status: t.value, value: a.value })))
          );
    }
    if (r.type === "transform")
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        if (!ao(o)) return o;
        const a = r.transform(o.value, i);
        if (a instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return { status: t.value, value: a };
      } else
        return this._def.schema
          ._parseAsync({ data: n.data, path: n.path, parent: n })
          .then((o) =>
            ao(o)
              ? Promise.resolve(r.transform(o.value, i)).then((a) => ({
                  status: t.value,
                  value: a,
                }))
              : o
          );
    Te.assertNever(r);
  }
}
vs.create = (s, e, t) =>
  new vs({ schema: s, typeName: ue.ZodEffects, effect: e, ...ge(t) });
vs.createWithPreprocess = (s, e, t) =>
  new vs({
    schema: e,
    effect: { type: "preprocess", transform: s },
    typeName: ue.ZodEffects,
    ...ge(t),
  });
class Qs extends me {
  _parse(e) {
    return this._getType(e) === G.undefined
      ? Nt(void 0)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Qs.create = (s, e) =>
  new Qs({ innerType: s, typeName: ue.ZodOptional, ...ge(e) });
class ir extends me {
  _parse(e) {
    return this._getType(e) === G.null
      ? Nt(null)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ir.create = (s, e) =>
  new ir({ innerType: s, typeName: ue.ZodNullable, ...ge(e) });
class yo extends me {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let n = t.data;
    return (
      t.parsedType === G.undefined && (n = this._def.defaultValue()),
      this._def.innerType._parse({ data: n, path: t.path, parent: t })
    );
  }
  removeDefault() {
    return this._def.innerType;
  }
}
yo.create = (s, e) =>
  new yo({
    innerType: s,
    typeName: ue.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...ge(e),
  });
class Ra extends me {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e),
      n = { ...t, common: { ...t.common, issues: [] } },
      r = this._def.innerType._parse({
        data: n.data,
        path: n.path,
        parent: { ...n },
      });
    return Ia(r)
      ? r.then((i) => ({
          status: "valid",
          value:
            i.status === "valid"
              ? i.value
              : this._def.catchValue({
                  get error() {
                    return new bs(n.common.issues);
                  },
                  input: n.data,
                }),
        }))
      : {
          status: "valid",
          value:
            r.status === "valid"
              ? r.value
              : this._def.catchValue({
                  get error() {
                    return new bs(n.common.issues);
                  },
                  input: n.data,
                }),
        };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Ra.create = (s, e) =>
  new Ra({
    innerType: s,
    typeName: ue.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...ge(e),
  });
class xa extends me {
  _parse(e) {
    if (this._getType(e) !== G.nan) {
      const n = this._getOrReturnCtx(e);
      return (
        X(n, { code: D.invalid_type, expected: G.nan, received: n.parsedType }),
        pe
      );
    }
    return { status: "valid", value: e.data };
  }
}
xa.create = (s) => new xa({ typeName: ue.ZodNaN, ...ge(s) });
const kN = Symbol("zod_brand");
class gg extends me {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e),
      n = t.data;
    return this._def.type._parse({ data: n, path: t.path, parent: t });
  }
  unwrap() {
    return this._def.type;
  }
}
class Oo extends me {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        return i.status === "aborted"
          ? pe
          : i.status === "dirty"
          ? (t.dirty(), pg(i.value))
          : this._def.out._parseAsync({
              data: i.value,
              path: n.path,
              parent: n,
            });
      })();
    {
      const r = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n,
      });
      return r.status === "aborted"
        ? pe
        : r.status === "dirty"
        ? (t.dirty(), { status: "dirty", value: r.value })
        : this._def.out._parseSync({ data: r.value, path: n.path, parent: n });
    }
  }
  static create(e, t) {
    return new Oo({ in: e, out: t, typeName: ue.ZodPipeline });
  }
}
class Pa extends me {
  _parse(e) {
    const t = this._def.innerType._parse(e);
    return ao(t) && (t.value = Object.freeze(t.value)), t;
  }
}
Pa.create = (s, e) =>
  new Pa({ innerType: s, typeName: ue.ZodReadonly, ...ge(e) });
const mg = (s, e = {}, t) =>
    s
      ? Gr.create().superRefine((n, r) => {
          var i, o;
          if (!s(n)) {
            const a =
                typeof e == "function"
                  ? e(n)
                  : typeof e == "string"
                  ? { message: e }
                  : e,
              c =
                (o = (i = a.fatal) !== null && i !== void 0 ? i : t) !== null &&
                o !== void 0
                  ? o
                  : !0,
              l = typeof a == "string" ? { message: a } : a;
            r.addIssue({ code: "custom", ...l, fatal: c });
          }
        })
      : Gr.create(),
  UN = { object: Ke.lazycreate };
var ue;
(function (s) {
  (s.ZodString = "ZodString"),
    (s.ZodNumber = "ZodNumber"),
    (s.ZodNaN = "ZodNaN"),
    (s.ZodBigInt = "ZodBigInt"),
    (s.ZodBoolean = "ZodBoolean"),
    (s.ZodDate = "ZodDate"),
    (s.ZodSymbol = "ZodSymbol"),
    (s.ZodUndefined = "ZodUndefined"),
    (s.ZodNull = "ZodNull"),
    (s.ZodAny = "ZodAny"),
    (s.ZodUnknown = "ZodUnknown"),
    (s.ZodNever = "ZodNever"),
    (s.ZodVoid = "ZodVoid"),
    (s.ZodArray = "ZodArray"),
    (s.ZodObject = "ZodObject"),
    (s.ZodUnion = "ZodUnion"),
    (s.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (s.ZodIntersection = "ZodIntersection"),
    (s.ZodTuple = "ZodTuple"),
    (s.ZodRecord = "ZodRecord"),
    (s.ZodMap = "ZodMap"),
    (s.ZodSet = "ZodSet"),
    (s.ZodFunction = "ZodFunction"),
    (s.ZodLazy = "ZodLazy"),
    (s.ZodLiteral = "ZodLiteral"),
    (s.ZodEnum = "ZodEnum"),
    (s.ZodEffects = "ZodEffects"),
    (s.ZodNativeEnum = "ZodNativeEnum"),
    (s.ZodOptional = "ZodOptional"),
    (s.ZodNullable = "ZodNullable"),
    (s.ZodDefault = "ZodDefault"),
    (s.ZodCatch = "ZodCatch"),
    (s.ZodPromise = "ZodPromise"),
    (s.ZodBranded = "ZodBranded"),
    (s.ZodPipeline = "ZodPipeline"),
    (s.ZodReadonly = "ZodReadonly");
})(ue || (ue = {}));
const $N = (s, e = { message: `Input not instance of ${s.name}` }) =>
    mg((t) => t instanceof s, e),
  wg = ys.create,
  yg = xn.create,
  DN = xa.create,
  LN = Pn.create,
  Eg = co.create,
  MN = nr.create,
  BN = Sa.create,
  FN = lo.create,
  jN = uo.create,
  qN = Gr.create,
  HN = Jn.create,
  WN = sn.create,
  zN = Na.create,
  VN = _s.create,
  KN = Ke.create,
  GN = Ke.strictCreate,
  YN = ho.create,
  ZN = Ka.create,
  JN = po.create,
  XN = Fs.create,
  QN = fo.create,
  eT = Ta.create,
  tT = rr.create,
  sT = jr.create,
  nT = go.create,
  rT = mo.create,
  iT = On.create,
  oT = wo.create,
  aT = Yr.create,
  Rh = vs.create,
  cT = Qs.create,
  lT = ir.create,
  dT = vs.createWithPreprocess,
  uT = Oo.create,
  hT = () => wg().optional(),
  pT = () => yg().optional(),
  fT = () => Eg().optional(),
  gT = {
    string: (s) => ys.create({ ...s, coerce: !0 }),
    number: (s) => xn.create({ ...s, coerce: !0 }),
    boolean: (s) => co.create({ ...s, coerce: !0 }),
    bigint: (s) => Pn.create({ ...s, coerce: !0 }),
    date: (s) => nr.create({ ...s, coerce: !0 }),
  },
  mT = pe;
var h = Object.freeze({
  __proto__: null,
  defaultErrorMap: oo,
  setErrorMap: bN,
  getErrorMap: va,
  makeIssue: Aa,
  EMPTY_PATH: _N,
  addIssueToContext: X,
  ParseStatus: bt,
  INVALID: pe,
  DIRTY: pg,
  OK: Nt,
  isAborted: Tl,
  isDirty: Rl,
  isValid: ao,
  isAsync: Ia,
  get util() {
    return Te;
  },
  get objectUtil() {
    return Nl;
  },
  ZodParsedType: G,
  getParsedType: yn,
  ZodType: me,
  ZodString: ys,
  ZodNumber: xn,
  ZodBigInt: Pn,
  ZodBoolean: co,
  ZodDate: nr,
  ZodSymbol: Sa,
  ZodUndefined: lo,
  ZodNull: uo,
  ZodAny: Gr,
  ZodUnknown: Jn,
  ZodNever: sn,
  ZodVoid: Na,
  ZodArray: _s,
  ZodObject: Ke,
  ZodUnion: ho,
  ZodDiscriminatedUnion: Ka,
  ZodIntersection: po,
  ZodTuple: Fs,
  ZodRecord: fo,
  ZodMap: Ta,
  ZodSet: rr,
  ZodFunction: jr,
  ZodLazy: go,
  ZodLiteral: mo,
  ZodEnum: On,
  ZodNativeEnum: wo,
  ZodPromise: Yr,
  ZodEffects: vs,
  ZodTransformer: vs,
  ZodOptional: Qs,
  ZodNullable: ir,
  ZodDefault: yo,
  ZodCatch: Ra,
  ZodNaN: xa,
  BRAND: kN,
  ZodBranded: gg,
  ZodPipeline: Oo,
  ZodReadonly: Pa,
  custom: mg,
  Schema: me,
  ZodSchema: me,
  late: UN,
  get ZodFirstPartyTypeKind() {
    return ue;
  },
  coerce: gT,
  any: qN,
  array: VN,
  bigint: LN,
  boolean: Eg,
  date: MN,
  discriminatedUnion: ZN,
  effect: Rh,
  enum: iT,
  function: sT,
  instanceof: $N,
  intersection: JN,
  lazy: nT,
  literal: rT,
  map: eT,
  nan: DN,
  nativeEnum: oT,
  never: WN,
  null: jN,
  nullable: lT,
  number: yg,
  object: KN,
  oboolean: fT,
  onumber: pT,
  optional: cT,
  ostring: hT,
  pipeline: uT,
  preprocess: dT,
  promise: aT,
  record: QN,
  set: tT,
  strictObject: GN,
  string: wg,
  symbol: BN,
  transformer: Rh,
  tuple: XN,
  undefined: FN,
  union: YN,
  unknown: HN,
  void: zN,
  NEVER: mT,
  ZodIssueCode: D,
  quotelessJson: EN,
  ZodError: bs,
});
const Ge = h.object({ message: h.string() });
function Y(s) {
  return h.literal(te[s]);
}
const Ga = h.object({
  serializedMessage: h.string().optional(),
  accountAddress: h.string(),
  chainId: h.string(),
  notBefore: h.string().optional(),
  domain: h.string(),
  uri: h.string(),
  version: h.string(),
  nonce: h.string(),
  statement: h.string().optional(),
  resources: h.array(h.string()).optional(),
  requestId: h.string().optional(),
  issuedAt: h.string().optional(),
  expirationTime: h.string().optional(),
});
h.object({
  accessList: h.array(h.string()),
  blockHash: h.string().nullable(),
  blockNumber: h.string().nullable(),
  chainId: h.string().or(h.number()),
  from: h.string(),
  gas: h.string(),
  hash: h.string(),
  input: h.string().nullable(),
  maxFeePerGas: h.string(),
  maxPriorityFeePerGas: h.string(),
  nonce: h.string(),
  r: h.string(),
  s: h.string(),
  to: h.string(),
  transactionIndex: h.string().nullable(),
  type: h.string(),
  v: h.string(),
  value: h.string(),
});
const wT = h.object({
    chainId: h.string().or(h.number()),
    rpcUrl: h.optional(h.string()),
  }),
  yT = h.object({ email: h.string().email() }),
  ET = h.object({ otp: h.string() }),
  bT = h.object({
    uri: h.string(),
    preferredAccountType: h.optional(h.string()),
    chainId: h.optional(h.string().or(h.number())),
    siwxMessage: h.optional(Ga),
    rpcUrl: h.optional(h.string()),
  }),
  _T = h.object({
    chainId: h.optional(h.string().or(h.number())),
    preferredAccountType: h.optional(h.string()),
    socialUri: h.optional(h.string()),
    siwxMessage: h.optional(Ga),
    rpcUrl: h.optional(h.string()),
  }),
  CT = h.object({
    provider: h.enum(["google", "github", "apple", "facebook", "x", "discord"]),
  }),
  vT = h.object({ email: h.string().email() }),
  AT = h.object({ otp: h.string() }),
  IT = h.object({ otp: h.string() }),
  ST = h.object({
    themeMode: h.optional(h.enum(["light", "dark"])),
    themeVariables: h.optional(h.record(h.string(), h.string().or(h.number()))),
    w3mThemeVariables: h.optional(h.record(h.string(), h.string())),
  }),
  NT = h.object({
    metadata: h
      .object({
        name: h.string(),
        description: h.string(),
        url: h.string(),
        icons: h.array(h.string()),
      })
      .optional(),
    sdkVersion: h.string().optional(),
    sdkType: h.string().optional(),
    projectId: h.string(),
  }),
  TT = h.object({ type: h.string() }),
  RT = h.object({ action: h.enum(["VERIFY_DEVICE", "VERIFY_OTP", "CONNECT"]) }),
  xT = h.object({ url: h.string() }),
  PT = h.object({ userName: h.string() }),
  OT = h.object({
    email: h.string().optional().nullable(),
    address: h.string(),
    chainId: h.string().or(h.number()),
    accounts: h
      .array(
        h.object({
          address: h.string(),
          type: h.enum([nt.ACCOUNT_TYPES.EOA, nt.ACCOUNT_TYPES.SMART_ACCOUNT]),
        })
      )
      .optional(),
    userName: h.string().optional().nullable(),
    preferredAccountType: h.optional(h.string()),
    signature: h.string().optional(),
    message: h.string().optional(),
    siwxMessage: h.optional(Ga),
  }),
  kT = h.object({
    action: h.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"]),
  }),
  UT = h.object({
    email: h.string().email().optional().nullable(),
    address: h.string(),
    chainId: h.string().or(h.number()),
    smartAccountDeployed: h.optional(h.boolean()),
    accounts: h
      .array(
        h.object({
          address: h.string(),
          type: h.enum([nt.ACCOUNT_TYPES.EOA, nt.ACCOUNT_TYPES.SMART_ACCOUNT]),
        })
      )
      .optional(),
    preferredAccountType: h.optional(h.string()),
    signature: h.string().optional(),
    message: h.string().optional(),
    siwxMessage: h.optional(Ga),
  }),
  $T = h.object({ uri: h.string() }),
  DT = h.object({ isConnected: h.boolean() }),
  LT = h.object({ chainId: h.string().or(h.number()) }),
  MT = h.object({ chainId: h.string().or(h.number()) }),
  BT = h.object({ newEmail: h.string().email() }),
  FT = h.object({ smartAccountEnabledNetworks: h.array(h.number()) });
h.object({ address: h.string(), isDeployed: h.boolean() });
const jT = h.object({ version: h.string().optional() }),
  qT = h.object({ type: h.string(), address: h.string() }),
  HT = h.any(),
  WT = h.object({ method: h.literal("eth_accounts") }),
  zT = h.object({ method: h.literal("eth_blockNumber") }),
  VT = h.object({ method: h.literal("eth_call"), params: h.array(h.any()) }),
  KT = h.object({ method: h.literal("eth_chainId") }),
  GT = h.object({
    method: h.literal("eth_estimateGas"),
    params: h.array(h.any()),
  }),
  YT = h.object({
    method: h.literal("eth_feeHistory"),
    params: h.array(h.any()),
  }),
  ZT = h.object({ method: h.literal("eth_gasPrice") }),
  JT = h.object({
    method: h.literal("eth_getAccount"),
    params: h.array(h.any()),
  }),
  XT = h.object({
    method: h.literal("eth_getBalance"),
    params: h.array(h.any()),
  }),
  QT = h.object({
    method: h.literal("eth_getBlockByHash"),
    params: h.array(h.any()),
  }),
  eR = h.object({
    method: h.literal("eth_getBlockByNumber"),
    params: h.array(h.any()),
  }),
  tR = h.object({
    method: h.literal("eth_getBlockReceipts"),
    params: h.array(h.any()),
  }),
  sR = h.object({
    method: h.literal("eth_getBlockTransactionCountByHash"),
    params: h.array(h.any()),
  }),
  nR = h.object({
    method: h.literal("eth_getBlockTransactionCountByNumber"),
    params: h.array(h.any()),
  }),
  rR = h.object({ method: h.literal("eth_getCode"), params: h.array(h.any()) }),
  iR = h.object({
    method: h.literal("eth_getFilterChanges"),
    params: h.array(h.any()),
  }),
  oR = h.object({
    method: h.literal("eth_getFilterLogs"),
    params: h.array(h.any()),
  }),
  aR = h.object({ method: h.literal("eth_getLogs"), params: h.array(h.any()) }),
  cR = h.object({
    method: h.literal("eth_getProof"),
    params: h.array(h.any()),
  }),
  lR = h.object({
    method: h.literal("eth_getStorageAt"),
    params: h.array(h.any()),
  }),
  dR = h.object({
    method: h.literal("eth_getTransactionByBlockHashAndIndex"),
    params: h.array(h.any()),
  }),
  uR = h.object({
    method: h.literal("eth_getTransactionByBlockNumberAndIndex"),
    params: h.array(h.any()),
  }),
  hR = h.object({
    method: h.literal("eth_getTransactionByHash"),
    params: h.array(h.any()),
  }),
  pR = h.object({
    method: h.literal("eth_getTransactionCount"),
    params: h.array(h.any()),
  }),
  fR = h.object({
    method: h.literal("eth_getTransactionReceipt"),
    params: h.array(h.any()),
  }),
  gR = h.object({
    method: h.literal("eth_getUncleCountByBlockHash"),
    params: h.array(h.any()),
  }),
  mR = h.object({
    method: h.literal("eth_getUncleCountByBlockNumber"),
    params: h.array(h.any()),
  }),
  wR = h.object({ method: h.literal("eth_maxPriorityFeePerGas") }),
  yR = h.object({ method: h.literal("eth_newBlockFilter") }),
  ER = h.object({
    method: h.literal("eth_newFilter"),
    params: h.array(h.any()),
  }),
  bR = h.object({ method: h.literal("eth_newPendingTransactionFilter") }),
  _R = h.object({
    method: h.literal("eth_sendRawTransaction"),
    params: h.array(h.any()),
  }),
  CR = h.object({ method: h.literal("eth_syncing"), params: h.array(h.any()) }),
  vR = h.object({
    method: h.literal("eth_uninstallFilter"),
    params: h.array(h.any()),
  }),
  xh = h.object({
    method: h.literal("personal_sign"),
    params: h.array(h.any()),
  }),
  AR = h.object({
    method: h.literal("eth_signTypedData_v4"),
    params: h.array(h.any()),
  }),
  IR = h.object({
    method: h.literal("eth_sendTransaction"),
    params: h.array(h.any()),
  }),
  SR = h.object({
    method: h.literal("solana_signMessage"),
    params: h.object({ message: h.string(), pubkey: h.string() }),
  }),
  NR = h.object({
    method: h.literal("solana_signTransaction"),
    params: h.object({ transaction: h.string() }),
  }),
  TR = h.object({
    method: h.literal("solana_signAllTransactions"),
    params: h.object({ transactions: h.array(h.string()) }),
  }),
  RR = h.object({
    method: h.literal("solana_signAndSendTransaction"),
    params: h.object({
      transaction: h.string(),
      options: h
        .object({
          skipPreflight: h.boolean().optional(),
          preflightCommitment: h
            .enum([
              "processed",
              "confirmed",
              "finalized",
              "recent",
              "single",
              "singleGossip",
              "root",
              "max",
            ])
            .optional(),
          maxRetries: h.number().optional(),
          minContextSlot: h.number().optional(),
        })
        .optional(),
    }),
  }),
  xR = h.object({
    method: h.literal("wallet_sendCalls"),
    params: h.array(
      h.object({
        chainId: h.string().or(h.number()).optional(),
        from: h.string().optional(),
        version: h.string().optional(),
        capabilities: h.any().optional(),
        calls: h.array(
          h.object({
            to: h.string().startsWith("0x"),
            data: h.string().startsWith("0x").optional(),
            value: h.string().optional(),
          })
        ),
      })
    ),
  }),
  PR = h.object({
    method: h.literal("wallet_getCallsStatus"),
    params: h.array(h.string()),
  }),
  OR = h.object({
    method: h.literal("wallet_getCapabilities"),
    params: h.array(h.string().or(h.number()).optional()).optional(),
  }),
  kR = h.object({
    method: h.literal("wallet_grantPermissions"),
    params: h.array(h.any()),
  }),
  UR = h.object({
    method: h.literal("wallet_revokePermissions"),
    params: h.any(),
  }),
  $R = h.object({ method: h.literal("wallet_getAssets"), params: h.any() }),
  Ph = h.object({ token: h.string() }),
  Z = h.object({ id: h.string().optional() }),
  Ai = {
    appEvent: Z.extend({ type: Y("APP_SWITCH_NETWORK"), payload: wT })
      .or(Z.extend({ type: Y("APP_CONNECT_EMAIL"), payload: yT }))
      .or(Z.extend({ type: Y("APP_CONNECT_DEVICE") }))
      .or(Z.extend({ type: Y("APP_CONNECT_OTP"), payload: ET }))
      .or(Z.extend({ type: Y("APP_CONNECT_SOCIAL"), payload: bT }))
      .or(Z.extend({ type: Y("APP_GET_FARCASTER_URI") }))
      .or(Z.extend({ type: Y("APP_CONNECT_FARCASTER") }))
      .or(Z.extend({ type: Y("APP_GET_USER"), payload: h.optional(_T) }))
      .or(Z.extend({ type: Y("APP_GET_SOCIAL_REDIRECT_URI"), payload: CT }))
      .or(Z.extend({ type: Y("APP_SIGN_OUT") }))
      .or(Z.extend({ type: Y("APP_IS_CONNECTED"), payload: h.optional(Ph) }))
      .or(Z.extend({ type: Y("APP_GET_CHAIN_ID") }))
      .or(Z.extend({ type: Y("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") }))
      .or(Z.extend({ type: Y("APP_INIT_SMART_ACCOUNT") }))
      .or(Z.extend({ type: Y("APP_SET_PREFERRED_ACCOUNT"), payload: TT }))
      .or(
        Z.extend({
          type: Y("APP_RPC_REQUEST"),
          payload: xh
            .or($R)
            .or(WT)
            .or(zT)
            .or(VT)
            .or(KT)
            .or(GT)
            .or(YT)
            .or(ZT)
            .or(JT)
            .or(XT)
            .or(QT)
            .or(eR)
            .or(tR)
            .or(sR)
            .or(nR)
            .or(rR)
            .or(iR)
            .or(oR)
            .or(aR)
            .or(cR)
            .or(lR)
            .or(dR)
            .or(uR)
            .or(hR)
            .or(pR)
            .or(fR)
            .or(gR)
            .or(mR)
            .or(wR)
            .or(yR)
            .or(ER)
            .or(bR)
            .or(_R)
            .or(CR)
            .or(vR)
            .or(xh)
            .or(AR)
            .or(IR)
            .or(SR)
            .or(NR)
            .or(TR)
            .or(RR)
            .or(PR)
            .or(xR)
            .or(OR)
            .or(kR)
            .or(UR)
            .and(
              h.object({
                chainId: h.string().or(h.number()).optional(),
                chainNamespace: h
                  .enum(["eip155", "solana", "polkadot", "bip122", "cosmos"])
                  .optional(),
                rpcUrl: h.string().optional(),
              })
            ),
        })
      )
      .or(Z.extend({ type: Y("APP_UPDATE_EMAIL"), payload: vT }))
      .or(Z.extend({ type: Y("APP_UPDATE_EMAIL_PRIMARY_OTP"), payload: AT }))
      .or(Z.extend({ type: Y("APP_UPDATE_EMAIL_SECONDARY_OTP"), payload: IT }))
      .or(Z.extend({ type: Y("APP_SYNC_THEME"), payload: ST }))
      .or(Z.extend({ type: Y("APP_SYNC_DAPP_DATA"), payload: NT }))
      .or(Z.extend({ type: Y("APP_RELOAD") }))
      .or(Z.extend({ type: Y("APP_RPC_ABORT") })),
    frameEvent: Z.extend({ type: Y("FRAME_SWITCH_NETWORK_ERROR"), payload: Ge })
      .or(Z.extend({ type: Y("FRAME_SWITCH_NETWORK_SUCCESS"), payload: MT }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_EMAIL_SUCCESS"), payload: RT }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_EMAIL_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_GET_FARCASTER_URI_SUCCESS"), payload: xT }))
      .or(Z.extend({ type: Y("FRAME_GET_FARCASTER_URI_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_FARCASTER_SUCCESS"), payload: PT }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_FARCASTER_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_OTP_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_OTP_SUCCESS") }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_DEVICE_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_DEVICE_SUCCESS") }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_SOCIAL_SUCCESS"), payload: OT }))
      .or(Z.extend({ type: Y("FRAME_CONNECT_SOCIAL_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_GET_USER_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_GET_USER_SUCCESS"), payload: UT }))
      .or(
        Z.extend({
          type: Y("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
          payload: Ge,
        })
      )
      .or(
        Z.extend({
          type: Y("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
          payload: $T,
        })
      )
      .or(Z.extend({ type: Y("FRAME_SIGN_OUT_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_SIGN_OUT_SUCCESS") }))
      .or(Z.extend({ type: Y("FRAME_IS_CONNECTED_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_IS_CONNECTED_SUCCESS"), payload: DT }))
      .or(Z.extend({ type: Y("FRAME_GET_CHAIN_ID_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_GET_CHAIN_ID_SUCCESS"), payload: LT }))
      .or(Z.extend({ type: Y("FRAME_RPC_REQUEST_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_RPC_REQUEST_SUCCESS"), payload: HT }))
      .or(Z.extend({ type: Y("FRAME_SESSION_UPDATE"), payload: Ph }))
      .or(Z.extend({ type: Y("FRAME_UPDATE_EMAIL_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_UPDATE_EMAIL_SUCCESS"), payload: kT }))
      .or(
        Z.extend({
          type: Y("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
          payload: Ge,
        })
      )
      .or(Z.extend({ type: Y("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") }))
      .or(
        Z.extend({
          type: Y("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
          payload: Ge,
        })
      )
      .or(
        Z.extend({
          type: Y("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
          payload: BT,
        })
      )
      .or(Z.extend({ type: Y("FRAME_SYNC_THEME_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_SYNC_THEME_SUCCESS") }))
      .or(Z.extend({ type: Y("FRAME_SYNC_DAPP_DATA_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_SYNC_DAPP_DATA_SUCCESS") }))
      .or(
        Z.extend({
          type: Y("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
          payload: FT,
        })
      )
      .or(
        Z.extend({
          type: Y("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
          payload: Ge,
        })
      )
      .or(Z.extend({ type: Y("FRAME_INIT_SMART_ACCOUNT_ERROR"), payload: Ge }))
      .or(
        Z.extend({
          type: Y("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
          payload: qT,
        })
      )
      .or(
        Z.extend({ type: Y("FRAME_SET_PREFERRED_ACCOUNT_ERROR"), payload: Ge })
      )
      .or(Z.extend({ type: Y("FRAME_READY"), payload: jT }))
      .or(Z.extend({ type: Y("FRAME_RELOAD_ERROR"), payload: Ge }))
      .or(Z.extend({ type: Y("FRAME_RELOAD_SUCCESS") })),
  };
function kc(s, e = {}) {
  var t;
  return (
    typeof (e == null ? void 0 : e.type) == "string" &&
    ((t = e == null ? void 0 : e.type) == null ? void 0 : t.includes(s))
  );
}
function DR({
  projectId: s,
  chainId: e,
  version: t,
  enableLogger: n,
  rpcUrl: r = S.BLOCKCHAIN_API_RPC_URL,
}) {
  const i = new URL(Fm);
  return (
    i.searchParams.set("projectId", s),
    i.searchParams.set("chainId", String(e)),
    i.searchParams.set("version", t),
    i.searchParams.set("enableLogger", String(n)),
    i.searchParams.set("rpcUrl", r),
    i.toString()
  );
}
class LR {
  constructor({
    projectId: e,
    isAppClient: t = !1,
    chainId: n = "eip155:1",
    enableLogger: r = !0,
    rpcUrl: i = S.BLOCKCHAIN_API_RPC_URL,
  }) {
    if (
      ((this.iframe = null),
      (this.iframeIsReady = !1),
      (this.initFrame = () => {
        const o = document.getElementById("w3m-iframe");
        this.iframe && !o && document.body.appendChild(this.iframe);
      }),
      (this.events = {
        registerFrameEventHandler: (o, a, c) => {
          function l({ data: d }) {
            if (!kc(te.FRAME_EVENT_KEY, d)) return;
            const u = Ai.frameEvent.parse(d);
            u.id === o && (a(u), window.removeEventListener("message", l));
          }
          Vt.isClient &&
            (window.addEventListener("message", l),
            c.addEventListener("abort", () => {
              window.removeEventListener("message", l);
            }));
        },
        onFrameEvent: (o) => {
          Vt.isClient &&
            window.addEventListener("message", ({ data: a }) => {
              if (!kc(te.FRAME_EVENT_KEY, a)) return;
              const c = Ai.frameEvent.parse(a);
              o(c);
            });
        },
        onAppEvent: (o) => {
          Vt.isClient &&
            window.addEventListener("message", ({ data: a }) => {
              if (!kc(te.APP_EVENT_KEY, a)) return;
              const c = Ai.appEvent.parse(a);
              o(c);
            });
        },
        postAppEvent: (o) => {
          var a;
          if (Vt.isClient) {
            if (!((a = this.iframe) != null && a.contentWindow))
              throw new Error("W3mFrame: iframe is not set");
            Ai.appEvent.parse(o), this.iframe.contentWindow.postMessage(o, "*");
          }
        },
        postFrameEvent: (o) => {
          if (Vt.isClient) {
            if (!parent) throw new Error("W3mFrame: parent is not set");
            Ai.frameEvent.parse(o), parent.postMessage(o, "*");
          }
        },
      }),
      (this.projectId = e),
      (this.frameLoadPromise = new Promise((o, a) => {
        this.frameLoadPromiseResolver = { resolve: o, reject: a };
      })),
      (this.rpcUrl = i),
      t &&
        ((this.frameLoadPromise = new Promise((o, a) => {
          this.frameLoadPromiseResolver = { resolve: o, reject: a };
        })),
        Vt.isClient))
    ) {
      const o = document.createElement("iframe");
      (o.id = "w3m-iframe"),
        (o.src = DR({
          projectId: e,
          chainId: n,
          version: qm,
          enableLogger: r,
          rpcUrl: this.rpcUrl,
        })),
        (o.name = "w3m-secure-iframe"),
        (o.style.position = "fixed"),
        (o.style.zIndex = "999999"),
        (o.style.display = "none"),
        (o.style.border = "none"),
        (o.style.animationDelay = "0s, 50ms"),
        (o.style.borderBottomLeftRadius =
          "clamp(0px, var(--wui-border-radius-l), 44px)"),
        (o.style.borderBottomRightRadius =
          "clamp(0px, var(--wui-border-radius-l), 44px)"),
        (this.iframe = o),
        (this.iframe.onerror = () => {
          var a;
          (a = this.frameLoadPromiseResolver) == null ||
            a.reject("Unable to load email login dependency");
        }),
        this.events.onFrameEvent((a) => {
          var c;
          a.type === "@w3m-frame/READY" &&
            ((this.iframeIsReady = !0),
            (c = this.frameLoadPromiseResolver) == null || c.resolve(void 0));
        });
    }
  }
  get networks() {
    const e = [
      "eip155:1",
      "eip155:5",
      "eip155:11155111",
      "eip155:10",
      "eip155:420",
      "eip155:42161",
      "eip155:421613",
      "eip155:137",
      "eip155:80001",
      "eip155:42220",
      "eip155:1313161554",
      "eip155:1313161555",
      "eip155:56",
      "eip155:97",
      "eip155:43114",
      "eip155:43113",
      "eip155:324",
      "eip155:280",
      "eip155:100",
      "eip155:8453",
      "eip155:84531",
      "eip155:84532",
      "eip155:7777777",
      "eip155:999",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    ].map((t) => ({
      [t]: {
        rpcUrl: `${this.rpcUrl}/v1/?chainId=${t}&projectId=${this.projectId}`,
        chainId: t,
      },
    }));
    return Object.assign({}, ...e);
  }
}
class MR {
  constructor(e) {
    var i;
    const t = ti({ level: jm }),
      { logger: n, chunkLoggerController: r } = $l({ opts: t });
    (this.logger = _t(n, this.constructor.name)),
      (this.chunkLoggerController = r),
      typeof window < "u" &&
        (i = this.chunkLoggerController) != null &&
        i.downloadLogsBlobInBrowser &&
        (window.downloadAppKitLogsBlob || (window.downloadAppKitLogsBlob = {}),
        (window.downloadAppKitLogsBlob.sdk = () => {
          var o;
          (o = this.chunkLoggerController) != null &&
            o.downloadLogsBlobInBrowser &&
            this.chunkLoggerController.downloadLogsBlobInBrowser({
              projectId: e,
            });
        }));
  }
}
class BR {
  constructor({
    projectId: e,
    chainId: t,
    enableLogger: n = !0,
    onTimeout: r,
    abortController: i,
    getActiveCaipNetwork: o,
  }) {
    (this.openRpcRequests = []),
      (this.isInitialized = !1),
      n && (this.w3mLogger = new MR(e)),
      (this.abortController = i),
      (this.getActiveCaipNetwork = o);
    const a = this.getRpcUrl(t);
    (this.w3mFrame = new LR({
      projectId: e,
      isAppClient: !0,
      chainId: t,
      enableLogger: n,
      rpcUrl: a,
    })),
      (this.onTimeout = r),
      this.getLoginEmailUsed() && this.createFrame();
  }
  async createFrame() {
    this.w3mFrame.initFrame(),
      (this.initPromise = new Promise((e) => {
        this.w3mFrame.events.onFrameEvent((t) => {
          t.type === te.FRAME_READY &&
            setTimeout(() => {
              e();
            }, 500);
        });
      })),
      await this.initPromise,
      (this.isInitialized = !0),
      (this.initPromise = void 0);
  }
  async init() {
    if (!this.isInitialized) {
      if (this.initPromise) {
        await this.initPromise;
        return;
      }
      await this.createFrame();
    }
  }
  getLoginEmailUsed() {
    return !!ht.get(te.EMAIL_LOGIN_USED_KEY);
  }
  getEmail() {
    return ht.get(te.EMAIL);
  }
  getUsername() {
    return ht.get(te.SOCIAL_USERNAME);
  }
  async reload() {
    var e;
    try {
      await this.appEvent({ type: te.APP_RELOAD });
    } catch (t) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: t }, "Error reloading iframe"),
        t)
      );
    }
  }
  async connectEmail(e) {
    var t;
    try {
      Vt.checkIfAllowedToTriggerEmail(), await this.init();
      const n = await this.appEvent({ type: te.APP_CONNECT_EMAIL, payload: e });
      return this.setNewLastEmailLoginTime(), n;
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error connecting email"),
        n)
      );
    }
  }
  async connectDevice() {
    var e;
    try {
      return this.appEvent({ type: te.APP_CONNECT_DEVICE });
    } catch (t) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: t }, "Error connecting device"),
        t)
      );
    }
  }
  async connectOtp(e) {
    var t;
    try {
      return this.appEvent({ type: te.APP_CONNECT_OTP, payload: e });
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error connecting otp"),
        n)
      );
    }
  }
  async isConnected() {
    var e;
    try {
      if (!this.getLoginEmailUsed()) return { isConnected: !1 };
      const t = await this.appEvent({ type: te.APP_IS_CONNECTED });
      return (t != null && t.isConnected) || this.deleteAuthLoginCache(), t;
    } catch (t) {
      throw (
        (this.deleteAuthLoginCache(),
        (e = this.w3mLogger) == null ||
          e.logger.error({ error: t }, "Error checking connection"),
        t)
      );
    }
  }
  async getChainId() {
    var e;
    try {
      const t = await this.appEvent({ type: te.APP_GET_CHAIN_ID });
      return this.setLastUsedChainId(t.chainId), t;
    } catch (t) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: t }, "Error getting chain id"),
        t)
      );
    }
  }
  async getSocialRedirectUri(e) {
    var t;
    try {
      return (
        await this.init(),
        this.appEvent({ type: te.APP_GET_SOCIAL_REDIRECT_URI, payload: e })
      );
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error getting social redirect uri"),
        n)
      );
    }
  }
  async updateEmail(e) {
    var t;
    try {
      const n = await this.appEvent({ type: te.APP_UPDATE_EMAIL, payload: e });
      return this.setNewLastEmailLoginTime(), n;
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error updating email"),
        n)
      );
    }
  }
  async updateEmailPrimaryOtp(e) {
    var t;
    try {
      return this.appEvent({
        type: te.APP_UPDATE_EMAIL_PRIMARY_OTP,
        payload: e,
      });
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error updating email primary otp"),
        n)
      );
    }
  }
  async updateEmailSecondaryOtp(e) {
    var t;
    try {
      const n = await this.appEvent({
        type: te.APP_UPDATE_EMAIL_SECONDARY_OTP,
        payload: e,
      });
      return this.setLoginSuccess(n.newEmail), n;
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error updating email secondary otp"),
        n)
      );
    }
  }
  async syncTheme(e) {
    var t;
    try {
      return this.appEvent({ type: te.APP_SYNC_THEME, payload: e });
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error syncing theme"),
        n)
      );
    }
  }
  async syncDappData(e) {
    var t;
    try {
      return this.appEvent({ type: te.APP_SYNC_DAPP_DATA, payload: e });
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error syncing dapp data"),
        n)
      );
    }
  }
  async getSmartAccountEnabledNetworks() {
    var e;
    try {
      const t = await this.appEvent({
        type: te.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS,
      });
      return (
        this.persistSmartAccountEnabledNetworks(t.smartAccountEnabledNetworks),
        t
      );
    } catch (t) {
      throw (
        (this.persistSmartAccountEnabledNetworks([]),
        (e = this.w3mLogger) == null ||
          e.logger.error(
            { error: t },
            "Error getting smart account enabled networks"
          ),
        t)
      );
    }
  }
  async setPreferredAccount(e) {
    var t;
    try {
      return this.appEvent({
        type: te.APP_SET_PREFERRED_ACCOUNT,
        payload: { type: e },
      });
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error setting preferred account"),
        n)
      );
    }
  }
  async connect(e) {
    var t, n;
    if (e != null && e.socialUri)
      try {
        await this.init();
        const r = this.getRpcUrl(e.chainId),
          i = await this.appEvent({
            type: te.APP_CONNECT_SOCIAL,
            payload: {
              uri: e.socialUri,
              preferredAccountType: e.preferredAccountType,
              chainId: e.chainId,
              siwxMessage: e.siwxMessage,
              rpcUrl: r,
            },
          });
        return (
          i.userName && this.setSocialLoginSuccess(i.userName),
          this.setLoginSuccess(i.email),
          this.setLastUsedChainId(i.chainId),
          (this.user = i),
          i
        );
      } catch (r) {
        throw (
          ((t = this.w3mLogger) == null ||
            t.logger.error({ error: r }, "Error connecting social"),
          r)
        );
      }
    else
      try {
        const r =
            (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1,
          i = await this.getUser({
            chainId: r,
            preferredAccountType: e == null ? void 0 : e.preferredAccountType,
            siwxMessage: e == null ? void 0 : e.siwxMessage,
            rpcUrl: this.getRpcUrl(r),
          });
        return (
          this.setLoginSuccess(i.email),
          this.setLastUsedChainId(i.chainId),
          (this.user = i),
          i
        );
      } catch (r) {
        throw (
          ((n = this.w3mLogger) == null ||
            n.logger.error({ error: r }, "Error connecting"),
          r)
        );
      }
  }
  async getUser(e) {
    var t;
    try {
      await this.init();
      const n =
          (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1,
        r = await this.appEvent({
          type: te.APP_GET_USER,
          payload: { ...e, chainId: n },
        });
      return (this.user = r), r;
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error connecting"),
        n)
      );
    }
  }
  async connectSocial({ uri: e, chainId: t, preferredAccountType: n }) {
    var r;
    try {
      await this.init();
      const i = this.getRpcUrl(t),
        o = await this.appEvent({
          type: te.APP_CONNECT_SOCIAL,
          payload: { uri: e, chainId: t, rpcUrl: i, preferredAccountType: n },
        });
      return o.userName && this.setSocialLoginSuccess(o.userName), o;
    } catch (i) {
      throw (
        ((r = this.w3mLogger) == null ||
          r.logger.error({ error: i }, "Error connecting social"),
        i)
      );
    }
  }
  async getFarcasterUri() {
    var e;
    try {
      return (
        await this.init(),
        await this.appEvent({ type: te.APP_GET_FARCASTER_URI })
      );
    } catch (t) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: t }, "Error getting farcaster uri"),
        t)
      );
    }
  }
  async connectFarcaster() {
    var e;
    try {
      const t = await this.appEvent({ type: te.APP_CONNECT_FARCASTER });
      return t.userName && this.setSocialLoginSuccess(t.userName), t;
    } catch (t) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: t }, "Error connecting farcaster"),
        t)
      );
    }
  }
  async switchNetwork({ chainId: e }) {
    var t;
    try {
      const n = this.getRpcUrl(e),
        r = await this.appEvent({
          type: te.APP_SWITCH_NETWORK,
          payload: { chainId: e, rpcUrl: n },
        });
      return this.setLastUsedChainId(r.chainId), r;
    } catch (n) {
      throw (
        ((t = this.w3mLogger) == null ||
          t.logger.error({ error: n }, "Error switching network"),
        n)
      );
    }
  }
  async disconnect() {
    var e;
    try {
      return (
        this.deleteAuthLoginCache(),
        await new Promise(async (n) => {
          const r = setTimeout(() => {
            n();
          }, 3e3);
          await this.appEvent({ type: te.APP_SIGN_OUT }), clearTimeout(r), n();
        })
      );
    } catch (t) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: t }, "Error disconnecting"),
        t)
      );
    }
  }
  async request(e) {
    var n, r, i, o, a;
    const t = e;
    try {
      if (nt.GET_CHAIN_ID === e.method) return this.getLastUsedChainId();
      const c = e.chainNamespace || "eip155",
        l = (n = this.getActiveCaipNetwork(c)) == null ? void 0 : n.id;
      (t.chainNamespace = c),
        (t.chainId = l),
        (t.rpcUrl = this.getRpcUrl(l)),
        (r = this.rpcRequestHandler) == null || r.call(this, e);
      const d = await this.appEvent({ type: te.APP_RPC_REQUEST, payload: t });
      return (i = this.rpcSuccessHandler) == null || i.call(this, d, t), d;
    } catch (c) {
      throw (
        ((o = this.rpcErrorHandler) == null || o.call(this, c, t),
        (a = this.w3mLogger) == null ||
          a.logger.error({ error: c }, "Error requesting"),
        c)
      );
    }
  }
  onRpcRequest(e) {
    this.rpcRequestHandler = e;
  }
  onRpcSuccess(e) {
    this.rpcSuccessHandler = e;
  }
  onRpcError(e) {
    this.rpcErrorHandler = e;
  }
  onIsConnected(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === te.FRAME_IS_CONNECTED_SUCCESS && t.payload.isConnected && e();
    });
  }
  onNotConnected(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === te.FRAME_IS_CONNECTED_ERROR && e(),
        t.type === te.FRAME_IS_CONNECTED_SUCCESS &&
          !t.payload.isConnected &&
          e();
    });
  }
  onConnect(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === te.FRAME_GET_USER_SUCCESS && e(t.payload);
    });
  }
  onSocialConnected(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === te.FRAME_CONNECT_SOCIAL_SUCCESS && e(t.payload);
    });
  }
  async getCapabilities() {
    try {
      return (await this.request({ method: "wallet_getCapabilities" })) || {};
    } catch {
      return {};
    }
  }
  onSetPreferredAccount(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === te.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS
        ? e(t.payload)
        : t.type === te.FRAME_SET_PREFERRED_ACCOUNT_ERROR &&
          e({ type: nt.ACCOUNT_TYPES.EOA });
    });
  }
  getAvailableChainIds() {
    return Object.keys(this.w3mFrame.networks);
  }
  async rejectRpcRequests() {
    var e;
    try {
      await Promise.all(
        this.openRpcRequests.map(async ({ abortController: t, method: n }) => {
          nt.SAFE_RPC_METHODS.includes(n) || t.abort(),
            await this.appEvent({ type: te.APP_RPC_ABORT });
        })
      ),
        (this.openRpcRequests = []);
    } catch (t) {
      (e = this.w3mLogger) == null ||
        e.logger.error({ error: t }, "Error aborting RPC request");
    }
  }
  async appEvent(e) {
    let t, n;
    function r(c) {
      return c.replace("@w3m-app/", "");
    }
    const i = [
        te.APP_SYNC_DAPP_DATA,
        te.APP_SYNC_THEME,
        te.APP_SET_PREFERRED_ACCOUNT,
      ],
      o = r(e.type);
    return (
      !this.w3mFrame.iframeIsReady &&
        !i.includes(e.type) &&
        (n = setTimeout(() => {
          var c;
          (c = this.onTimeout) == null || c.call(this, "iframe_load_failed"),
            this.abortController.abort();
        }, 2e4)),
      await this.w3mFrame.frameLoadPromise,
      clearTimeout(n),
      [
        te.APP_CONNECT_EMAIL,
        te.APP_CONNECT_DEVICE,
        te.APP_CONNECT_OTP,
        te.APP_CONNECT_SOCIAL,
        te.APP_GET_SOCIAL_REDIRECT_URI,
      ]
        .map(r)
        .includes(o) &&
        (t = setTimeout(() => {
          var c;
          (c = this.onTimeout) == null ||
            c.call(this, "iframe_request_timeout"),
            this.abortController.abort();
        }, 12e4)),
      new Promise((c, l) => {
        var w, g, m;
        const d = Math.random().toString(36).substring(7);
        (m = (w = this.w3mLogger) == null ? void 0 : (g = w.logger).info) ==
          null || m.call(g, { event: e, id: d }, "Sending app event"),
          this.w3mFrame.events.postAppEvent({ ...e, id: d });
        const u = new AbortController();
        if (o === "RPC_REQUEST") {
          const f = e;
          this.openRpcRequests = [
            ...this.openRpcRequests,
            { ...f.payload, abortController: u },
          ];
        }
        u.signal.addEventListener("abort", () => {
          o === "RPC_REQUEST"
            ? l(new Error("Request was aborted"))
            : o !== "GET_FARCASTER_URI" && l(new Error("Something went wrong"));
        });
        function p(f, E) {
          var b, _, N;
          f.id === d &&
            ((_ = E == null ? void 0 : (b = E.logger).info) == null ||
              _.call(b, { framEvent: f, id: d }, "Received frame response"),
            f.type === `@w3m-frame/${o}_SUCCESS`
              ? (t && clearTimeout(t),
                n && clearTimeout(n),
                "payload" in f && c(f.payload),
                c(void 0))
              : f.type === `@w3m-frame/${o}_ERROR` &&
                (t && clearTimeout(t),
                n && clearTimeout(n),
                "payload" in f &&
                  l(
                    new Error(
                      ((N = f.payload) == null ? void 0 : N.message) ||
                        "An error occurred"
                    )
                  ),
                l(new Error("An error occurred"))));
        }
        this.w3mFrame.events.registerFrameEventHandler(
          d,
          (f) => p(f, this.w3mLogger),
          this.abortController.signal
        );
      })
    );
  }
  setNewLastEmailLoginTime() {
    ht.set(te.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
  }
  setSocialLoginSuccess(e) {
    ht.set(te.SOCIAL_USERNAME, e);
  }
  setLoginSuccess(e) {
    e && ht.set(te.EMAIL, e),
      ht.set(te.EMAIL_LOGIN_USED_KEY, "true"),
      ht.delete(te.LAST_EMAIL_LOGIN_TIME);
  }
  deleteAuthLoginCache() {
    ht.delete(te.EMAIL_LOGIN_USED_KEY),
      ht.delete(te.EMAIL),
      ht.delete(te.LAST_USED_CHAIN_KEY),
      ht.delete(te.SOCIAL_USERNAME);
  }
  setLastUsedChainId(e) {
    e && ht.set(te.LAST_USED_CHAIN_KEY, String(e));
  }
  getLastUsedChainId() {
    const e = ht.get(te.LAST_USED_CHAIN_KEY) ?? void 0,
      t = Number(e);
    return isNaN(t) ? e : t;
  }
  persistSmartAccountEnabledNetworks(e) {
    ht.set(te.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(","));
  }
  getRpcUrl(e) {
    var r, i;
    let t = e === void 0 ? void 0 : "eip155";
    typeof e == "string" &&
      (e.includes(":")
        ? (t =
            (r = Mt.parseCaipNetworkId(e)) == null ? void 0 : r.chainNamespace)
        : Number.isInteger(Number(e))
        ? (t = "eip155")
        : (t = "solana"));
    const n = this.getActiveCaipNetwork(t);
    return (i = n == null ? void 0 : n.rpcUrls.default.http) == null
      ? void 0
      : i[0];
  }
}
class zi {
  constructor() {}
  static getInstance({
    projectId: e,
    chainId: t,
    enableLogger: n,
    onTimeout: r,
    abortController: i,
    getActiveCaipNetwork: o,
  }) {
    return (
      zi.instance ||
        (zi.instance = new BR({
          projectId: e,
          chainId: t,
          enableLogger: n,
          onTimeout: r,
          abortController: i,
          getActiveCaipNetwork: o,
        })),
      zi.instance
    );
  }
}
var Oh = {};
const FR = {
    ACCOUNT_TABS: [
      { label: "Tokens" },
      { label: "NFTs" },
      { label: "Activity" },
    ],
    SECURE_SITE_ORIGIN:
      (typeof process < "u" && typeof Oh < "u"
        ? Oh.NEXT_PUBLIC_SECURE_SITE_ORIGIN
        : void 0) || "https://secure.walletconnect.org",
    VIEW_DIRECTION: { Next: "next", Prev: "prev" },
    DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
    ANIMATION_DURATIONS: {
      HeaderText: 120,
      ModalHeight: 150,
      ViewTransition: 150,
    },
  },
  Pl = {
    filterOutDuplicatesByRDNS(s) {
      const e = R.state.enableEIP6963 ? q.state.connectors : [],
        t = M.getRecentWallets(),
        n = e
          .map((a) => {
            var c;
            return (c = a.info) == null ? void 0 : c.rdns;
          })
          .filter(Boolean),
        r = t.map((a) => a.rdns).filter(Boolean),
        i = n.concat(r);
      if (i.includes("io.metamask.mobile") && ne.isMobile()) {
        const a = i.indexOf("io.metamask.mobile");
        i[a] = "io.metamask";
      }
      return s.filter(
        (a) =>
          !(
            (a != null && a.rdns && i.includes(String(a.rdns))) ||
            (!(a != null && a.rdns) && e.some((l) => l.name === a.name))
          )
      );
    },
    filterOutDuplicatesByIds(s) {
      const e = q.state.connectors.filter(
          (a) => a.type === "ANNOUNCED" || a.type === "INJECTED"
        ),
        t = M.getRecentWallets(),
        n = e.map((a) => a.explorerId),
        r = t.map((a) => a.id),
        i = n.concat(r);
      return s.filter((a) => !i.includes(a == null ? void 0 : a.id));
    },
    filterOutDuplicateWallets(s) {
      const e = this.filterOutDuplicatesByRDNS(s);
      return this.filterOutDuplicatesByIds(e);
    },
    markWalletsAsInstalled(s) {
      const { connectors: e } = q.state,
        { featuredWalletIds: t } = R.state,
        n = e
          .filter((o) => o.type === "ANNOUNCED")
          .reduce((o, a) => {
            var c;
            return (c = a.info) != null && c.rdns && (o[a.info.rdns] = !0), o;
          }, {});
      return s
        .map((o) => ({ ...o, installed: !!o.rdns && !!n[o.rdns ?? ""] }))
        .sort((o, a) => {
          const c = Number(a.installed) - Number(o.installed);
          if (c !== 0) return c;
          if (t != null && t.length) {
            const l = t.indexOf(o.id),
              d = t.indexOf(a.id);
            if (l !== -1 && d !== -1) return l - d;
            if (l !== -1) return -1;
            if (d !== -1) return 1;
          }
          return 0;
        });
    },
    getConnectOrderMethod(s, e) {
      var c;
      const t =
          (s == null ? void 0 : s.connectMethodsOrder) ||
          ((c = R.state.features) == null ? void 0 : c.connectMethodsOrder),
        n = e || q.state.connectors;
      if (t) return t;
      const { injected: r, announced: i } = ra.getConnectorsByType(
          n,
          re.state.recommended,
          re.state.featured
        ),
        o = r.filter(ra.showConnector),
        a = i.filter(ra.showConnector);
      return o.length || a.length
        ? ["wallet", "email", "social"]
        : FR.DEFAULT_CONNECT_METHOD_ORDER;
    },
    isExcluded(s) {
      const e =
          !!s.rdns && re.state.excludedWallets.some((n) => n.rdns === s.rdns),
        t =
          !!s.name &&
          re.state.excludedWallets.some((n) =>
            At.isLowerCaseMatch(n.name, s.name)
          );
      return e || t;
    },
  },
  ra = {
    getConnectorsByType(s, e, t) {
      const { customWallets: n } = R.state,
        r = M.getRecentWallets(),
        i = Pl.filterOutDuplicateWallets(e),
        o = Pl.filterOutDuplicateWallets(t),
        a = s.filter((u) => u.type === "MULTI_CHAIN"),
        c = s.filter((u) => u.type === "ANNOUNCED"),
        l = s.filter((u) => u.type === "INJECTED"),
        d = s.filter((u) => u.type === "EXTERNAL");
      return {
        custom: n,
        recent: r,
        external: d,
        multiChain: a,
        announced: c,
        injected: l,
        recommended: i,
        featured: o,
      };
    },
    showConnector(s) {
      var r;
      const e = (r = s.info) == null ? void 0 : r.rdns,
        t =
          !!e && re.state.excludedWallets.some((i) => !!i.rdns && i.rdns === e),
        n =
          !!s.name &&
          re.state.excludedWallets.some((i) =>
            At.isLowerCaseMatch(i.name, s.name)
          );
      return !(
        (s.type === "INJECTED" &&
          ((s.name === "Browser Wallet" &&
            (!ne.isMobile() || (ne.isMobile() && !e && !H.checkInstalled()))) ||
            t ||
            n)) ||
        ((s.type === "ANNOUNCED" || s.type === "EXTERNAL") && (t || n))
      );
    },
    getIsConnectedWithWC() {
      return Array.from(y.state.chains.values()).some(
        (t) => q.getConnectorId(t.namespace) === S.CONNECTOR_ID.WALLET_CONNECT
      );
    },
    getConnectorTypeOrder({
      recommended: s,
      featured: e,
      custom: t,
      recent: n,
      announced: r,
      injected: i,
      multiChain: o,
      external: a,
      overriddenConnectors: c = ((l) =>
        (l = R.state.features) == null ? void 0 : l.connectorTypeOrder)() ?? [],
    }) {
      const p = [
          { type: "walletConnect", isEnabled: R.state.enableWalletConnect },
          { type: "recent", isEnabled: n.length > 0 },
          { type: "injected", isEnabled: [...i, ...r, ...o].length > 0 },
          { type: "featured", isEnabled: e.length > 0 },
          { type: "custom", isEnabled: t && t.length > 0 },
          { type: "external", isEnabled: a.length > 0 },
          { type: "recommended", isEnabled: s.length > 0 },
        ].filter((f) => f.isEnabled),
        w = new Set(p.map((f) => f.type)),
        g = c.filter((f) => w.has(f)).map((f) => ({ type: f, isEnabled: !0 })),
        m = p.filter(({ type: f }) => !g.some(({ type: b }) => b === f));
      return Array.from(new Set([...g, ...m].map(({ type: f }) => f)));
    },
    getAuthName({ email: s, socialUsername: e, socialProvider: t }) {
      return e
        ? t && t === "discord" && e.endsWith("0")
          ? e.slice(0, -1)
          : e
        : s.length > 30
        ? `${s.slice(0, -3)}...`
        : s;
    },
    async fetchProviderData(s) {
      var e, t;
      try {
        if (s.name === "Browser Wallet" && !ne.isMobile())
          return { accounts: [], chainId: void 0 };
        if (s.id === S.CONNECTOR_ID.AUTH)
          return { accounts: [], chainId: void 0 };
        const [n, r] = await Promise.all([
          (e = s.provider) == null
            ? void 0
            : e.request({ method: "eth_accounts" }),
          (t = s.provider) == null
            ? void 0
            : t.request({ method: "eth_chainId" }).then((i) => Number(i)),
        ]);
        return { accounts: n, chainId: r };
      } catch (n) {
        return (
          console.warn(`Failed to fetch provider data for ${s.name}`, n),
          { accounts: [], chainId: void 0 }
        );
      }
    },
  };
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const ia = globalThis,
  ud =
    ia.ShadowRoot &&
    (ia.ShadyCSS === void 0 || ia.ShadyCSS.nativeShadow) &&
    "adoptedStyleSheets" in Document.prototype &&
    "replace" in CSSStyleSheet.prototype,
  bg = Symbol(),
  kh = new WeakMap();
let jR = class {
  constructor(e, t, n) {
    if (((this._$cssResult$ = !0), n !== bg))
      throw Error(
        "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
      );
    (this.cssText = e), (this.t = t);
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (ud && e === void 0) {
      const n = t !== void 0 && t.length === 1;
      n && (e = kh.get(t)),
        e === void 0 &&
          ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText),
          n && kh.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const qR = (s) => new jR(typeof s == "string" ? s : s + "", void 0, bg),
  HR = (s, e) => {
    if (ud)
      s.adoptedStyleSheets = e.map((t) =>
        t instanceof CSSStyleSheet ? t : t.styleSheet
      );
    else
      for (const t of e) {
        const n = document.createElement("style"),
          r = ia.litNonce;
        r !== void 0 && n.setAttribute("nonce", r),
          (n.textContent = t.cssText),
          s.appendChild(n);
      }
  },
  Uh = ud
    ? (s) => s
    : (s) =>
        s instanceof CSSStyleSheet
          ? ((e) => {
              let t = "";
              for (const n of e.cssRules) t += n.cssText;
              return qR(t);
            })(s)
          : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const {
    is: WR,
    defineProperty: zR,
    getOwnPropertyDescriptor: VR,
    getOwnPropertyNames: KR,
    getOwnPropertySymbols: GR,
    getPrototypeOf: YR,
  } = Object,
  An = globalThis,
  $h = An.trustedTypes,
  ZR = $h ? $h.emptyScript : "",
  Uc = An.reactiveElementPolyfillSupport,
  Vi = (s, e) => s,
  Ol = {
    toAttribute(s, e) {
      switch (e) {
        case Boolean:
          s = s ? ZR : null;
          break;
        case Object:
        case Array:
          s = s == null ? s : JSON.stringify(s);
      }
      return s;
    },
    fromAttribute(s, e) {
      let t = s;
      switch (e) {
        case Boolean:
          t = s !== null;
          break;
        case Number:
          t = s === null ? null : Number(s);
          break;
        case Object:
        case Array:
          try {
            t = JSON.parse(s);
          } catch {
            t = null;
          }
      }
      return t;
    },
  },
  _g = (s, e) => !WR(s, e),
  Dh = {
    attribute: !0,
    type: String,
    converter: Ol,
    reflect: !1,
    useDefault: !1,
    hasChanged: _g,
  };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")),
  An.litPropertyMetadata ?? (An.litPropertyMetadata = new WeakMap());
let Ii = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = Dh) {
    if (
      (t.state && (t.attribute = !1),
      this._$Ei(),
      this.prototype.hasOwnProperty(e) && ((t = Object.create(t)).wrapped = !0),
      this.elementProperties.set(e, t),
      !t.noAccessor)
    ) {
      const n = Symbol(),
        r = this.getPropertyDescriptor(e, n, t);
      r !== void 0 && zR(this.prototype, e, r);
    }
  }
  static getPropertyDescriptor(e, t, n) {
    const { get: r, set: i } = VR(this.prototype, e) ?? {
      get() {
        return this[t];
      },
      set(o) {
        this[t] = o;
      },
    };
    return {
      get: r,
      set(o) {
        const a = r == null ? void 0 : r.call(this);
        i == null || i.call(this, o), this.requestUpdate(e, a, n);
      },
      configurable: !0,
      enumerable: !0,
    };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? Dh;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Vi("elementProperties"))) return;
    const e = YR(this);
    e.finalize(),
      e.l !== void 0 && (this.l = [...e.l]),
      (this.elementProperties = new Map(e.elementProperties));
  }
  static finalize() {
    if (this.hasOwnProperty(Vi("finalized"))) return;
    if (
      ((this.finalized = !0),
      this._$Ei(),
      this.hasOwnProperty(Vi("properties")))
    ) {
      const t = this.properties,
        n = [...KR(t), ...GR(t)];
      for (const r of n) this.createProperty(r, t[r]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0)
        for (const [n, r] of t) this.elementProperties.set(n, r);
    }
    this._$Eh = new Map();
    for (const [t, n] of this.elementProperties) {
      const r = this._$Eu(t, n);
      r !== void 0 && this._$Eh.set(r, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const n = new Set(e.flat(1 / 0).reverse());
      for (const r of n) t.unshift(Uh(r));
    } else e !== void 0 && t.push(Uh(e));
    return t;
  }
  static _$Eu(e, t) {
    const n = t.attribute;
    return n === !1
      ? void 0
      : typeof n == "string"
      ? n
      : typeof e == "string"
      ? e.toLowerCase()
      : void 0;
  }
  constructor() {
    super(),
      (this._$Ep = void 0),
      (this.isUpdatePending = !1),
      (this.hasUpdated = !1),
      (this._$Em = null),
      this._$Ev();
  }
  _$Ev() {
    var e;
    (this._$ES = new Promise((t) => (this.enableUpdating = t))),
      (this._$AL = new Map()),
      this._$E_(),
      this.requestUpdate(),
      (e = this.constructor.l) == null || e.forEach((t) => t(this));
  }
  addController(e) {
    var t;
    (this._$EO ?? (this._$EO = new Set())).add(e),
      this.renderRoot !== void 0 &&
        this.isConnected &&
        ((t = e.hostConnected) == null || t.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$EO) == null || t.delete(e);
  }
  _$E_() {
    const e = new Map(),
      t = this.constructor.elementProperties;
    for (const n of t.keys())
      this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e =
      this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return HR(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
      this.enableUpdating(!0),
      (e = this._$EO) == null ||
        e.forEach((t) => {
          var n;
          return (n = t.hostConnected) == null ? void 0 : n.call(t);
        });
  }
  enableUpdating(e) {}
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null ||
      e.forEach((t) => {
        var n;
        return (n = t.hostDisconnected) == null ? void 0 : n.call(t);
      });
  }
  attributeChangedCallback(e, t, n) {
    this._$AK(e, n);
  }
  _$ET(e, t) {
    var i;
    const n = this.constructor.elementProperties.get(e),
      r = this.constructor._$Eu(e, n);
    if (r !== void 0 && n.reflect === !0) {
      const o = (
        ((i = n.converter) == null ? void 0 : i.toAttribute) !== void 0
          ? n.converter
          : Ol
      ).toAttribute(t, n.type);
      (this._$Em = e),
        o == null ? this.removeAttribute(r) : this.setAttribute(r, o),
        (this._$Em = null);
    }
  }
  _$AK(e, t) {
    var i, o;
    const n = this.constructor,
      r = n._$Eh.get(e);
    if (r !== void 0 && this._$Em !== r) {
      const a = n.getPropertyOptions(r),
        c =
          typeof a.converter == "function"
            ? { fromAttribute: a.converter }
            : ((i = a.converter) == null ? void 0 : i.fromAttribute) !== void 0
            ? a.converter
            : Ol;
      (this._$Em = r),
        (this[r] =
          c.fromAttribute(t, a.type) ??
          ((o = this._$Ej) == null ? void 0 : o.get(r)) ??
          null),
        (this._$Em = null);
    }
  }
  requestUpdate(e, t, n) {
    var r;
    if (e !== void 0) {
      const i = this.constructor,
        o = this[e];
      if (
        (n ?? (n = i.getPropertyOptions(e)),
        !(
          (n.hasChanged ?? _g)(o, t) ||
          (n.useDefault &&
            n.reflect &&
            o === ((r = this._$Ej) == null ? void 0 : r.get(e)) &&
            !this.hasAttribute(i._$Eu(e, n)))
        ))
      )
        return;
      this.C(e, t, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(e, t, { useDefault: n, reflect: r, wrapped: i }, o) {
    (n &&
      !(this._$Ej ?? (this._$Ej = new Map())).has(e) &&
      (this._$Ej.set(e, o ?? t ?? this[e]), i !== !0 || o !== void 0)) ||
      (this._$AL.has(e) ||
        (this.hasUpdated || n || (t = void 0), this._$AL.set(e, t)),
      r === !0 &&
        this._$Em !== e &&
        (this._$Eq ?? (this._$Eq = new Set())).add(e));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && (await e), !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (
        (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
        this._$Ep)
      ) {
        for (const [i, o] of this._$Ep) this[i] = o;
        this._$Ep = void 0;
      }
      const r = this.constructor.elementProperties;
      if (r.size > 0)
        for (const [i, o] of r) {
          const { wrapped: a } = o,
            c = this[i];
          a !== !0 ||
            this._$AL.has(i) ||
            c === void 0 ||
            this.C(i, void 0, o, c);
        }
    }
    let e = !1;
    const t = this._$AL;
    try {
      (e = this.shouldUpdate(t)),
        e
          ? (this.willUpdate(t),
            (n = this._$EO) == null ||
              n.forEach((r) => {
                var i;
                return (i = r.hostUpdate) == null ? void 0 : i.call(r);
              }),
            this.update(t))
          : this._$EM();
    } catch (r) {
      throw ((e = !1), this._$EM(), r);
    }
    e && this._$AE(t);
  }
  willUpdate(e) {}
  _$AE(e) {
    var t;
    (t = this._$EO) == null ||
      t.forEach((n) => {
        var r;
        return (r = n.hostUpdated) == null ? void 0 : r.call(n);
      }),
      this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
      this.updated(e);
  }
  _$EM() {
    (this._$AL = new Map()), (this.isUpdatePending = !1);
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((t) => this._$ET(t, this[t]))),
      this._$EM();
  }
  updated(e) {}
  firstUpdated(e) {}
};
(Ii.elementStyles = []),
  (Ii.shadowRootOptions = { mode: "open" }),
  (Ii[Vi("elementProperties")] = new Map()),
  (Ii[Vi("finalized")] = new Map()),
  Uc == null || Uc({ ReactiveElement: Ii }),
  (An.reactiveElementVersions ?? (An.reactiveElementVersions = [])).push(
    "2.1.0"
  );
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const Ki = globalThis,
  Oa = Ki.trustedTypes,
  Lh = Oa ? Oa.createPolicy("lit-html", { createHTML: (s) => s }) : void 0,
  Cg = "$lit$",
  En = `lit$${Math.random().toFixed(9).slice(2)}$`,
  vg = "?" + En,
  JR = `<${vg}>`,
  or = document,
  ka = () => or.createComment(""),
  Eo = (s) => s === null || (typeof s != "object" && typeof s != "function"),
  hd = Array.isArray,
  XR = (s) =>
    hd(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function",
  $c = `[ 	
\f\r]`,
  Si = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  Mh = /-->/g,
  Bh = />/g,
  Mn = RegExp(
    `>|${$c}(?:([^\\s"'>=/]+)(${$c}*=${$c}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
    "g"
  ),
  Fh = /'/g,
  jh = /"/g,
  Ag = /^(?:script|style|textarea|title)$/i,
  bo = Symbol.for("lit-noChange"),
  at = Symbol.for("lit-nothing"),
  qh = new WeakMap(),
  Yn = or.createTreeWalker(or, 129);
function Ig(s, e) {
  if (!hd(s) || !s.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return Lh !== void 0 ? Lh.createHTML(e) : e;
}
const QR = (s, e) => {
  const t = s.length - 1,
    n = [];
  let r,
    i = e === 2 ? "<svg>" : e === 3 ? "<math>" : "",
    o = Si;
  for (let a = 0; a < t; a++) {
    const c = s[a];
    let l,
      d,
      u = -1,
      p = 0;
    for (; p < c.length && ((o.lastIndex = p), (d = o.exec(c)), d !== null); )
      (p = o.lastIndex),
        o === Si
          ? d[1] === "!--"
            ? (o = Mh)
            : d[1] !== void 0
            ? (o = Bh)
            : d[2] !== void 0
            ? (Ag.test(d[2]) && (r = RegExp("</" + d[2], "g")), (o = Mn))
            : d[3] !== void 0 && (o = Mn)
          : o === Mn
          ? d[0] === ">"
            ? ((o = r ?? Si), (u = -1))
            : d[1] === void 0
            ? (u = -2)
            : ((u = o.lastIndex - d[2].length),
              (l = d[1]),
              (o = d[3] === void 0 ? Mn : d[3] === '"' ? jh : Fh))
          : o === jh || o === Fh
          ? (o = Mn)
          : o === Mh || o === Bh
          ? (o = Si)
          : ((o = Mn), (r = void 0));
    const w = o === Mn && s[a + 1].startsWith("/>") ? " " : "";
    i +=
      o === Si
        ? c + JR
        : u >= 0
        ? (n.push(l), c.slice(0, u) + Cg + c.slice(u) + En + w)
        : c + En + (u === -2 ? a : w);
  }
  return [
    Ig(
      s,
      i + (s[t] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")
    ),
    n,
  ];
};
let kl = class Sg {
  constructor({ strings: e, _$litType$: t }, n) {
    let r;
    this.parts = [];
    let i = 0,
      o = 0;
    const a = e.length - 1,
      c = this.parts,
      [l, d] = QR(e, t);
    if (
      ((this.el = Sg.createElement(l, n)),
      (Yn.currentNode = this.el.content),
      t === 2 || t === 3)
    ) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (r = Yn.nextNode()) !== null && c.length < a; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes())
          for (const u of r.getAttributeNames())
            if (u.endsWith(Cg)) {
              const p = d[o++],
                w = r.getAttribute(u).split(En),
                g = /([.?@])?(.*)/.exec(p);
              c.push({
                type: 1,
                index: i,
                name: g[2],
                strings: w,
                ctor:
                  g[1] === "."
                    ? tx
                    : g[1] === "?"
                    ? sx
                    : g[1] === "@"
                    ? nx
                    : Ya,
              }),
                r.removeAttribute(u);
            } else
              u.startsWith(En) &&
                (c.push({ type: 6, index: i }), r.removeAttribute(u));
        if (Ag.test(r.tagName)) {
          const u = r.textContent.split(En),
            p = u.length - 1;
          if (p > 0) {
            r.textContent = Oa ? Oa.emptyScript : "";
            for (let w = 0; w < p; w++)
              r.append(u[w], ka()),
                Yn.nextNode(),
                c.push({ type: 2, index: ++i });
            r.append(u[p], ka());
          }
        }
      } else if (r.nodeType === 8)
        if (r.data === vg) c.push({ type: 2, index: i });
        else {
          let u = -1;
          for (; (u = r.data.indexOf(En, u + 1)) !== -1; )
            c.push({ type: 7, index: i }), (u += En.length - 1);
        }
      i++;
    }
  }
  static createElement(e, t) {
    const n = or.createElement("template");
    return (n.innerHTML = e), n;
  }
};
function Zr(s, e, t = s, n) {
  var o, a;
  if (e === bo) return e;
  let r = n !== void 0 ? ((o = t._$Co) == null ? void 0 : o[n]) : t._$Cl;
  const i = Eo(e) ? void 0 : e._$litDirective$;
  return (
    (r == null ? void 0 : r.constructor) !== i &&
      ((a = r == null ? void 0 : r._$AO) == null || a.call(r, !1),
      i === void 0 ? (r = void 0) : ((r = new i(s)), r._$AT(s, t, n)),
      n !== void 0 ? ((t._$Co ?? (t._$Co = []))[n] = r) : (t._$Cl = r)),
    r !== void 0 && (e = Zr(s, r._$AS(s, e.values), r, n)),
    e
  );
}
let ex = class {
    constructor(e, t) {
      (this._$AV = []), (this._$AN = void 0), (this._$AD = e), (this._$AM = t);
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(e) {
      const {
          el: { content: t },
          parts: n,
        } = this._$AD,
        r = ((e == null ? void 0 : e.creationScope) ?? or).importNode(t, !0);
      Yn.currentNode = r;
      let i = Yn.nextNode(),
        o = 0,
        a = 0,
        c = n[0];
      for (; c !== void 0; ) {
        if (o === c.index) {
          let l;
          c.type === 2
            ? (l = new Ng(i, i.nextSibling, this, e))
            : c.type === 1
            ? (l = new c.ctor(i, c.name, c.strings, this, e))
            : c.type === 6 && (l = new rx(i, this, e)),
            this._$AV.push(l),
            (c = n[++a]);
        }
        o !== (c == null ? void 0 : c.index) && ((i = Yn.nextNode()), o++);
      }
      return (Yn.currentNode = or), r;
    }
    p(e) {
      let t = 0;
      for (const n of this._$AV)
        n !== void 0 &&
          (n.strings !== void 0
            ? (n._$AI(e, n, t), (t += n.strings.length - 2))
            : n._$AI(e[t])),
          t++;
    }
  },
  Ng = class Tg {
    get _$AU() {
      var e;
      return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
    }
    constructor(e, t, n, r) {
      (this.type = 2),
        (this._$AH = at),
        (this._$AN = void 0),
        (this._$AA = e),
        (this._$AB = t),
        (this._$AM = n),
        (this.options = r),
        (this._$Cv = (r == null ? void 0 : r.isConnected) ?? !0);
    }
    get parentNode() {
      let e = this._$AA.parentNode;
      const t = this._$AM;
      return (
        t !== void 0 &&
          (e == null ? void 0 : e.nodeType) === 11 &&
          (e = t.parentNode),
        e
      );
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(e, t = this) {
      (e = Zr(this, e, t)),
        Eo(e)
          ? e === at || e == null || e === ""
            ? (this._$AH !== at && this._$AR(), (this._$AH = at))
            : e !== this._$AH && e !== bo && this._(e)
          : e._$litType$ !== void 0
          ? this.$(e)
          : e.nodeType !== void 0
          ? this.T(e)
          : XR(e)
          ? this.k(e)
          : this._(e);
    }
    O(e) {
      return this._$AA.parentNode.insertBefore(e, this._$AB);
    }
    T(e) {
      this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)));
    }
    _(e) {
      this._$AH !== at && Eo(this._$AH)
        ? (this._$AA.nextSibling.data = e)
        : this.T(or.createTextNode(e)),
        (this._$AH = e);
    }
    $(e) {
      var i;
      const { values: t, _$litType$: n } = e,
        r =
          typeof n == "number"
            ? this._$AC(e)
            : (n.el === void 0 &&
                (n.el = kl.createElement(Ig(n.h, n.h[0]), this.options)),
              n);
      if (((i = this._$AH) == null ? void 0 : i._$AD) === r) this._$AH.p(t);
      else {
        const o = new ex(r, this),
          a = o.u(this.options);
        o.p(t), this.T(a), (this._$AH = o);
      }
    }
    _$AC(e) {
      let t = qh.get(e.strings);
      return t === void 0 && qh.set(e.strings, (t = new kl(e))), t;
    }
    k(e) {
      hd(this._$AH) || ((this._$AH = []), this._$AR());
      const t = this._$AH;
      let n,
        r = 0;
      for (const i of e)
        r === t.length
          ? t.push((n = new Tg(this.O(ka()), this.O(ka()), this, this.options)))
          : (n = t[r]),
          n._$AI(i),
          r++;
      r < t.length && (this._$AR(n && n._$AB.nextSibling, r), (t.length = r));
    }
    _$AR(e = this._$AA.nextSibling, t) {
      var n;
      for (
        (n = this._$AP) == null ? void 0 : n.call(this, !1, !0, t);
        e && e !== this._$AB;

      ) {
        const r = e.nextSibling;
        e.remove(), (e = r);
      }
    }
    setConnected(e) {
      var t;
      this._$AM === void 0 &&
        ((this._$Cv = e), (t = this._$AP) == null || t.call(this, e));
    }
  },
  Ya = class {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(e, t, n, r, i) {
      (this.type = 1),
        (this._$AH = at),
        (this._$AN = void 0),
        (this.element = e),
        (this.name = t),
        (this._$AM = r),
        (this.options = i),
        n.length > 2 || n[0] !== "" || n[1] !== ""
          ? ((this._$AH = Array(n.length - 1).fill(new String())),
            (this.strings = n))
          : (this._$AH = at);
    }
    _$AI(e, t = this, n, r) {
      const i = this.strings;
      let o = !1;
      if (i === void 0)
        (e = Zr(this, e, t, 0)),
          (o = !Eo(e) || (e !== this._$AH && e !== bo)),
          o && (this._$AH = e);
      else {
        const a = e;
        let c, l;
        for (e = i[0], c = 0; c < i.length - 1; c++)
          (l = Zr(this, a[n + c], t, c)),
            l === bo && (l = this._$AH[c]),
            o || (o = !Eo(l) || l !== this._$AH[c]),
            l === at ? (e = at) : e !== at && (e += (l ?? "") + i[c + 1]),
            (this._$AH[c] = l);
      }
      o && !r && this.j(e);
    }
    j(e) {
      e === at
        ? this.element.removeAttribute(this.name)
        : this.element.setAttribute(this.name, e ?? "");
    }
  },
  tx = class extends Ya {
    constructor() {
      super(...arguments), (this.type = 3);
    }
    j(e) {
      this.element[this.name] = e === at ? void 0 : e;
    }
  },
  sx = class extends Ya {
    constructor() {
      super(...arguments), (this.type = 4);
    }
    j(e) {
      this.element.toggleAttribute(this.name, !!e && e !== at);
    }
  },
  nx = class extends Ya {
    constructor(e, t, n, r, i) {
      super(e, t, n, r, i), (this.type = 5);
    }
    _$AI(e, t = this) {
      if ((e = Zr(this, e, t, 0) ?? at) === bo) return;
      const n = this._$AH,
        r =
          (e === at && n !== at) ||
          e.capture !== n.capture ||
          e.once !== n.once ||
          e.passive !== n.passive,
        i = e !== at && (n === at || r);
      r && this.element.removeEventListener(this.name, this, n),
        i && this.element.addEventListener(this.name, this, e),
        (this._$AH = e);
    }
    handleEvent(e) {
      var t;
      typeof this._$AH == "function"
        ? this._$AH.call(
            ((t = this.options) == null ? void 0 : t.host) ?? this.element,
            e
          )
        : this._$AH.handleEvent(e);
    }
  },
  rx = class {
    constructor(e, t, n) {
      (this.element = e),
        (this.type = 6),
        (this._$AN = void 0),
        (this._$AM = t),
        (this.options = n);
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(e) {
      Zr(this, e);
    }
  };
const Dc = Ki.litHtmlPolyfillSupport;
Dc == null || Dc(kl, Ng),
  (Ki.litHtmlVersions ?? (Ki.litHtmlVersions = [])).push("3.3.0");
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const oa = globalThis,
  pd =
    oa.ShadowRoot &&
    (oa.ShadyCSS === void 0 || oa.ShadyCSS.nativeShadow) &&
    "adoptedStyleSheets" in Document.prototype &&
    "replace" in CSSStyleSheet.prototype,
  fd = Symbol(),
  Hh = new WeakMap();
let Rg = class {
  constructor(e, t, n) {
    if (((this._$cssResult$ = !0), n !== fd))
      throw Error(
        "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
      );
    (this.cssText = e), (this.t = t);
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (pd && e === void 0) {
      const n = t !== void 0 && t.length === 1;
      n && (e = Hh.get(t)),
        e === void 0 &&
          ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText),
          n && Hh.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const ss = (s) => new Rg(typeof s == "string" ? s : s + "", void 0, fd),
  qr = (s, ...e) => {
    const t =
      s.length === 1
        ? s[0]
        : e.reduce(
            (n, r, i) =>
              n +
              ((o) => {
                if (o._$cssResult$ === !0) return o.cssText;
                if (typeof o == "number") return o;
                throw Error(
                  "Value passed to 'css' function must be a 'css' function result: " +
                    o +
                    ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                );
              })(r) +
              s[i + 1],
            s[0]
          );
    return new Rg(t, s, fd);
  },
  ix = (s, e) => {
    if (pd)
      s.adoptedStyleSheets = e.map((t) =>
        t instanceof CSSStyleSheet ? t : t.styleSheet
      );
    else
      for (const t of e) {
        const n = document.createElement("style"),
          r = oa.litNonce;
        r !== void 0 && n.setAttribute("nonce", r),
          (n.textContent = t.cssText),
          s.appendChild(n);
      }
  },
  Wh = pd
    ? (s) => s
    : (s) =>
        s instanceof CSSStyleSheet
          ? ((e) => {
              let t = "";
              for (const n of e.cssRules) t += n.cssText;
              return ss(t);
            })(s)
          : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const {
    is: ox,
    defineProperty: ax,
    getOwnPropertyDescriptor: cx,
    getOwnPropertyNames: lx,
    getOwnPropertySymbols: dx,
    getPrototypeOf: ux,
  } = Object,
  In = globalThis,
  zh = In.trustedTypes,
  hx = zh ? zh.emptyScript : "",
  Lc = In.reactiveElementPolyfillSupport,
  Gi = (s, e) => s,
  Ul = {
    toAttribute(s, e) {
      switch (e) {
        case Boolean:
          s = s ? hx : null;
          break;
        case Object:
        case Array:
          s = s == null ? s : JSON.stringify(s);
      }
      return s;
    },
    fromAttribute(s, e) {
      let t = s;
      switch (e) {
        case Boolean:
          t = s !== null;
          break;
        case Number:
          t = s === null ? null : Number(s);
          break;
        case Object:
        case Array:
          try {
            t = JSON.parse(s);
          } catch {
            t = null;
          }
      }
      return t;
    },
  },
  xg = (s, e) => !ox(s, e),
  Vh = {
    attribute: !0,
    type: String,
    converter: Ul,
    reflect: !1,
    useDefault: !1,
    hasChanged: xg,
  };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")),
  In.litPropertyMetadata ?? (In.litPropertyMetadata = new WeakMap());
let $r = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = Vh) {
    if (
      (t.state && (t.attribute = !1),
      this._$Ei(),
      this.prototype.hasOwnProperty(e) && ((t = Object.create(t)).wrapped = !0),
      this.elementProperties.set(e, t),
      !t.noAccessor)
    ) {
      const n = Symbol(),
        r = this.getPropertyDescriptor(e, n, t);
      r !== void 0 && ax(this.prototype, e, r);
    }
  }
  static getPropertyDescriptor(e, t, n) {
    const { get: r, set: i } = cx(this.prototype, e) ?? {
      get() {
        return this[t];
      },
      set(o) {
        this[t] = o;
      },
    };
    return {
      get: r,
      set(o) {
        const a = r == null ? void 0 : r.call(this);
        i == null || i.call(this, o), this.requestUpdate(e, a, n);
      },
      configurable: !0,
      enumerable: !0,
    };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? Vh;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Gi("elementProperties"))) return;
    const e = ux(this);
    e.finalize(),
      e.l !== void 0 && (this.l = [...e.l]),
      (this.elementProperties = new Map(e.elementProperties));
  }
  static finalize() {
    if (this.hasOwnProperty(Gi("finalized"))) return;
    if (
      ((this.finalized = !0),
      this._$Ei(),
      this.hasOwnProperty(Gi("properties")))
    ) {
      const t = this.properties,
        n = [...lx(t), ...dx(t)];
      for (const r of n) this.createProperty(r, t[r]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0)
        for (const [n, r] of t) this.elementProperties.set(n, r);
    }
    this._$Eh = new Map();
    for (const [t, n] of this.elementProperties) {
      const r = this._$Eu(t, n);
      r !== void 0 && this._$Eh.set(r, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const n = new Set(e.flat(1 / 0).reverse());
      for (const r of n) t.unshift(Wh(r));
    } else e !== void 0 && t.push(Wh(e));
    return t;
  }
  static _$Eu(e, t) {
    const n = t.attribute;
    return n === !1
      ? void 0
      : typeof n == "string"
      ? n
      : typeof e == "string"
      ? e.toLowerCase()
      : void 0;
  }
  constructor() {
    super(),
      (this._$Ep = void 0),
      (this.isUpdatePending = !1),
      (this.hasUpdated = !1),
      (this._$Em = null),
      this._$Ev();
  }
  _$Ev() {
    var e;
    (this._$ES = new Promise((t) => (this.enableUpdating = t))),
      (this._$AL = new Map()),
      this._$E_(),
      this.requestUpdate(),
      (e = this.constructor.l) == null || e.forEach((t) => t(this));
  }
  addController(e) {
    var t;
    (this._$EO ?? (this._$EO = new Set())).add(e),
      this.renderRoot !== void 0 &&
        this.isConnected &&
        ((t = e.hostConnected) == null || t.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$EO) == null || t.delete(e);
  }
  _$E_() {
    const e = new Map(),
      t = this.constructor.elementProperties;
    for (const n of t.keys())
      this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e =
      this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return ix(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
      this.enableUpdating(!0),
      (e = this._$EO) == null ||
        e.forEach((t) => {
          var n;
          return (n = t.hostConnected) == null ? void 0 : n.call(t);
        });
  }
  enableUpdating(e) {}
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null ||
      e.forEach((t) => {
        var n;
        return (n = t.hostDisconnected) == null ? void 0 : n.call(t);
      });
  }
  attributeChangedCallback(e, t, n) {
    this._$AK(e, n);
  }
  _$ET(e, t) {
    var i;
    const n = this.constructor.elementProperties.get(e),
      r = this.constructor._$Eu(e, n);
    if (r !== void 0 && n.reflect === !0) {
      const o = (
        ((i = n.converter) == null ? void 0 : i.toAttribute) !== void 0
          ? n.converter
          : Ul
      ).toAttribute(t, n.type);
      (this._$Em = e),
        o == null ? this.removeAttribute(r) : this.setAttribute(r, o),
        (this._$Em = null);
    }
  }
  _$AK(e, t) {
    var i, o;
    const n = this.constructor,
      r = n._$Eh.get(e);
    if (r !== void 0 && this._$Em !== r) {
      const a = n.getPropertyOptions(r),
        c =
          typeof a.converter == "function"
            ? { fromAttribute: a.converter }
            : ((i = a.converter) == null ? void 0 : i.fromAttribute) !== void 0
            ? a.converter
            : Ul;
      (this._$Em = r),
        (this[r] =
          c.fromAttribute(t, a.type) ??
          ((o = this._$Ej) == null ? void 0 : o.get(r)) ??
          null),
        (this._$Em = null);
    }
  }
  requestUpdate(e, t, n) {
    var r;
    if (e !== void 0) {
      const i = this.constructor,
        o = this[e];
      if (
        (n ?? (n = i.getPropertyOptions(e)),
        !(
          (n.hasChanged ?? xg)(o, t) ||
          (n.useDefault &&
            n.reflect &&
            o === ((r = this._$Ej) == null ? void 0 : r.get(e)) &&
            !this.hasAttribute(i._$Eu(e, n)))
        ))
      )
        return;
      this.C(e, t, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(e, t, { useDefault: n, reflect: r, wrapped: i }, o) {
    (n &&
      !(this._$Ej ?? (this._$Ej = new Map())).has(e) &&
      (this._$Ej.set(e, o ?? t ?? this[e]), i !== !0 || o !== void 0)) ||
      (this._$AL.has(e) ||
        (this.hasUpdated || n || (t = void 0), this._$AL.set(e, t)),
      r === !0 &&
        this._$Em !== e &&
        (this._$Eq ?? (this._$Eq = new Set())).add(e));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && (await e), !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (
        (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
        this._$Ep)
      ) {
        for (const [i, o] of this._$Ep) this[i] = o;
        this._$Ep = void 0;
      }
      const r = this.constructor.elementProperties;
      if (r.size > 0)
        for (const [i, o] of r) {
          const { wrapped: a } = o,
            c = this[i];
          a !== !0 ||
            this._$AL.has(i) ||
            c === void 0 ||
            this.C(i, void 0, o, c);
        }
    }
    let e = !1;
    const t = this._$AL;
    try {
      (e = this.shouldUpdate(t)),
        e
          ? (this.willUpdate(t),
            (n = this._$EO) == null ||
              n.forEach((r) => {
                var i;
                return (i = r.hostUpdate) == null ? void 0 : i.call(r);
              }),
            this.update(t))
          : this._$EM();
    } catch (r) {
      throw ((e = !1), this._$EM(), r);
    }
    e && this._$AE(t);
  }
  willUpdate(e) {}
  _$AE(e) {
    var t;
    (t = this._$EO) == null ||
      t.forEach((n) => {
        var r;
        return (r = n.hostUpdated) == null ? void 0 : r.call(n);
      }),
      this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
      this.updated(e);
  }
  _$EM() {
    (this._$AL = new Map()), (this.isUpdatePending = !1);
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((t) => this._$ET(t, this[t]))),
      this._$EM();
  }
  updated(e) {}
  firstUpdated(e) {}
};
($r.elementStyles = []),
  ($r.shadowRootOptions = { mode: "open" }),
  ($r[Gi("elementProperties")] = new Map()),
  ($r[Gi("finalized")] = new Map()),
  Lc == null || Lc({ ReactiveElement: $r }),
  (In.reactiveElementVersions ?? (In.reactiveElementVersions = [])).push(
    "2.1.0"
  );
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const Yi = globalThis,
  Ua = Yi.trustedTypes,
  Kh = Ua ? Ua.createPolicy("lit-html", { createHTML: (s) => s }) : void 0,
  Pg = "$lit$",
  bn = `lit$${Math.random().toFixed(9).slice(2)}$`,
  Og = "?" + bn,
  px = `<${Og}>`,
  ar = document,
  _o = () => ar.createComment(""),
  Co = (s) => s === null || (typeof s != "object" && typeof s != "function"),
  gd = Array.isArray,
  fx = (s) =>
    gd(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function",
  Mc = `[ 	
\f\r]`,
  Ni = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  Gh = /-->/g,
  Yh = />/g,
  Bn = RegExp(
    `>|${Mc}(?:([^\\s"'>=/]+)(${Mc}*=${Mc}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
    "g"
  ),
  Zh = /'/g,
  Jh = /"/g,
  kg = /^(?:script|style|textarea|title)$/i,
  Ug =
    (s) =>
    (e, ...t) => ({ _$litType$: s, strings: e, values: t }),
  mP = Ug(1),
  wP = Ug(2),
  Jr = Symbol.for("lit-noChange"),
  ct = Symbol.for("lit-nothing"),
  Xh = new WeakMap(),
  Zn = ar.createTreeWalker(ar, 129);
function $g(s, e) {
  if (!gd(s) || !s.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return Kh !== void 0 ? Kh.createHTML(e) : e;
}
const gx = (s, e) => {
  const t = s.length - 1,
    n = [];
  let r,
    i = e === 2 ? "<svg>" : e === 3 ? "<math>" : "",
    o = Ni;
  for (let a = 0; a < t; a++) {
    const c = s[a];
    let l,
      d,
      u = -1,
      p = 0;
    for (; p < c.length && ((o.lastIndex = p), (d = o.exec(c)), d !== null); )
      (p = o.lastIndex),
        o === Ni
          ? d[1] === "!--"
            ? (o = Gh)
            : d[1] !== void 0
            ? (o = Yh)
            : d[2] !== void 0
            ? (kg.test(d[2]) && (r = RegExp("</" + d[2], "g")), (o = Bn))
            : d[3] !== void 0 && (o = Bn)
          : o === Bn
          ? d[0] === ">"
            ? ((o = r ?? Ni), (u = -1))
            : d[1] === void 0
            ? (u = -2)
            : ((u = o.lastIndex - d[2].length),
              (l = d[1]),
              (o = d[3] === void 0 ? Bn : d[3] === '"' ? Jh : Zh))
          : o === Jh || o === Zh
          ? (o = Bn)
          : o === Gh || o === Yh
          ? (o = Ni)
          : ((o = Bn), (r = void 0));
    const w = o === Bn && s[a + 1].startsWith("/>") ? " " : "";
    i +=
      o === Ni
        ? c + px
        : u >= 0
        ? (n.push(l), c.slice(0, u) + Pg + c.slice(u) + bn + w)
        : c + bn + (u === -2 ? a : w);
  }
  return [
    $g(
      s,
      i + (s[t] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")
    ),
    n,
  ];
};
class vo {
  constructor({ strings: e, _$litType$: t }, n) {
    let r;
    this.parts = [];
    let i = 0,
      o = 0;
    const a = e.length - 1,
      c = this.parts,
      [l, d] = gx(e, t);
    if (
      ((this.el = vo.createElement(l, n)),
      (Zn.currentNode = this.el.content),
      t === 2 || t === 3)
    ) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (r = Zn.nextNode()) !== null && c.length < a; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes())
          for (const u of r.getAttributeNames())
            if (u.endsWith(Pg)) {
              const p = d[o++],
                w = r.getAttribute(u).split(bn),
                g = /([.?@])?(.*)/.exec(p);
              c.push({
                type: 1,
                index: i,
                name: g[2],
                strings: w,
                ctor:
                  g[1] === "."
                    ? wx
                    : g[1] === "?"
                    ? yx
                    : g[1] === "@"
                    ? Ex
                    : Za,
              }),
                r.removeAttribute(u);
            } else
              u.startsWith(bn) &&
                (c.push({ type: 6, index: i }), r.removeAttribute(u));
        if (kg.test(r.tagName)) {
          const u = r.textContent.split(bn),
            p = u.length - 1;
          if (p > 0) {
            r.textContent = Ua ? Ua.emptyScript : "";
            for (let w = 0; w < p; w++)
              r.append(u[w], _o()),
                Zn.nextNode(),
                c.push({ type: 2, index: ++i });
            r.append(u[p], _o());
          }
        }
      } else if (r.nodeType === 8)
        if (r.data === Og) c.push({ type: 2, index: i });
        else {
          let u = -1;
          for (; (u = r.data.indexOf(bn, u + 1)) !== -1; )
            c.push({ type: 7, index: i }), (u += bn.length - 1);
        }
      i++;
    }
  }
  static createElement(e, t) {
    const n = ar.createElement("template");
    return (n.innerHTML = e), n;
  }
}
function Xr(s, e, t = s, n) {
  var o, a;
  if (e === Jr) return e;
  let r = n !== void 0 ? ((o = t._$Co) == null ? void 0 : o[n]) : t._$Cl;
  const i = Co(e) ? void 0 : e._$litDirective$;
  return (
    (r == null ? void 0 : r.constructor) !== i &&
      ((a = r == null ? void 0 : r._$AO) == null || a.call(r, !1),
      i === void 0 ? (r = void 0) : ((r = new i(s)), r._$AT(s, t, n)),
      n !== void 0 ? ((t._$Co ?? (t._$Co = []))[n] = r) : (t._$Cl = r)),
    r !== void 0 && (e = Xr(s, r._$AS(s, e.values), r, n)),
    e
  );
}
class mx {
  constructor(e, t) {
    (this._$AV = []), (this._$AN = void 0), (this._$AD = e), (this._$AM = t);
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const {
        el: { content: t },
        parts: n,
      } = this._$AD,
      r = ((e == null ? void 0 : e.creationScope) ?? ar).importNode(t, !0);
    Zn.currentNode = r;
    let i = Zn.nextNode(),
      o = 0,
      a = 0,
      c = n[0];
    for (; c !== void 0; ) {
      if (o === c.index) {
        let l;
        c.type === 2
          ? (l = new ko(i, i.nextSibling, this, e))
          : c.type === 1
          ? (l = new c.ctor(i, c.name, c.strings, this, e))
          : c.type === 6 && (l = new bx(i, this, e)),
          this._$AV.push(l),
          (c = n[++a]);
      }
      o !== (c == null ? void 0 : c.index) && ((i = Zn.nextNode()), o++);
    }
    return (Zn.currentNode = ar), r;
  }
  p(e) {
    let t = 0;
    for (const n of this._$AV)
      n !== void 0 &&
        (n.strings !== void 0
          ? (n._$AI(e, n, t), (t += n.strings.length - 2))
          : n._$AI(e[t])),
        t++;
  }
}
class ko {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, t, n, r) {
    (this.type = 2),
      (this._$AH = ct),
      (this._$AN = void 0),
      (this._$AA = e),
      (this._$AB = t),
      (this._$AM = n),
      (this.options = r),
      (this._$Cv = (r == null ? void 0 : r.isConnected) ?? !0);
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return (
      t !== void 0 &&
        (e == null ? void 0 : e.nodeType) === 11 &&
        (e = t.parentNode),
      e
    );
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    (e = Xr(this, e, t)),
      Co(e)
        ? e === ct || e == null || e === ""
          ? (this._$AH !== ct && this._$AR(), (this._$AH = ct))
          : e !== this._$AH && e !== Jr && this._(e)
        : e._$litType$ !== void 0
        ? this.$(e)
        : e.nodeType !== void 0
        ? this.T(e)
        : fx(e)
        ? this.k(e)
        : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)));
  }
  _(e) {
    this._$AH !== ct && Co(this._$AH)
      ? (this._$AA.nextSibling.data = e)
      : this.T(ar.createTextNode(e)),
      (this._$AH = e);
  }
  $(e) {
    var i;
    const { values: t, _$litType$: n } = e,
      r =
        typeof n == "number"
          ? this._$AC(e)
          : (n.el === void 0 &&
              (n.el = vo.createElement($g(n.h, n.h[0]), this.options)),
            n);
    if (((i = this._$AH) == null ? void 0 : i._$AD) === r) this._$AH.p(t);
    else {
      const o = new mx(r, this),
        a = o.u(this.options);
      o.p(t), this.T(a), (this._$AH = o);
    }
  }
  _$AC(e) {
    let t = Xh.get(e.strings);
    return t === void 0 && Xh.set(e.strings, (t = new vo(e))), t;
  }
  k(e) {
    gd(this._$AH) || ((this._$AH = []), this._$AR());
    const t = this._$AH;
    let n,
      r = 0;
    for (const i of e)
      r === t.length
        ? t.push((n = new ko(this.O(_o()), this.O(_o()), this, this.options)))
        : (n = t[r]),
        n._$AI(i),
        r++;
    r < t.length && (this._$AR(n && n._$AB.nextSibling, r), (t.length = r));
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var n;
    for (
      (n = this._$AP) == null ? void 0 : n.call(this, !1, !0, t);
      e && e !== this._$AB;

    ) {
      const r = e.nextSibling;
      e.remove(), (e = r);
    }
  }
  setConnected(e) {
    var t;
    this._$AM === void 0 &&
      ((this._$Cv = e), (t = this._$AP) == null || t.call(this, e));
  }
}
class Za {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, n, r, i) {
    (this.type = 1),
      (this._$AH = ct),
      (this._$AN = void 0),
      (this.element = e),
      (this.name = t),
      (this._$AM = r),
      (this.options = i),
      n.length > 2 || n[0] !== "" || n[1] !== ""
        ? ((this._$AH = Array(n.length - 1).fill(new String())),
          (this.strings = n))
        : (this._$AH = ct);
  }
  _$AI(e, t = this, n, r) {
    const i = this.strings;
    let o = !1;
    if (i === void 0)
      (e = Xr(this, e, t, 0)),
        (o = !Co(e) || (e !== this._$AH && e !== Jr)),
        o && (this._$AH = e);
    else {
      const a = e;
      let c, l;
      for (e = i[0], c = 0; c < i.length - 1; c++)
        (l = Xr(this, a[n + c], t, c)),
          l === Jr && (l = this._$AH[c]),
          o || (o = !Co(l) || l !== this._$AH[c]),
          l === ct ? (e = ct) : e !== ct && (e += (l ?? "") + i[c + 1]),
          (this._$AH[c] = l);
    }
    o && !r && this.j(e);
  }
  j(e) {
    e === ct
      ? this.element.removeAttribute(this.name)
      : this.element.setAttribute(this.name, e ?? "");
  }
}
class wx extends Za {
  constructor() {
    super(...arguments), (this.type = 3);
  }
  j(e) {
    this.element[this.name] = e === ct ? void 0 : e;
  }
}
class yx extends Za {
  constructor() {
    super(...arguments), (this.type = 4);
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== ct);
  }
}
class Ex extends Za {
  constructor(e, t, n, r, i) {
    super(e, t, n, r, i), (this.type = 5);
  }
  _$AI(e, t = this) {
    if ((e = Xr(this, e, t, 0) ?? ct) === Jr) return;
    const n = this._$AH,
      r =
        (e === ct && n !== ct) ||
        e.capture !== n.capture ||
        e.once !== n.once ||
        e.passive !== n.passive,
      i = e !== ct && (n === ct || r);
    r && this.element.removeEventListener(this.name, this, n),
      i && this.element.addEventListener(this.name, this, e),
      (this._$AH = e);
  }
  handleEvent(e) {
    var t;
    typeof this._$AH == "function"
      ? this._$AH.call(
          ((t = this.options) == null ? void 0 : t.host) ?? this.element,
          e
        )
      : this._$AH.handleEvent(e);
  }
}
class bx {
  constructor(e, t, n) {
    (this.element = e),
      (this.type = 6),
      (this._$AN = void 0),
      (this._$AM = t),
      (this.options = n);
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    Xr(this, e);
  }
}
const Bc = Yi.litHtmlPolyfillSupport;
Bc == null || Bc(vo, ko),
  (Yi.litHtmlVersions ?? (Yi.litHtmlVersions = [])).push("3.3.0");
const _x = (s, e, t) => {
  const n = (t == null ? void 0 : t.renderBefore) ?? e;
  let r = n._$litPart$;
  if (r === void 0) {
    const i = (t == null ? void 0 : t.renderBefore) ?? null;
    n._$litPart$ = r = new ko(e.insertBefore(_o(), i), i, void 0, t ?? {});
  }
  return r._$AI(s), r;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const Xn = globalThis;
class aa extends $r {
  constructor() {
    super(...arguments),
      (this.renderOptions = { host: this }),
      (this._$Do = void 0);
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (
      (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild),
      e
    );
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
      super.update(e),
      (this._$Do = _x(t, this.renderRoot, this.renderOptions));
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return Jr;
  }
}
var sp;
(aa._$litElement$ = !0),
  (aa.finalized = !0),
  (sp = Xn.litElementHydrateSupport) == null || sp.call(Xn, { LitElement: aa });
const Fc = Xn.litElementPolyfillSupport;
Fc == null || Fc({ LitElement: aa });
(Xn.litElementVersions ?? (Xn.litElementVersions = [])).push("4.2.0");
let Zi, Sn, Nn;
function yP(s, e) {
  (Zi = document.createElement("style")),
    (Sn = document.createElement("style")),
    (Nn = document.createElement("style")),
    (Zi.textContent = Hr(s).core.cssText),
    (Sn.textContent = Hr(s).dark.cssText),
    (Nn.textContent = Hr(s).light.cssText),
    document.head.appendChild(Zi),
    document.head.appendChild(Sn),
    document.head.appendChild(Nn),
    Dg(e);
}
function Dg(s) {
  Sn &&
    Nn &&
    (s === "light"
      ? (Sn.removeAttribute("media"), (Nn.media = "enabled"))
      : (Nn.removeAttribute("media"), (Sn.media = "enabled")));
}
function Cx(s) {
  Zi &&
    Sn &&
    Nn &&
    ((Zi.textContent = Hr(s).core.cssText),
    (Sn.textContent = Hr(s).dark.cssText),
    (Nn.textContent = Hr(s).light.cssText));
}
function Hr(s) {
  return {
    core: qr`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${ss(
          s != null && s["--w3m-color-mix-strength"]
            ? `${s["--w3m-color-mix-strength"]}%`
            : "0%"
        )};
        --w3m-font-family: ${ss(
          (s == null ? void 0 : s["--w3m-font-family"]) ||
            "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;"
        )};
        --w3m-font-size-master: ${ss(
          (s == null ? void 0 : s["--w3m-font-size-master"]) || "10px"
        )};
        --w3m-border-radius-master: ${ss(
          (s == null ? void 0 : s["--w3m-border-radius-master"]) || "4px"
        )};
        --w3m-z-index: ${ss((s == null ? void 0 : s["--w3m-z-index"]) || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
    light: qr`
      :root {
        --w3m-color-mix: ${ss(
          (s == null ? void 0 : s["--w3m-color-mix"]) || "#fff"
        )};
        --w3m-accent: ${ss(Zs(s, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${ss(Zs(s, "dark")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
    dark: qr`
      :root {
        --w3m-color-mix: ${ss(
          (s == null ? void 0 : s["--w3m-color-mix"]) || "#000"
        )};
        --w3m-accent: ${ss(Zs(s, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${ss(Zs(s, "light")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `,
  };
}
const EP = qr`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
  bP = qr`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
  _P = qr`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`,
  ca = {
    hexStringToNumber(s) {
      const e = s.startsWith("0x") ? s.slice(2) : s;
      return parseInt(e, 16);
    },
    numberToHexString(s) {
      return `0x${s.toString(16)}`;
    },
    async getUserInfo(s) {
      const [e, t] = await Promise.all([ca.getAddresses(s), ca.getChainId(s)]);
      return { chainId: t, addresses: e };
    },
    async getChainId(s) {
      const e = await s.request({ method: "eth_chainId" });
      return Number(e);
    },
    async getAddress(s) {
      const [e] = await s.request({ method: "eth_accounts" });
      return e;
    },
    async getAddresses(s) {
      return await s.request({ method: "eth_accounts" });
    },
    async addEthereumChain(s, e) {
      var n, r;
      const t = ((n = e.rpcUrls.chainDefault) == null ? void 0 : n.http) || [];
      await s.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: ca.numberToHexString(e.id),
            rpcUrls: [...t],
            chainName: e.name,
            nativeCurrency: {
              name: e.nativeCurrency.name,
              decimals: e.nativeCurrency.decimals,
              symbol: e.nativeCurrency.symbol,
            },
            blockExplorerUrls: [
              (r = e.blockExplorers) == null ? void 0 : r.default.url,
            ],
            iconUrls: [io.NetworkImageIds[e.id]],
          },
        ],
      });
    },
  },
  Pr = { ACCOUNT_INDEXES: { PAYMENT: 0, ORDINAL: 1 } };
function Uo(s) {
  return { formatters: void 0, fees: void 0, serializers: void 0, ...s };
}
const Qh = Uo({
    id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    name: "Solana",
    network: "solana-mainnet",
    nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
    rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
    blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
    testnet: !1,
    chainNamespace: "solana",
    caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
  }),
  ep = Uo({
    id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    name: "Solana Devnet",
    network: "solana-devnet",
    nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
    rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
    blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
    testnet: !0,
    chainNamespace: "solana",
    caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K",
  });
Uo({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: !0,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
});
Uo({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
  rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
});
Uo({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
  rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
  testnet: !0,
});
const Lg = {
    solana: [
      "solana_signMessage",
      "solana_signTransaction",
      "solana_requestAccounts",
      "solana_getAccounts",
      "solana_signAllTransactions",
      "solana_signAndSendTransaction",
    ],
    eip155: [
      "eth_accounts",
      "eth_requestAccounts",
      "eth_sendRawTransaction",
      "eth_sign",
      "eth_signTransaction",
      "eth_signTypedData",
      "eth_signTypedData_v3",
      "eth_signTypedData_v4",
      "eth_sendTransaction",
      "personal_sign",
      "wallet_switchEthereumChain",
      "wallet_addEthereumChain",
      "wallet_getPermissions",
      "wallet_requestPermissions",
      "wallet_registerOnboarding",
      "wallet_watchAsset",
      "wallet_scanQRCode",
      "wallet_getCallsStatus",
      "wallet_showCallsStatus",
      "wallet_sendCalls",
      "wallet_getCapabilities",
      "wallet_grantPermissions",
      "wallet_revokePermissions",
      "wallet_getAssets",
    ],
    bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"],
  },
  Ls = {
    getMethodsByChainNamespace(s) {
      return Lg[s] || [];
    },
    createDefaultNamespace(s) {
      return {
        methods: this.getMethodsByChainNamespace(s),
        events: ["accountsChanged", "chainChanged"],
        chains: [],
        rpcMap: {},
      };
    },
    applyNamespaceOverrides(s, e) {
      if (!e) return { ...s };
      const t = { ...s },
        n = new Set();
      if (
        (e.methods && Object.keys(e.methods).forEach((r) => n.add(r)),
        e.chains && Object.keys(e.chains).forEach((r) => n.add(r)),
        e.events && Object.keys(e.events).forEach((r) => n.add(r)),
        e.rpcMap &&
          Object.keys(e.rpcMap).forEach((r) => {
            const [i] = r.split(":");
            i && n.add(i);
          }),
        n.forEach((r) => {
          t[r] || (t[r] = this.createDefaultNamespace(r));
        }),
        e.methods &&
          Object.entries(e.methods).forEach(([r, i]) => {
            t[r] && (t[r].methods = i);
          }),
        e.chains &&
          Object.entries(e.chains).forEach(([r, i]) => {
            t[r] && (t[r].chains = i);
          }),
        e.events &&
          Object.entries(e.events).forEach(([r, i]) => {
            t[r] && (t[r].events = i);
          }),
        e.rpcMap)
      ) {
        const r = new Set();
        Object.entries(e.rpcMap).forEach(([i, o]) => {
          const [a, c] = i.split(":");
          !a ||
            !c ||
            !t[a] ||
            (t[a].rpcMap || (t[a].rpcMap = {}),
            r.has(a) || ((t[a].rpcMap = {}), r.add(a)),
            (t[a].rpcMap[c] = o));
        });
      }
      return t;
    },
    createNamespaces(s, e) {
      const t = s.reduce((n, r) => {
        const { id: i, chainNamespace: o, rpcUrls: a } = r,
          c = a.default.http[0];
        n[o] || (n[o] = this.createDefaultNamespace(o));
        const l = `${o}:${i}`,
          d = n[o];
        switch ((d.chains.push(l), l)) {
          case Qh.caipNetworkId:
            d.chains.push(Qh.deprecatedCaipNetworkId);
            break;
          case ep.caipNetworkId:
            d.chains.push(ep.deprecatedCaipNetworkId);
            break;
        }
        return d != null && d.rpcMap && c && (d.rpcMap[i] = c), n;
      }, {});
      return this.applyNamespaceOverrides(t, e);
    },
    resolveReownName: async (s) => {
      var n;
      const e = await Di.resolveName(s);
      return (
        ((n = (Object.values(e == null ? void 0 : e.addresses) || [])[0]) ==
        null
          ? void 0
          : n.address) || !1
      );
    },
    getChainsFromNamespaces(s = {}) {
      return Object.values(s).flatMap((e) => {
        const t = e.chains || [],
          n = e.accounts.map((r) => {
            const [i, o] = r.split(":");
            return `${i}:${o}`;
          });
        return Array.from(new Set([...t, ...n]));
      });
    },
    isSessionEventData(s) {
      return (
        typeof s == "object" &&
        s !== null &&
        "id" in s &&
        "topic" in s &&
        "params" in s &&
        typeof s.params == "object" &&
        s.params !== null &&
        "chainId" in s.params &&
        "event" in s.params &&
        typeof s.params.event == "object" &&
        s.params.event !== null
      );
    },
    isOriginAllowed(s, e, t) {
      for (const n of [...e, ...t])
        if (n.includes("*")) {
          const i = `^${n
            .replace(/[.*+?^${}()|[\]\\]/gu, "\\$&")
            .replace(/\\\*/gu, ".*")}$`;
          if (new RegExp(i, "u").test(s)) return !0;
        } else
          try {
            if (new URL(n).origin === s) return !0;
          } catch {
            if (n === s) return !0;
          }
      return !1;
    },
    listenWcProvider({
      universalProvider: s,
      namespace: e,
      onConnect: t,
      onDisconnect: n,
      onAccountsChanged: r,
      onChainChanged: i,
      onDisplayUri: o,
    }) {
      t &&
        s.on("connect", () => {
          const a = Ls.getWalletConnectAccounts(s, e);
          t(a);
        }),
        n &&
          s.on("disconnect", () => {
            n();
          }),
        r &&
          s.on("session_event", (a) => {
            if (Ls.isSessionEventData(a)) {
              const { name: c, data: l } = a.params.event;
              if (c === "accountsChanged" && Array.isArray(l)) {
                const d = l
                  .filter((u) => ne.isCaipAddress(u))
                  .map((u) => Mt.parseCaipAddress(u))
                  .filter((u) => u.chainNamespace === e);
                r(d);
              }
            }
          }),
        i &&
          s.on("chainChanged", (a) => {
            i(a);
          }),
        o &&
          s.on("display_uri", (a) => {
            o(a);
          });
    },
    getWalletConnectAccounts(s, e) {
      var r, i, o, a;
      const t = new Set(),
        n =
          (a =
            (o =
              (i =
                (r = s == null ? void 0 : s.session) == null
                  ? void 0
                  : r.namespaces) == null
                ? void 0
                : i[e]) == null
              ? void 0
              : o.accounts) == null
            ? void 0
            : a
                .map((c) => Mt.parseCaipAddress(c))
                .filter(({ address: c }) =>
                  t.has(c.toLowerCase()) ? !1 : (t.add(c.toLowerCase()), !0)
                );
      return n && n.length > 0 ? n : [];
    },
  };
class vx {
  constructor(e) {
    this.namespace = e.namespace;
  }
  async syncConnections(e) {
    switch (this.namespace) {
      case S.CHAIN.EVM:
        await this.syncEVMConnections(e);
        break;
      case S.CHAIN.SOLANA:
        await this.syncSolanaConnections(e);
        break;
      case S.CHAIN.BITCOIN:
        await this.syncBitcoinConnections(e);
        break;
      default:
        throw new Error(`Unsupported chain namespace: ${this.namespace}`);
    }
  }
  async syncEVMConnections({
    connectors: e,
    caipNetworks: t,
    universalProvider: n,
    getConnectionStatusInfo: r,
    onConnection: i,
    onListenProvider: o,
  }) {
    await Promise.all(
      e
        .filter((a) => {
          const { hasDisconnected: c, hasConnected: l } = r(a.id);
          return !c && l;
        })
        .map(async (a) => {
          if (a.id === S.CONNECTOR_ID.WALLET_CONNECT) {
            const c = Ls.getWalletConnectAccounts(n, this.namespace),
              l = t.find((d) => {
                var u, p;
                return (
                  d.chainNamespace === this.namespace &&
                  d.id.toString() ===
                    ((p = (u = c[0]) == null ? void 0 : u.chainId) == null
                      ? void 0
                      : p.toString())
                );
              });
            c.length > 0 &&
              i({
                connectorId: a.id,
                accounts: c.map((d) => ({ address: d.address })),
                caipNetwork: l,
              });
          } else {
            const { accounts: c, chainId: l } = await ra.fetchProviderData(a);
            if (c.length > 0 && l) {
              const d = t.find(
                (u) =>
                  u.chainNamespace === this.namespace &&
                  u.id.toString() === l.toString()
              );
              i({
                connectorId: a.id,
                accounts: c.map((u) => ({ address: u })),
                caipNetwork: d,
              }),
                a.provider &&
                  a.id !== S.CONNECTOR_ID.AUTH &&
                  a.id !== S.CONNECTOR_ID.WALLET_CONNECT &&
                  o(a.id, a.provider);
            }
          }
        })
    );
  }
  async syncSolanaConnections({
    connectors: e,
    caipNetwork: t,
    universalProvider: n,
    getConnectionStatusInfo: r,
    onConnection: i,
    onListenProvider: o,
  }) {
    await Promise.all(
      e
        .filter((a) => {
          const { hasDisconnected: c, hasConnected: l } = r(a.id);
          return !c && l;
        })
        .map(async (a) => {
          if (a.id === S.CONNECTOR_ID.WALLET_CONNECT) {
            const c = Ls.getWalletConnectAccounts(n, this.namespace);
            c.length > 0 &&
              i({
                connectorId: a.id,
                accounts: c.map((l) => ({ address: l.address })),
                caipNetwork: t,
              });
          } else {
            const c = await a.connect({ chainId: t == null ? void 0 : t.id });
            c &&
              (i({
                connectorId: a.id,
                accounts: [{ address: c }],
                caipNetwork: t,
              }),
              o(a.id, a.provider));
          }
        })
    );
  }
  async syncBitcoinConnections({
    connectors: e,
    caipNetwork: t,
    universalProvider: n,
    getConnectionStatusInfo: r,
    onConnection: i,
    onListenProvider: o,
  }) {
    await Promise.all(
      e
        .filter((a) => {
          const { hasDisconnected: c, hasConnected: l } = r(a.id);
          return !c && l;
        })
        .map(async (a) => {
          var p, w, g, m, f, E;
          if (a.id === S.CONNECTOR_ID.WALLET_CONNECT) {
            const b = Ls.getWalletConnectAccounts(n, this.namespace);
            b.length > 0 &&
              i({
                connectorId: a.id,
                accounts: b.map((_) => ({ address: _.address })),
                caipNetwork: t,
              });
            return;
          }
          const c = await a.connect(),
            l = await a.getAccountAddresses();
          let d =
            l == null
              ? void 0
              : l.map((b) =>
                  ne.createAccount(
                    S.CHAIN.BITCOIN,
                    b.address,
                    b.purpose || "payment",
                    b.publicKey,
                    b.path
                  )
                );
          if (
            (d &&
              d.length > 1 &&
              (d = [
                {
                  namespace: S.CHAIN.BITCOIN,
                  publicKey:
                    ((p = d[Pr.ACCOUNT_INDEXES.PAYMENT]) == null
                      ? void 0
                      : p.publicKey) ?? "",
                  path:
                    ((w = d[Pr.ACCOUNT_INDEXES.PAYMENT]) == null
                      ? void 0
                      : w.path) ?? "",
                  address:
                    ((g = d[Pr.ACCOUNT_INDEXES.PAYMENT]) == null
                      ? void 0
                      : g.address) ?? "",
                  type: "payment",
                },
                {
                  namespace: S.CHAIN.BITCOIN,
                  publicKey:
                    ((m = d[Pr.ACCOUNT_INDEXES.ORDINAL]) == null
                      ? void 0
                      : m.publicKey) ?? "",
                  path:
                    ((f = d[Pr.ACCOUNT_INDEXES.ORDINAL]) == null
                      ? void 0
                      : f.path) ?? "",
                  address:
                    ((E = d[Pr.ACCOUNT_INDEXES.ORDINAL]) == null
                      ? void 0
                      : E.address) ?? "",
                  type: "ordinal",
                },
              ]),
            !(
              a.chains.find((b) => b.id === (t == null ? void 0 : t.id)) ||
              a.chains[0]
            ))
          )
            throw new Error(
              "The connector does not support any of the requested chains"
            );
          c &&
            (o(a.id, a.provider),
            i({
              connectorId: a.id,
              accounts: d.map((b) => ({ address: b.address, type: b.type })),
              caipNetwork: t,
            }));
        })
    );
  }
  getConnection({ address: e, connectorId: t, connections: n, connectors: r }) {
    if (t) {
      const o = n.find((l) => At.isLowerCaseMatch(l.connectorId, t));
      if (!o) return null;
      const a = r.find((l) => At.isLowerCaseMatch(l.id, o.connectorId)),
        c = e
          ? o.accounts.find((l) => At.isLowerCaseMatch(l.address, e))
          : o.accounts[0];
      return { ...o, account: c, connector: a };
    }
    const i = n.find(
      (o) =>
        o.accounts.length > 0 &&
        r.some((a) => At.isLowerCaseMatch(a.id, o.connectorId))
    );
    if (i) {
      const [o] = i.accounts,
        a = r.find((c) => At.isLowerCaseMatch(c.id, i.connectorId));
      return { ...i, account: o, connector: a };
    }
    return null;
  }
}
const Br = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603,
  DEFAULT_ALLOWED_ANCESTORS: [
    "http://localhost:*",
    "https://localhost:*",
    "http://127.0.0.1:*",
    "https://127.0.0.1:*",
    "https://*.pages.dev",
    "https://*.vercel.app",
    "https://*.ngrok-free.app",
    "https://secure-mobile.walletconnect.com",
    "https://secure-mobile.walletconnect.org",
  ],
};
class Mg {
  constructor({ provider: e, namespace: t }) {
    (this.id = S.CONNECTOR_ID.WALLET_CONNECT),
      (this.name = io.ConnectorNamesMap[S.CONNECTOR_ID.WALLET_CONNECT]),
      (this.type = "WALLET_CONNECT"),
      (this.imageId = io.ConnectorImageIds[S.CONNECTOR_ID.WALLET_CONNECT]),
      (this.getCaipNetworks = y.getCaipNetworks.bind(y)),
      (this.caipNetworks = this.getCaipNetworks()),
      (this.provider = e),
      (this.chain = t);
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    if (!(await this.authenticate())) {
      const t = this.getCaipNetworks(),
        n = R.state.universalProviderConfigOverride,
        r = Ls.createNamespaces(t, n);
      await this.provider.connect({ optionalNamespaces: r });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session,
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const e = this.chains.map((t) => t.caipNetworkId);
    return ms.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains: e,
      methods: Ax,
    });
  }
}
const Ax = [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    "wallet_getCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    "wallet_getAssets",
  ],
  Ix = [S.CONNECTOR_ID.AUTH, S.CONNECTOR_ID.WALLET_CONNECT];
class Sx {
  constructor(e) {
    (this.availableConnectors = []),
      (this.availableConnections = []),
      (this.providerHandlers = {}),
      (this.eventListeners = new Map()),
      (this.getCaipNetworks = (t) => y.getCaipNetworks(t)),
      (this.getConnectorId = (t) => q.getConnectorId(t)),
      e && this.construct(e),
      e != null &&
        e.namespace &&
        (this.connectionManager = new vx({ namespace: e.namespace }));
  }
  construct(e) {
    (this.projectId = e.projectId),
      (this.namespace = e.namespace),
      (this.adapterType = e.adapterType);
  }
  get connectors() {
    return this.availableConnectors;
  }
  get connections() {
    return this.availableConnections;
  }
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  onAuthConnected({ accounts: e, chainId: t }) {
    const n = this.getCaipNetworks()
      .filter((r) => r.chainNamespace === this.namespace)
      .find((r) => r.id.toString() === (t == null ? void 0 : t.toString()));
    e &&
      n &&
      this.addConnection({
        connectorId: S.CONNECTOR_ID.AUTH,
        accounts: e,
        caipNetwork: n,
      });
  }
  setAuthProvider(e) {
    e.onConnect(this.onAuthConnected.bind(this)),
      e.onSocialConnected(this.onAuthConnected.bind(this)),
      this.addConnector({
        id: S.CONNECTOR_ID.AUTH,
        type: "AUTH",
        name: S.CONNECTOR_NAMES.AUTH,
        provider: e,
        imageId: io.ConnectorImageIds[S.CONNECTOR_ID.AUTH],
        chain: this.namespace,
        chains: [],
      });
  }
  addConnector(...e) {
    const t = new Set();
    (this.availableConnectors = [...e, ...this.availableConnectors].filter(
      (n) => (t.has(n.id) ? !1 : (t.add(n.id), !0))
    )),
      this.emit("connectors", this.availableConnectors);
  }
  addConnection(...e) {
    const t = new Set();
    (this.availableConnections = [...e, ...this.availableConnections].filter(
      (n) =>
        t.has(n.connectorId.toLowerCase())
          ? !1
          : (t.add(n.connectorId.toLowerCase()), !0)
    )),
      this.emit("connections", this.availableConnections);
  }
  deleteConnection(e) {
    (this.availableConnections = this.availableConnections.filter(
      (t) => !At.isLowerCaseMatch(t.connectorId, e)
    )),
      this.emit("connections", this.availableConnections);
  }
  clearConnections(e = !1) {
    (this.availableConnections = []),
      e && this.emit("connections", this.availableConnections);
  }
  setStatus(e, t) {
    se.setStatus(e, t);
  }
  on(e, t) {
    var n;
    this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
      (n = this.eventListeners.get(e)) == null || n.add(t);
  }
  off(e, t) {
    const n = this.eventListeners.get(e);
    n && n.delete(t);
  }
  removeAllEventListeners() {
    this.eventListeners.forEach((e) => {
      e.clear();
    });
  }
  emit(e, t) {
    const n = this.eventListeners.get(e);
    n && n.forEach((r) => r(t));
  }
  async connectWalletConnect(e) {
    return {
      clientId: (await this.getWalletConnectConnector().connectWalletConnect())
        .clientId,
    };
  }
  async switchNetwork(e) {
    const { caipNetwork: t, providerType: n } = e;
    if (!e.provider) return;
    const r = "provider" in e.provider ? e.provider.provider : e.provider;
    if (n === "WALLET_CONNECT") {
      r.setDefaultChain(t.caipNetworkId);
      return;
    }
    if (r && n === "AUTH") {
      const i = r,
        o = Cs(t.chainNamespace);
      await i.switchNetwork({ chainId: t.caipNetworkId });
      const a = await i.getUser({
        chainId: t.caipNetworkId,
        preferredAccountType: o,
      });
      this.emit("switchNetwork", a);
    }
  }
  getWalletConnectConnector() {
    const e = this.connectors.find((t) => t instanceof Mg);
    if (!e) throw new Error("WalletConnectConnector not found");
    return e;
  }
  onConnect(e, t) {
    if (e.length > 0) {
      const { address: n, chainId: r } = ne.getAccount(e[0]),
        i = this.getCaipNetworks()
          .filter((a) => a.chainNamespace === this.namespace)
          .find((a) => a.id.toString() === (r == null ? void 0 : r.toString())),
        o = this.connectors.find((a) => a.id === t);
      n &&
        (this.emit("accountChanged", { address: n, chainId: r, connector: o }),
        this.addConnection({
          connectorId: t,
          accounts: e.map((a) => {
            const { address: c } = ne.getAccount(a);
            return { address: c };
          }),
          caipNetwork: i,
        }));
    }
  }
  onAccountsChanged(e, t, n = !0) {
    var r, i;
    if (e.length > 0) {
      const { address: o } = ne.getAccount(e[0]),
        a =
          (r = this.connectionManager) == null
            ? void 0
            : r.getConnection({
                connectorId: t,
                connections: this.connections,
                connectors: this.connectors,
              });
      o &&
        At.isLowerCaseMatch(this.getConnectorId(S.CHAIN.EVM), t) &&
        this.emit("accountChanged", {
          address: o,
          chainId:
            (i = a == null ? void 0 : a.caipNetwork) == null ? void 0 : i.id,
          connector: a == null ? void 0 : a.connector,
        }),
        this.addConnection({
          connectorId: t,
          accounts: e.map((c) => {
            const { address: l } = ne.getAccount(c);
            return { address: l };
          }),
          caipNetwork: a == null ? void 0 : a.caipNetwork,
        });
    } else n && this.onDisconnect(t);
  }
  onDisconnect(e) {
    this.removeProviderListeners(e),
      this.deleteConnection(e),
      At.isLowerCaseMatch(this.getConnectorId(S.CHAIN.EVM), e) &&
        this.emitFirstAvailableConnection(),
      this.connections.length === 0 && this.emit("disconnect");
  }
  onChainChanged(e, t) {
    var o;
    const n =
        typeof e == "string" && e.startsWith("0x")
          ? ca.hexStringToNumber(e).toString()
          : e.toString(),
      r =
        (o = this.connectionManager) == null
          ? void 0
          : o.getConnection({
              connectorId: t,
              connections: this.connections,
              connectors: this.connectors,
            }),
      i = this.getCaipNetworks()
        .filter((a) => a.chainNamespace === this.namespace)
        .find((a) => a.id.toString() === n);
    r &&
      this.addConnection({
        connectorId: t,
        accounts: r.accounts,
        caipNetwork: i,
      }),
      At.isLowerCaseMatch(this.getConnectorId(S.CHAIN.EVM), t) &&
        this.emit("switchNetwork", { chainId: n });
  }
  listenProviderEvents(e, t) {
    if (Ix.includes(e)) return;
    const n = (o) => this.onAccountsChanged(o, e),
      r = (o) => this.onChainChanged(o, e),
      i = () => this.onDisconnect(e);
    this.providerHandlers[e] ||
      (t.on("disconnect", i),
      t.on("accountsChanged", n),
      t.on("chainChanged", r),
      (this.providerHandlers[e] = {
        provider: t,
        disconnect: i,
        accountsChanged: n,
        chainChanged: r,
      }));
  }
  removeProviderListeners(e) {
    if (this.providerHandlers[e]) {
      const {
        provider: t,
        disconnect: n,
        accountsChanged: r,
        chainChanged: i,
      } = this.providerHandlers[e];
      t.removeListener("disconnect", n),
        t.removeListener("accountsChanged", r),
        t.removeListener("chainChanged", i),
        (this.providerHandlers[e] = null);
    }
  }
  emitFirstAvailableConnection() {
    var t, n;
    const e =
      (t = this.connectionManager) == null
        ? void 0
        : t.getConnection({
            connections: this.connections,
            connectors: this.connectors,
          });
    if (e) {
      const [r] = e.accounts;
      this.emit("accountChanged", {
        address: r == null ? void 0 : r.address,
        chainId: (n = e.caipNetwork) == null ? void 0 : n.id,
        connector: e.connector,
      });
    }
  }
}
class Nx extends Sx {
  async setUniversalProvider(e) {
    if (!this.namespace)
      throw new Error(
        "UniversalAdapter:setUniversalProvider - namespace is required"
      );
    return (
      this.addConnector(
        new Mg({
          provider: e,
          caipNetworks: this.getCaipNetworks(),
          namespace: this.namespace,
        })
      ),
      Promise.resolve()
    );
  }
  async connect(e) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(e.chainId),
      provider: this.provider,
      address: "",
    });
  }
  async disconnect() {
    try {
      await this.getWalletConnectConnector().disconnect(),
        this.emit("disconnect");
    } catch (e) {
      console.warn("UniversalAdapter:disconnect - error", e);
    }
    return { connections: [] };
  }
  syncConnections() {
    return Promise.resolve();
  }
  async getAccounts({ namespace: e }) {
    var r, i, o, a;
    const t = this.provider,
      n =
        ((a =
          (o =
            (i =
              (r = t == null ? void 0 : t.session) == null
                ? void 0
                : r.namespaces) == null
              ? void 0
              : i[e]) == null
            ? void 0
            : o.accounts) == null
          ? void 0
          : a
              .map((c) => {
                const [, , l] = c.split(":");
                return l;
              })
              .filter((c, l, d) => d.indexOf(c) === l)) || [];
    return Promise.resolve({
      accounts: n.map((c) =>
        ne.createAccount(e, c, e === "bip122" ? "payment" : "eoa")
      ),
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(e) {
    var i, o, a, c, l;
    if (
      !(
        e.caipNetwork &&
        Pe.BALANCE_SUPPORTED_CHAINS.includes(
          (i = e.caipNetwork) == null ? void 0 : i.chainNamespace
        )
      ) ||
      ((o = e.caipNetwork) != null && o.testnet)
    )
      return {
        balance: "0.00",
        symbol:
          ((a = e.caipNetwork) == null ? void 0 : a.nativeCurrency.symbol) ||
          "",
      };
    if (
      se.state.balanceLoading &&
      e.chainId === ((c = y.state.activeCaipNetwork) == null ? void 0 : c.id)
    )
      return {
        balance: se.state.balance || "0.00",
        symbol: se.state.balanceSymbol || "",
      };
    const r = (await se.fetchTokenBalance()).find((d) => {
      var u, p;
      return (
        d.chainId ===
          `${(u = e.caipNetwork) == null ? void 0 : u.chainNamespace}:${
            e.chainId
          }` &&
        d.symbol ===
          ((p = e.caipNetwork) == null ? void 0 : p.nativeCurrency.symbol)
      );
    });
    return {
      balance: (r == null ? void 0 : r.quantity.numeric) || "0.00",
      symbol:
        (r == null ? void 0 : r.symbol) ||
        ((l = e.caipNetwork) == null ? void 0 : l.nativeCurrency.symbol) ||
        "",
    };
  }
  async signMessage(e) {
    var o, a, c;
    const { provider: t, message: n, address: r } = e;
    if (!t)
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    let i = "";
    return (
      ((o = y.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace) ===
      S.CHAIN.SOLANA
        ? (i = (
            await t.request(
              {
                method: "solana_signMessage",
                params: {
                  message: ei.encode(new TextEncoder().encode(n)),
                  pubkey: r,
                },
              },
              (a = y.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId
            )
          ).signature)
        : (i = await t.request(
            { method: "personal_sign", params: [n, r] },
            (c = y.state.activeCaipNetwork) == null ? void 0 : c.caipNetworkId
          )),
      { signature: i }
    );
  }
  async estimateGas() {
    return Promise.resolve({ gas: BigInt(0) });
  }
  async sendTransaction() {
    return Promise.resolve({ hash: "" });
  }
  walletGetAssets(e) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({ hash: "" });
  }
  emitFirstAvailableConnection() {}
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: "",
    });
  }
  async switchNetwork(e) {
    var r, i, o, a, c, l;
    const { caipNetwork: t } = e,
      n = this.getWalletConnectConnector();
    if (t.chainNamespace === S.CHAIN.EVM)
      try {
        await ((r = n.provider) == null
          ? void 0
          : r.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: bd(t.id) }],
            }));
      } catch (d) {
        if (
          d.code === Br.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
          d.code === Br.ERROR_INVALID_CHAIN_ID ||
          d.code === Br.ERROR_CODE_DEFAULT ||
          ((o =
            (i = d == null ? void 0 : d.data) == null
              ? void 0
              : i.originalError) == null
            ? void 0
            : o.code) === Br.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
        )
          try {
            await ((l = n.provider) == null
              ? void 0
              : l.request({
                  method: "wallet_addEthereumChain",
                  params: [
                    {
                      chainId: bd(t.id),
                      rpcUrls: [
                        (a = t == null ? void 0 : t.rpcUrls.chainDefault) ==
                        null
                          ? void 0
                          : a.http,
                      ],
                      chainName: t.name,
                      nativeCurrency: t.nativeCurrency,
                      blockExplorerUrls: [
                        (c = t.blockExplorers) == null ? void 0 : c.default.url,
                      ],
                    },
                  ],
                }));
          } catch {
            throw new Error("Chain is not supported");
          }
      }
    n.provider.setDefaultChain(t.caipNetworkId);
  }
  getWalletConnectProvider() {
    const e = this.connectors.find((n) => n.type === "WALLET_CONNECT");
    return e == null ? void 0 : e.provider;
  }
}
const Tx = [
    "email",
    "socials",
    "swaps",
    "onramp",
    "activity",
    "reownBranding",
    "multiWallet",
  ],
  Xo = {
    email: {
      apiFeatureName: "social_login",
      localFeatureName: "email",
      returnType: !1,
      isLegacy: !1,
      isAvailableOnBasic: !1,
      processApi: (s) => {
        if (!(s != null && s.config)) return !1;
        const e = s.config;
        return !!s.isEnabled && e.includes("email");
      },
      processFallback: (s) =>
        s === void 0 ? Pe.DEFAULT_REMOTE_FEATURES.email : !!s,
    },
    socials: {
      apiFeatureName: "social_login",
      localFeatureName: "socials",
      returnType: !1,
      isLegacy: !1,
      isAvailableOnBasic: !1,
      processApi: (s) => {
        if (!(s != null && s.config)) return !1;
        const e = s.config;
        return s.isEnabled && e.length > 0
          ? e.filter((t) => t !== "email")
          : !1;
      },
      processFallback: (s) =>
        s === void 0
          ? Pe.DEFAULT_REMOTE_FEATURES.socials
          : typeof s == "boolean"
          ? s
            ? Pe.DEFAULT_REMOTE_FEATURES.socials
            : !1
          : s,
    },
    swaps: {
      apiFeatureName: "swap",
      localFeatureName: "swaps",
      returnType: !1,
      isLegacy: !1,
      isAvailableOnBasic: !1,
      processApi: (s) => {
        if (!(s != null && s.config)) return !1;
        const e = s.config;
        return s.isEnabled && e.length > 0 ? e : !1;
      },
      processFallback: (s) =>
        s === void 0
          ? Pe.DEFAULT_REMOTE_FEATURES.swaps
          : typeof s == "boolean"
          ? s
            ? Pe.DEFAULT_REMOTE_FEATURES.swaps
            : !1
          : s,
    },
    onramp: {
      apiFeatureName: "onramp",
      localFeatureName: "onramp",
      returnType: !1,
      isLegacy: !1,
      isAvailableOnBasic: !1,
      processApi: (s) => {
        if (!(s != null && s.config)) return !1;
        const e = s.config;
        return s.isEnabled && e.length > 0 ? e : !1;
      },
      processFallback: (s) =>
        s === void 0
          ? Pe.DEFAULT_REMOTE_FEATURES.onramp
          : typeof s == "boolean"
          ? s
            ? Pe.DEFAULT_REMOTE_FEATURES.onramp
            : !1
          : s,
    },
    activity: {
      apiFeatureName: "activity",
      localFeatureName: "history",
      returnType: !1,
      isLegacy: !0,
      isAvailableOnBasic: !1,
      processApi: (s) => !!s.isEnabled,
      processFallback: (s) =>
        s === void 0 ? Pe.DEFAULT_REMOTE_FEATURES.activity : !!s,
    },
    reownBranding: {
      apiFeatureName: "reown_branding",
      localFeatureName: "reownBranding",
      returnType: !1,
      isLegacy: !1,
      isAvailableOnBasic: !1,
      processApi: (s) => !!s.isEnabled,
      processFallback: (s) =>
        s === void 0 ? Pe.DEFAULT_REMOTE_FEATURES.reownBranding : !!s,
    },
    multiWallet: {
      apiFeatureName: "multi_wallet",
      localFeatureName: "multiWallet",
      returnType: !1,
      isLegacy: !1,
      isAvailableOnBasic: !1,
      processApi: (s) => !!s.isEnabled,
      processFallback: () => Pe.DEFAULT_REMOTE_FEATURES.multiWallet,
    },
  },
  Rx = {
    localSettingsOverridden: new Set(),
    getApiConfig(s, e) {
      return e == null ? void 0 : e.find((t) => t.id === s);
    },
    addWarning(s, e) {
      if (s !== void 0) {
        const t = Xo[e],
          n = t.isLegacy
            ? `"features.${t.localFeatureName}" (now "${e}")`
            : `"features.${e}"`;
        this.localSettingsOverridden.add(n);
      }
    },
    processFeature(s, e, t, n, r) {
      const i = Xo[s],
        o = e[i.localFeatureName];
      if (r && !i.isAvailableOnBasic) return !1;
      if (n) {
        const a = this.getApiConfig(i.apiFeatureName, t);
        return (a == null ? void 0 : a.config) === null
          ? this.processFallbackFeature(s, o)
          : a != null && a.config
          ? (o !== void 0 && this.addWarning(o, s),
            this.processApiFeature(s, a))
          : !1;
      }
      return this.processFallbackFeature(s, o);
    },
    processApiFeature(s, e) {
      return Xo[s].processApi(e);
    },
    processFallbackFeature(s, e) {
      return Xo[s].processFallback(e);
    },
    async fetchRemoteFeatures(s) {
      const e = s.basic ?? !1,
        t = s.features || {};
      this.localSettingsOverridden.clear();
      let n = null,
        r = !1;
      try {
        (n = await re.fetchProjectConfig()), (r = n != null);
      } catch (o) {
        console.warn(
          "[Reown Config] Failed to fetch remote project configuration. Using local/default values.",
          o
        );
      }
      const i =
        r && !e
          ? Pe.DEFAULT_REMOTE_FEATURES
          : Pe.DEFAULT_REMOTE_FEATURES_DISABLED;
      try {
        for (const o of Tx) {
          const a = this.processFeature(o, t, n, r, e);
          Object.assign(i, { [o]: a });
        }
      } catch (o) {
        return (
          console.warn(
            "[Reown Config] Failed to process the configuration from Cloud. Using default values.",
            o
          ),
          Pe.DEFAULT_REMOTE_FEATURES
        );
      }
      if (r && this.localSettingsOverridden.size > 0) {
        const o = `Your local configuration for ${Array.from(
          this.localSettingsOverridden
        ).join(
          ", "
        )} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
        tt.open(
          {
            shortMessage: "Local configuration ignored",
            longMessage: `[Reown Config Notice] ${o}`,
          },
          "warning"
        );
      }
      return i;
    },
  };
class xx {
  constructor(e) {
    (this.chainNamespaces = []),
      (this.remoteFeatures = {}),
      (this.reportedAlertErrors = {}),
      (this.getCaipNetwork = (t, n) => {
        var r, i, o, a;
        if (t) {
          const c =
            (i =
              (r = y.getNetworkData(t)) == null
                ? void 0
                : r.requestedCaipNetworks) == null
              ? void 0
              : i.find((u) => u.id === n);
          if (c) return c;
          const l = (o = y.getNetworkData(t)) == null ? void 0 : o.caipNetwork;
          return (
            l ||
            ((a = y
              .getRequestedCaipNetworks(t)
              .filter((u) => u.chainNamespace === t)) == null
              ? void 0
              : a[0])
          );
        }
        return y.state.activeCaipNetwork || this.defaultCaipNetwork;
      }),
      (this.getCaipNetworkId = () => {
        const t = this.getCaipNetwork();
        if (t) return t.id;
      }),
      (this.getCaipNetworks = (t) => y.getCaipNetworks(t)),
      (this.getActiveChainNamespace = () => y.state.activeChain),
      (this.setRequestedCaipNetworks = (t, n) => {
        y.setRequestedCaipNetworks(t, n);
      }),
      (this.getApprovedCaipNetworkIds = () => y.getAllApprovedCaipNetworkIds()),
      (this.getCaipAddress = (t) =>
        y.state.activeChain === t || !t
          ? y.state.activeCaipAddress
          : y.getAccountProp("caipAddress", t)),
      (this.setClientId = (t) => {
        ae.setClientId(t);
      }),
      (this.getProvider = (t) => Le.getProvider(t)),
      (this.getProviderType = (t) => Le.getProviderId(t)),
      (this.getPreferredAccountType = (t) => Cs(t)),
      (this.setCaipAddress = (t, n) => {
        se.setCaipAddress(t, n);
      }),
      (this.setBalance = (t, n, r) => {
        se.setBalance(t, n, r);
      }),
      (this.setProfileName = (t, n) => {
        se.setProfileName(t, n);
      }),
      (this.setProfileImage = (t, n) => {
        se.setProfileImage(t, n);
      }),
      (this.setUser = (t, n) => {
        se.setUser(t, n);
      }),
      (this.resetAccount = (t) => {
        se.resetAccount(t);
      }),
      (this.setCaipNetwork = (t) => {
        y.setActiveCaipNetwork(t);
      }),
      (this.setCaipNetworkOfNamespace = (t, n) => {
        y.setChainNetworkData(n, { caipNetwork: t });
      }),
      (this.setStatus = (t, n) => {
        se.setStatus(t, n),
          q.isConnected()
            ? M.setConnectionStatus("connected")
            : M.setConnectionStatus("disconnected");
      }),
      (this.getAddressByChainNamespace = (t) => y.getAccountProp("address", t)),
      (this.setConnectors = (t) => {
        const n = [...q.state.allConnectors, ...t];
        q.setConnectors(n);
      }),
      (this.setConnections = (t, n) => {
        M.setConnections(t, n), H.setConnections(t, n);
      }),
      (this.fetchIdentity = (t) => ae.fetchIdentity(t)),
      (this.getReownName = (t) => Di.getNamesForAddress(t)),
      (this.getConnectors = () => q.getConnectors()),
      (this.getConnectorImage = (t) => lp.getConnectorImage(t)),
      (this.getConnections = (t) =>
        this.remoteFeatures.multiWallet
          ? da.getConnectionsData(t).connections
          : (tt.open(
              S.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
              "info"
            ),
            [])),
      (this.getRecentConnections = (t) =>
        this.remoteFeatures.multiWallet
          ? da.getConnectionsData(t).recentConnections
          : (tt.open(
              S.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
              "info"
            ),
            [])),
      (this.switchConnection = async (t) => {
        if (!this.remoteFeatures.multiWallet) {
          tt.open(
            S.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
            "info"
          );
          return;
        }
        await H.switchConnection(t);
      }),
      (this.deleteConnection = (t) => {
        if (!this.remoteFeatures.multiWallet) {
          tt.open(
            S.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
            "info"
          );
          return;
        }
        M.deleteAddressFromConnection(t), H.syncStorageConnections();
      }),
      (this.setConnectedWalletInfo = (t, n) => {
        const r = Le.getProviderId(n),
          i = t ? { ...t, type: r } : void 0;
        se.setConnectedWalletInfo(i, n);
      }),
      (this.getIsConnectedState = () => !!y.state.activeCaipAddress),
      (this.addAddressLabel = (t, n, r) => {
        se.addAddressLabel(t, n, r);
      }),
      (this.removeAddressLabel = (t, n) => {
        se.removeAddressLabel(t, n);
      }),
      (this.getAddress = (t) =>
        y.state.activeChain === t || !t
          ? se.state.address
          : y.getAccountProp("address", t)),
      (this.setApprovedCaipNetworksData = (t) =>
        y.setApprovedCaipNetworksData(t)),
      (this.resetNetwork = (t) => {
        y.resetNetwork(t);
      }),
      (this.addConnector = (t) => {
        q.addConnector(t);
      }),
      (this.resetWcConnection = () => {
        H.resetWcConnection();
      }),
      (this.setAddressExplorerUrl = (t, n) => {
        se.setAddressExplorerUrl(t, n);
      }),
      (this.setSmartAccountDeployed = (t, n) => {
        se.setSmartAccountDeployed(t, n);
      }),
      (this.setPreferredAccountType = (t, n) => {
        y.setAccountProp("preferredAccountType", t, n);
      }),
      (this.setEIP6963Enabled = (t) => {
        R.setEIP6963Enabled(t);
      }),
      (this.handleUnsafeRPCRequest = () => {
        if (this.isOpen()) {
          if (this.isTransactionStackEmpty()) return;
          this.redirect("ApproveTransaction");
        } else this.open({ view: "ApproveTransaction" });
      }),
      (this.options = e),
      (this.version = e.sdkVersion),
      (this.caipNetworks = this.extendCaipNetworks(e)),
      (this.chainNamespaces = this.getChainNamespacesSet(
        e.adapters,
        this.caipNetworks
      )),
      (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
      (this.chainAdapters = this.createAdapters(e.adapters)),
      (this.readyPromise = this.initialize(e));
  }
  getChainNamespacesSet(e, t) {
    const n = e == null ? void 0 : e.map((i) => i.namespace).filter((i) => !!i);
    if (n != null && n.length) return [...new Set(n)];
    const r = t == null ? void 0 : t.map((i) => i.chainNamespace);
    return [...new Set(r)];
  }
  async initialize(e) {
    var t, n, r;
    this.initializeProjectSettings(e),
      this.initControllers(e),
      await this.initChainAdapters(),
      this.sendInitializeEvent(e),
      R.state.enableReconnect
        ? (await this.syncExistingConnection(),
          await this.syncAdapterConnections())
        : await this.unSyncExistingConnection(),
      (this.remoteFeatures = await Rx.fetchRemoteFeatures(e)),
      R.setRemoteFeatures(this.remoteFeatures),
      this.remoteFeatures.onramp &&
        Vc.setOnrampProviders(this.remoteFeatures.onramp),
      (((t = R.state.remoteFeatures) != null && t.email) ||
        (Array.isArray(
          (n = R.state.remoteFeatures) == null ? void 0 : n.socials
        ) &&
          ((r = R.state.remoteFeatures) == null ? void 0 : r.socials.length) >
            0)) &&
        (await this.checkAllowedOrigins());
  }
  async checkAllowedOrigins() {
    try {
      const e = await re.fetchAllowedOrigins();
      if (!e || !ne.isClient()) {
        tt.open(vt.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
        return;
      }
      const t = window.location.origin;
      Ls.isOriginAllowed(t, e, Br.DEFAULT_ALLOWED_ANCESTORS) ||
        tt.open(vt.ALERT_ERRORS.INVALID_APP_CONFIGURATION, "error");
    } catch (e) {
      if (!(e instanceof Error)) {
        tt.open(vt.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
        return;
      }
      switch (e.message) {
        case "RATE_LIMITED":
          tt.open(vt.ALERT_ERRORS.RATE_LIMITED_APP_CONFIGURATION, "error");
          break;
        case "SERVER_ERROR": {
          const t = e.cause instanceof Error ? e.cause : e;
          tt.open(
            {
              shortMessage:
                vt.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.shortMessage,
              longMessage:
                vt.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.longMessage(
                  t.message
                ),
            },
            "error"
          );
          break;
        }
        default:
          tt.open(vt.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      }
    }
  }
  sendInitializeEvent(e) {
    var n;
    const { ...t } = e;
    delete t.adapters,
      delete t.universalProvider,
      Ue.sendEvent({
        type: "track",
        event: "INITIALIZE",
        properties: {
          ...t,
          networks: e.networks.map((r) => r.id),
          siweConfig: {
            options: ((n = e.siweConfig) == null ? void 0 : n.options) || {},
          },
        },
      });
  }
  initControllers(e) {
    this.initializeOptionsController(e),
      this.initializeChainController(e),
      this.initializeThemeController(e),
      this.initializeConnectionController(e),
      this.initializeConnectorController();
  }
  initializeThemeController(e) {
    e.themeMode && $t.setThemeMode(e.themeMode),
      e.themeVariables && $t.setThemeVariables(e.themeVariables);
  }
  initializeChainController(e) {
    if (!this.connectionControllerClient || !this.networkControllerClient)
      throw new Error(
        "ConnectionControllerClient and NetworkControllerClient must be set"
      );
    y.initialize(e.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient,
    });
    const t = this.getDefaultNetwork();
    t && y.setActiveCaipNetwork(t);
  }
  initializeConnectionController(e) {
    H.initialize(e.adapters ?? []), H.setWcBasic(e.basic ?? !1);
  }
  initializeConnectorController() {
    q.initialize(this.chainNamespaces);
  }
  initializeProjectSettings(e) {
    R.setProjectId(e.projectId), R.setSdkVersion(e.sdkVersion);
  }
  initializeOptionsController(e) {
    var r;
    R.setDebug(e.debug !== !1),
      R.setEnableWalletConnect(e.enableWalletConnect !== !1),
      R.setEnableWalletGuide(e.enableWalletGuide !== !1),
      R.setEnableWallets(e.enableWallets !== !1),
      R.setEIP6963Enabled(e.enableEIP6963 !== !1),
      R.setEnableNetworkSwitch(e.enableNetworkSwitch !== !1),
      R.setEnableReconnect(e.enableReconnect !== !1),
      R.setEnableAuthLogger(e.enableAuthLogger !== !1),
      R.setCustomRpcUrls(e.customRpcUrls),
      R.setEnableEmbedded(e.enableEmbedded),
      R.setAllWallets(e.allWallets),
      R.setIncludeWalletIds(e.includeWalletIds),
      R.setExcludeWalletIds(e.excludeWalletIds),
      R.setFeaturedWalletIds(e.featuredWalletIds),
      R.setTokens(e.tokens),
      R.setTermsConditionsUrl(e.termsConditionsUrl),
      R.setPrivacyPolicyUrl(e.privacyPolicyUrl),
      R.setCustomWallets(e.customWallets),
      R.setFeatures(e.features),
      R.setAllowUnsupportedChain(e.allowUnsupportedChain),
      R.setUniversalProviderConfigOverride(e.universalProviderConfigOverride),
      R.setPreferUniversalLinks(e.experimental_preferUniversalLinks),
      R.setDefaultAccountTypes(e.defaultAccountTypes);
    const t = this.getDefaultMetaData();
    if (
      (!e.metadata && t && (e.metadata = t),
      R.setMetadata(e.metadata),
      R.setDisableAppend(e.disableAppend),
      R.setEnableEmbedded(e.enableEmbedded),
      R.setSIWX(e.siwx),
      !e.projectId)
    ) {
      tt.open(vt.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    if (
      ((r = e.adapters) == null
        ? void 0
        : r.find((i) => i.namespace === S.CHAIN.EVM)) &&
      e.siweConfig
    ) {
      if (e.siwx)
        throw new Error("Cannot set both `siweConfig` and `siwx` options");
      R.setSIWX(e.siweConfig.mapToSIWX());
    }
  }
  getDefaultMetaData() {
    var e, t, n, r;
    return ne.isClient()
      ? {
          name:
            ((t =
              (e = document.getElementsByTagName("title")) == null
                ? void 0
                : e[0]) == null
              ? void 0
              : t.textContent) || "",
          description:
            ((n = document.querySelector('meta[property="og:description"]')) ==
            null
              ? void 0
              : n.content) || "",
          url: window.location.origin,
          icons: [
            ((r = document.querySelector('link[rel~="icon"]')) == null
              ? void 0
              : r.href) || "",
          ],
        }
      : null;
  }
  setUnsupportedNetwork(e) {
    const t = this.getActiveChainNamespace();
    if (t) {
      const n = kr.getUnsupportedNetwork(`${t}:${e}`);
      y.setActiveCaipNetwork(n);
    }
  }
  getDefaultNetwork() {
    return kr.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(e, t) {
    return kr.extendCaipNetwork(e, {
      customNetworkImageUrls: t.chainImages,
      projectId: t.projectId,
    });
  }
  extendCaipNetworks(e) {
    return kr.extendCaipNetworks(e.networks, {
      customNetworkImageUrls: e.chainImages,
      customRpcUrls: e.customRpcUrls,
      projectId: e.projectId,
    });
  }
  extendDefaultCaipNetwork(e) {
    const t = e.networks.find((r) => {
      var i;
      return r.id === ((i = e.defaultNetwork) == null ? void 0 : i.id);
    });
    return t
      ? kr.extendCaipNetwork(t, {
          customNetworkImageUrls: e.chainImages,
          customRpcUrls: e.customRpcUrls,
          projectId: e.projectId,
        })
      : void 0;
  }
  async disconnectNamespace(e, t) {
    try {
      this.setLoading(!0, e);
      let n = { connections: [] };
      const r = this.getAdapter(e),
        { caipAddress: i } = y.getAccountData(e) || {};
      return (
        (i || !R.state.enableReconnect) &&
          r != null &&
          r.disconnect &&
          (n = await r.disconnect({ id: t })),
        this.setLoading(!1, e),
        n
      );
    } catch (n) {
      throw (
        (this.setLoading(!1, e),
        new Error(`Failed to disconnect chains: ${n.message}`))
      );
    }
  }
  createClients() {
    (this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var l;
        const e = y.state.activeChain,
          t = this.getAdapter(e),
          n = (l = this.getCaipNetwork(e)) == null ? void 0 : l.id,
          r = H.getConnections(e),
          i = this.remoteFeatures.multiWallet,
          o = r.length > 0;
        if (!t) throw new Error("Adapter not found");
        const a = await t.connectWalletConnect(n);
        (!o || !i) && this.close(),
          this.setClientId((a == null ? void 0 : a.clientId) || null),
          M.setConnectedNamespaces([...y.state.chains.keys()]),
          await this.syncWalletConnectAccount(),
          await ms.initializeIfEnabled();
      },
      connectExternal: async ({
        id: e,
        address: t,
        info: n,
        type: r,
        provider: i,
        chain: o,
        caipNetwork: a,
        socialUri: c,
      }) => {
        var g, m, f, E, b, _;
        const l = y.state.activeChain,
          d = o || l,
          u = this.getAdapter(d);
        if (o && o !== l && !a) {
          const N = this.getCaipNetworks().find((A) => A.chainNamespace === o);
          N && this.setCaipNetwork(N);
        }
        if (!d) throw new Error("connectExternal: namespace not found");
        if (!u) throw new Error("connectExternal: adapter not found");
        const p = this.getCaipNetwork(d),
          w = await u.connect({
            id: e,
            address: t,
            info: n,
            type: r,
            provider: i,
            socialUri: c,
            chainId: (a == null ? void 0 : a.id) || (p == null ? void 0 : p.id),
            rpcUrl:
              ((f =
                (m =
                  (g = a == null ? void 0 : a.rpcUrls) == null
                    ? void 0
                    : g.default) == null
                  ? void 0
                  : m.http) == null
                ? void 0
                : f[0]) ||
              ((_ =
                (b =
                  (E = p == null ? void 0 : p.rpcUrls) == null
                    ? void 0
                    : E.default) == null
                  ? void 0
                  : b.http) == null
                ? void 0
                : _[0]),
          });
        if (w)
          return (
            M.addConnectedNamespace(d),
            this.syncProvider({ ...w, chainNamespace: d }),
            this.setStatus("connected", d),
            this.syncConnectedWalletInfo(d),
            M.removeDisconnectedConnectorId(e, d),
            { address: w.address }
          );
      },
      reconnectExternal: async ({ id: e, info: t, type: n, provider: r }) => {
        var a;
        const i = y.state.activeChain,
          o = this.getAdapter(i);
        if (!i) throw new Error("reconnectExternal: namespace not found");
        if (!o) throw new Error("reconnectExternal: adapter not found");
        o != null &&
          o.reconnect &&
          (await (o == null
            ? void 0
            : o.reconnect({
                id: e,
                info: t,
                type: n,
                provider: r,
                chainId: (a = this.getCaipNetwork()) == null ? void 0 : a.id,
              })),
          M.addConnectedNamespace(i),
          this.syncConnectedWalletInfo(i));
      },
      disconnect: async (e) => {
        var d;
        const { id: t, chainNamespace: n, initialDisconnect: r } = e || {},
          i = n || y.state.activeChain,
          o = Array.from(y.state.chains.keys()),
          a = q.getConnectorId(i),
          c = t === S.CONNECTOR_ID.AUTH || a === S.CONNECTOR_ID.AUTH,
          l =
            t === S.CONNECTOR_ID.WALLET_CONNECT ||
            a === S.CONNECTOR_ID.WALLET_CONNECT;
        try {
          let u = n ? [n] : o;
          (l || c) && (u = o);
          const p = u.map(async (m) => {
              let f = t;
              (l || c) && !t && (f = a),
                r &&
                  c &&
                  (M.deleteConnectedSocialProvider(),
                  u.forEach((b) => {
                    M.addDisconnectedConnectorId(f || "", b);
                  }));
              const E = await this.disconnectNamespace(m, f);
              E &&
                E.connections.forEach((b) => {
                  b.connectorId === S.CONNECTOR_ID.AUTH &&
                    M.deleteConnectedSocialProvider(),
                    M.addDisconnectedConnectorId(b.connectorId, m);
                }),
                r &&
                  this.onDisconnectNamespace({
                    chainNamespace: m,
                    closeModal: !1,
                  });
            }),
            w = await Promise.allSettled(p);
          xe.resetSend(),
            H.resetWcConnection(),
            (d = ms.getSIWX()) != null &&
              d.signOutOnDisconnect &&
              (await ms.clearSessions()),
            q.setFilterByNamespace(void 0),
            H.syncStorageConnections();
          const g = w.filter((m) => m.status === "rejected");
          if (g.length > 0)
            throw new Error(g.map((m) => m.reason.message).join(", "));
          Ue.sendEvent({
            type: "track",
            event: "DISCONNECT_SUCCESS",
            properties: { namespace: n || "all" },
          });
        } catch (u) {
          throw new Error(`Failed to disconnect chains: ${u.message}`);
        }
      },
      checkInstalled: (e) =>
        e
          ? e.some((t) => {
              var n;
              return !!((n = window.ethereum) != null && n[String(t)]);
            })
          : !!window.ethereum,
      signMessage: async (e) => {
        const t = y.state.activeChain,
          n = this.getAdapter(y.state.activeChain);
        if (!t) throw new Error("signMessage: namespace not found");
        if (!n) throw new Error("signMessage: adapter not found");
        const r = await (n == null
          ? void 0
          : n.signMessage({
              message: e,
              address: se.state.address,
              provider: Le.getProvider(t),
            }));
        return (r == null ? void 0 : r.signature) || "";
      },
      sendTransaction: async (e) => {
        const t = e.chainNamespace;
        if (!t) throw new Error("sendTransaction: namespace not found");
        if (Pe.SEND_SUPPORTED_NAMESPACES.includes(t)) {
          const n = this.getAdapter(t);
          if (!n) throw new Error("sendTransaction: adapter not found");
          const r = Le.getProvider(t),
            i = await (n == null
              ? void 0
              : n.sendTransaction({
                  ...e,
                  caipNetwork: this.getCaipNetwork(),
                  provider: r,
                }));
          return (i == null ? void 0 : i.hash) || "";
        }
        return "";
      },
      estimateGas: async (e) => {
        const t = e.chainNamespace;
        if (t === S.CHAIN.EVM) {
          const n = this.getAdapter(t);
          if (!n)
            throw new Error(
              "estimateGas: adapter is required but got undefined"
            );
          const r = Le.getProvider(t),
            i = this.getCaipNetwork();
          if (!i)
            throw new Error(
              "estimateGas: caipNetwork is required but got undefined"
            );
          const o = await (n == null
            ? void 0
            : n.estimateGas({ ...e, provider: r, caipNetwork: i }));
          return (o == null ? void 0 : o.gas) || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        var t;
        const e = y.state.activeChain;
        if (!e)
          throw new Error(
            "getEnsAvatar: namespace is required but got undefined"
          );
        return (
          await this.syncIdentity({
            address: se.state.address,
            chainId: Number(
              (t = this.getCaipNetwork()) == null ? void 0 : t.id
            ),
            chainNamespace: e,
          }),
          se.state.profileImage || !1
        );
      },
      getEnsAddress: async (e) => await Ls.resolveReownName(e),
      writeContract: async (e) => {
        const t = y.state.activeChain,
          n = this.getAdapter(t);
        if (!t)
          throw new Error(
            "writeContract: namespace is required but got undefined"
          );
        if (!n)
          throw new Error(
            "writeContract: adapter is required but got undefined"
          );
        const r = this.getCaipNetwork(),
          i = this.getCaipAddress(),
          o = Le.getProvider(t);
        if (!r || !i)
          throw new Error(
            "writeContract: caipNetwork or caipAddress is required but got undefined"
          );
        const a = await (n == null
          ? void 0
          : n.writeContract({
              ...e,
              caipNetwork: r,
              provider: o,
              caipAddress: i,
            }));
        return a == null ? void 0 : a.hash;
      },
      parseUnits: (e, t) => {
        const n = this.getAdapter(y.state.activeChain);
        if (!n)
          throw new Error("parseUnits: adapter is required but got undefined");
        return (
          (n == null ? void 0 : n.parseUnits({ value: e, decimals: t })) ?? 0n
        );
      },
      formatUnits: (e, t) => {
        const n = this.getAdapter(y.state.activeChain);
        if (!n)
          throw new Error("formatUnits: adapter is required but got undefined");
        return (
          (n == null ? void 0 : n.formatUnits({ value: e, decimals: t })) ?? "0"
        );
      },
      getCapabilities: async (e) => {
        const t = this.getAdapter(y.state.activeChain);
        if (!t)
          throw new Error(
            "getCapabilities: adapter is required but got undefined"
          );
        return await (t == null ? void 0 : t.getCapabilities(e));
      },
      grantPermissions: async (e) => {
        const t = this.getAdapter(y.state.activeChain);
        if (!t)
          throw new Error(
            "grantPermissions: adapter is required but got undefined"
          );
        return await (t == null ? void 0 : t.grantPermissions(e));
      },
      revokePermissions: async (e) => {
        const t = this.getAdapter(y.state.activeChain);
        if (!t)
          throw new Error(
            "revokePermissions: adapter is required but got undefined"
          );
        return t != null && t.revokePermissions
          ? await t.revokePermissions(e)
          : "0x";
      },
      walletGetAssets: async (e) => {
        const t = this.getAdapter(y.state.activeChain);
        if (!t)
          throw new Error(
            "walletGetAssets: adapter is required but got undefined"
          );
        return (await (t == null ? void 0 : t.walletGetAssets(e))) ?? {};
      },
      updateBalance: (e) => {
        const t = this.getCaipNetwork(e);
        !t ||
          !se.state.address ||
          this.updateNativeBalance(
            se.state.address,
            t == null ? void 0 : t.id,
            e
          );
      },
    }),
      (this.networkControllerClient = {
        switchCaipNetwork: async (e) => await this.switchCaipNetwork(e),
        getApprovedCaipNetworksData: async () =>
          this.getApprovedCaipNetworksData(),
      }),
      H.setClient(this.connectionControllerClient);
  }
  getApprovedCaipNetworksData() {
    var t, n, r, i, o;
    if (
      Le.getProviderId(y.state.activeChain) === zt.CONNECTOR_TYPE_WALLET_CONNECT
    ) {
      const a =
        (n = (t = this.universalProvider) == null ? void 0 : t.session) == null
          ? void 0
          : n.namespaces;
      return {
        supportsAllNetworks:
          ((o =
            (i = (r = this.universalProvider) == null ? void 0 : r.session) ==
            null
              ? void 0
              : i.peer) == null
            ? void 0
            : o.metadata.name) === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(a),
      };
    }
    return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(e) {
    if (!e) return;
    const t = e.chainNamespace;
    if (this.getAddressByChainNamespace(e.chainNamespace)) {
      const r = Le.getProvider(t),
        i = Le.getProviderId(t);
      if (e.chainNamespace === y.state.activeChain) {
        const o = this.getAdapter(t);
        await (o == null
          ? void 0
          : o.switchNetwork({ caipNetwork: e, provider: r, providerType: i }));
      } else if (
        (this.setCaipNetwork(e), i === zt.CONNECTOR_TYPE_WALLET_CONNECT)
      )
        this.syncWalletConnectAccount();
      else {
        const o = this.getAddressByChainNamespace(t);
        o && this.syncAccount({ address: o, chainId: e.id, chainNamespace: t });
      }
    } else this.setCaipNetwork(e);
  }
  getChainsFromNamespaces(e = {}) {
    return Object.values(e).flatMap((t) => {
      const n = t.chains || [],
        r = t.accounts.map((i) => {
          const { chainId: o, chainNamespace: a } = Mt.parseCaipAddress(i);
          return `${a}:${o}`;
        });
      return Array.from(new Set([...n, ...r]));
    });
  }
  createAdapters(e) {
    return (
      this.createClients(),
      this.chainNamespaces.reduce((t, n) => {
        var i;
        const r = e == null ? void 0 : e.find((o) => o.namespace === n);
        return (
          r
            ? (r.construct({
                namespace: n,
                projectId: (i = this.options) == null ? void 0 : i.projectId,
                networks: this.getCaipNetworks(),
              }),
              (t[n] = r))
            : (t[n] = new Nx({
                namespace: n,
                networks: this.getCaipNetworks(),
              })),
          t
        );
      }, {})
    );
  }
  async initChainAdapter(e) {
    var t;
    this.onConnectors(e),
      this.listenAdapter(e),
      await ((t = this.chainAdapters) == null
        ? void 0
        : t[e].syncConnectors(this.options, this)),
      await this.createUniversalProviderForAdapter(e);
  }
  async initChainAdapters() {
    await Promise.all(
      this.chainNamespaces.map(async (e) => {
        await this.initChainAdapter(e);
      })
    );
  }
  onConnectors(e) {
    const t = this.getAdapter(e);
    t == null || t.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(e) {
    const t = this.getAdapter(e);
    if (!t) return;
    const n = M.getConnectionStatus();
    R.state.enableReconnect === !1
      ? this.setStatus("disconnected", e)
      : n === "connected"
      ? this.setStatus("connecting", e)
      : n === "disconnected"
      ? (M.clearAddressCache(), this.setStatus(n, e))
      : this.setStatus(n, e),
      t.on("switchNetwork", ({ address: r, chainId: i }) => {
        const o = this.getCaipNetworks().find(
            (l) =>
              l.id.toString() === i.toString() ||
              l.caipNetworkId.toString() === i.toString()
          ),
          a = y.state.activeChain === e,
          c = y.getAccountProp("address", e);
        if (o) {
          const l = a && r ? r : c;
          l &&
            this.syncAccount({ address: l, chainId: o.id, chainNamespace: e });
        } else this.setUnsupportedNetwork(i);
      }),
      t.on("disconnect", () => {
        this.onDisconnectNamespace({ chainNamespace: e });
      }),
      t.on("connections", (r) => {
        this.setConnections(r, e);
      }),
      t.on("pendingTransactions", () => {
        const r = se.state.address,
          i = y.state.activeCaipNetwork;
        !r ||
          !(i != null && i.id) ||
          this.updateNativeBalance(r, i.id, i.chainNamespace);
      }),
      t.on("accountChanged", ({ address: r, chainId: i, connector: o }) => {
        var c, l;
        const a = y.state.activeChain === e;
        o != null &&
          o.provider &&
          (this.syncProvider({
            id: o.id,
            type: o.type,
            provider: o.provider,
            chainNamespace: e,
          }),
          this.syncConnectedWalletInfo(e)),
          a && i
            ? this.syncAccount({ address: r, chainId: i, chainNamespace: e })
            : a && (c = y.state.activeCaipNetwork) != null && c.id
            ? this.syncAccount({
                address: r,
                chainId:
                  (l = y.state.activeCaipNetwork) == null ? void 0 : l.id,
                chainNamespace: e,
              })
            : this.syncAccountInfo(r, i, e),
          M.addConnectedNamespace(e);
      });
  }
  async createUniversalProviderForAdapter(e) {
    var t, n, r;
    await this.getUniversalProvider(),
      this.universalProvider &&
        (await ((r =
          (n = (t = this.chainAdapters) == null ? void 0 : t[e]) == null
            ? void 0
            : n.setUniversalProvider) == null
          ? void 0
          : r.call(n, this.universalProvider)));
  }
  async syncExistingConnection() {
    await Promise.allSettled(
      this.chainNamespaces.map((e) => this.syncNamespaceConnection(e))
    );
  }
  async unSyncExistingConnection() {
    try {
      await Promise.allSettled(
        this.chainNamespaces.map((e) =>
          H.disconnect({ namespace: e, initialDisconnect: !0 })
        )
      );
    } catch (e) {
      console.error("Error disconnecting existing connections:", e);
    }
  }
  async syncNamespaceConnection(e) {
    try {
      e === S.CHAIN.EVM &&
        ne.isSafeApp() &&
        q.setConnectorId(S.CONNECTOR_ID.SAFE, e);
      const t = q.getConnectorId(e);
      switch ((this.setStatus("connecting", e), t)) {
        case S.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount();
          break;
        case S.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(e);
      }
    } catch (t) {
      console.warn("AppKit couldn't sync existing connection", t),
        this.setStatus("disconnected", e);
    }
  }
  onDisconnectNamespace(e) {
    const { chainNamespace: t, closeModal: n } = e || {};
    y.resetAccount(t),
      y.resetNetwork(t),
      q.removeConnectorId(t),
      M.removeConnectedNamespace(t),
      Le.resetChain(t),
      this.setUser(void 0, t),
      this.setStatus("disconnected", t),
      this.setConnectedWalletInfo(void 0, t),
      n !== !1 && Ne.close();
  }
  async syncAdapterConnections() {
    await Promise.allSettled(
      this.chainNamespaces.map((e) => {
        var r;
        const t = this.getCaipAddress(e),
          n = this.getCaipNetwork(e);
        return (r = this.chainAdapters) == null
          ? void 0
          : r[e].syncConnections({
              connectToFirstConnector: !t,
              caipNetwork: n,
              getConnectorStorageInfo(i) {
                const a = M.getConnections()[e] ?? [];
                return {
                  hasDisconnected: M.isConnectorDisconnected(i, e),
                  hasConnected: a.some((c) =>
                    At.isLowerCaseMatch(c.connectorId, i)
                  ),
                };
              },
            });
      })
    );
  }
  async syncAdapterConnection(e) {
    var a, c, l;
    const t = this.getAdapter(e),
      n = q.getConnectorId(e),
      r = this.getCaipNetwork(e),
      o = q.getConnectors(e).find((d) => d.id === n);
    try {
      if (!t || !o)
        throw new Error(`Adapter or connector not found for namespace ${e}`);
      if (!(r != null && r.id)) throw new Error("CaipNetwork not found");
      const d = await (t == null
        ? void 0
        : t.syncConnection({
            namespace: e,
            id: o.id,
            chainId: r.id,
            rpcUrl:
              (l =
                (c =
                  (a = r == null ? void 0 : r.rpcUrls) == null
                    ? void 0
                    : a.default) == null
                  ? void 0
                  : c.http) == null
                ? void 0
                : l[0],
          }));
      d
        ? (this.syncProvider({ ...d, chainNamespace: e }),
          await this.syncAccount({ ...d, chainNamespace: e }),
          this.setStatus("connected", e))
        : this.setStatus("disconnected", e);
    } catch {
      this.onDisconnectNamespace({ chainNamespace: e, closeModal: !1 });
    }
  }
  async syncWalletConnectAccount() {
    var n, r;
    const e = Object.keys(
        ((r = (n = this.universalProvider) == null ? void 0 : n.session) == null
          ? void 0
          : r.namespaces) || {}
      ),
      t = this.chainNamespaces.map(async (i) => {
        var d, u, p, w, g;
        const o = this.getAdapter(i);
        if (!o) return;
        const a =
            ((w =
              (p =
                (u =
                  (d = this.universalProvider) == null ? void 0 : d.session) ==
                null
                  ? void 0
                  : u.namespaces) == null
                ? void 0
                : p[i]) == null
              ? void 0
              : w.accounts) || [],
          c = (g = y.state.activeCaipNetwork) == null ? void 0 : g.id,
          l =
            a.find((m) => {
              const { chainId: f } = Mt.parseCaipAddress(m);
              return f === (c == null ? void 0 : c.toString());
            }) || a[0];
        if (l) {
          const m = Mt.validateCaipAddress(l),
            { chainId: f, address: E } = Mt.parseCaipAddress(m);
          if (
            (Le.setProviderId(i, zt.CONNECTOR_TYPE_WALLET_CONNECT),
            this.caipNetworks &&
              y.state.activeCaipNetwork &&
              o.namespace !== S.CHAIN.EVM)
          ) {
            const b = o.getWalletConnectProvider({
              caipNetworks: this.getCaipNetworks(),
              provider: this.universalProvider,
              activeCaipNetwork: y.state.activeCaipNetwork,
            });
            Le.setProvider(i, b);
          } else Le.setProvider(i, this.universalProvider);
          q.setConnectorId(S.CONNECTOR_ID.WALLET_CONNECT, i),
            M.addConnectedNamespace(i),
            await this.syncAccount({
              address: E,
              chainId: f,
              chainNamespace: i,
            });
        } else e.includes(i) && this.setStatus("disconnected", i);
        this.syncConnectedWalletInfo(i), await y.setApprovedCaipNetworksData(i);
      });
    await Promise.all(t);
  }
  syncProvider({ type: e, provider: t, id: n, chainNamespace: r }) {
    Le.setProviderId(r, e), Le.setProvider(r, t), q.setConnectorId(n, r);
  }
  async syncAccount(e) {
    var u, p;
    const t = e.chainNamespace === y.state.activeChain,
      n = y.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
      { address: r, chainId: i, chainNamespace: o } = e,
      { chainId: a } = M.getActiveNetworkProps(),
      c = i || a,
      l =
        ((u = y.state.activeCaipNetwork) == null ? void 0 : u.name) ===
        S.UNSUPPORTED_NETWORK_NAME,
      d = y.getNetworkProp("supportsAllNetworks", o);
    if ((this.setStatus("connected", o), !(l && !d) && c)) {
      let w = this.getCaipNetworks().find(
          (f) => f.id.toString() === c.toString()
        ),
        g = this.getCaipNetworks().find((f) => f.chainNamespace === o);
      if (!d && !w && !g) {
        const f = this.getApprovedCaipNetworkIds() || [],
          E = f.find((_) => {
            var N;
            return (
              ((N = Mt.parseCaipNetworkId(_)) == null ? void 0 : N.chainId) ===
              c.toString()
            );
          }),
          b = f.find((_) => {
            var N;
            return (
              ((N = Mt.parseCaipNetworkId(_)) == null
                ? void 0
                : N.chainNamespace) === o
            );
          });
        (w = this.getCaipNetworks().find((_) => _.caipNetworkId === E)),
          (g = this.getCaipNetworks().find(
            (_) =>
              _.caipNetworkId === b ||
              ("deprecatedCaipNetworkId" in _ &&
                _.deprecatedCaipNetworkId === b)
          ));
      }
      const m = w || g;
      (m == null ? void 0 : m.chainNamespace) === y.state.activeChain
        ? R.state.enableNetworkSwitch &&
          !R.state.allowUnsupportedChain &&
          ((p = y.state.activeCaipNetwork) == null ? void 0 : p.name) ===
            S.UNSUPPORTED_NETWORK_NAME
          ? y.showUnsupportedChainUI()
          : this.setCaipNetwork(m)
        : t || (n && this.setCaipNetworkOfNamespace(n, o)),
        this.syncConnectedWalletInfo(o),
        At.isLowerCaseMatch(r, se.state.address) ||
          this.syncAccountInfo(r, m == null ? void 0 : m.id, o),
        t
          ? await this.syncBalance({
              address: r,
              chainId: m == null ? void 0 : m.id,
              chainNamespace: o,
            })
          : await this.syncBalance({
              address: r,
              chainId: n == null ? void 0 : n.id,
              chainNamespace: o,
            });
    }
  }
  async syncAccountInfo(e, t, n) {
    const r = this.getCaipAddress(n),
      i = t || (r == null ? void 0 : r.split(":")[1]);
    if (!i) return;
    const o = `${n}:${i}:${e}`;
    this.setCaipAddress(o, n),
      await this.syncIdentity({ address: e, chainId: i, chainNamespace: n });
  }
  async syncReownName(e, t) {
    try {
      const n = await this.getReownName(e);
      if (n[0]) {
        const r = n[0];
        this.setProfileName(r.name, t);
      } else this.setProfileName(null, t);
    } catch {
      this.setProfileName(null, t);
    }
  }
  syncConnectedWalletInfo(e) {
    var r;
    const t = q.getConnectorId(e),
      n = Le.getProviderId(e);
    if (n === zt.CONNECTOR_TYPE_ANNOUNCED || n === zt.CONNECTOR_TYPE_INJECTED) {
      if (t) {
        const i = this.getConnectors().find((o) => {
          var d, u;
          const a = o.id === t,
            c = ((d = o.info) == null ? void 0 : d.rdns) === t,
            l =
              (u = o.connectors) == null
                ? void 0
                : u.some((p) => {
                    var w;
                    return (
                      p.id === t ||
                      ((w = p.info) == null ? void 0 : w.rdns) === t
                    );
                  });
          return a || c || !!l;
        });
        if (i) {
          const { info: o, name: a, imageUrl: c } = i,
            l = c || this.getConnectorImage(i);
          this.setConnectedWalletInfo({ name: a, icon: l, ...o }, e);
        }
      }
    } else if (n === zt.CONNECTOR_TYPE_WALLET_CONNECT) {
      const i = Le.getProvider(e);
      i != null &&
        i.session &&
        this.setConnectedWalletInfo(
          {
            ...i.session.peer.metadata,
            name: i.session.peer.metadata.name,
            icon: (r = i.session.peer.metadata.icons) == null ? void 0 : r[0],
          },
          e
        );
    } else if (t && t === S.CONNECTOR_ID.COINBASE) {
      const i = this.getConnectors().find(
        (o) => o.id === S.CONNECTOR_ID.COINBASE
      );
      this.setConnectedWalletInfo(
        { name: "Coinbase Wallet", icon: this.getConnectorImage(i) },
        e
      );
    }
  }
  async syncBalance(e) {
    !ip
      .getNetworksByNamespace(this.getCaipNetworks(), e.chainNamespace)
      .find((n) => {
        var r;
        return (
          n.id.toString() === ((r = e.chainId) == null ? void 0 : r.toString())
        );
      }) ||
      !e.chainId ||
      (await this.updateNativeBalance(e.address, e.chainId, e.chainNamespace));
  }
  async ready() {
    await this.readyPromise;
  }
  async updateNativeBalance(e, t, n) {
    const r = this.getAdapter(n),
      i = y.getCaipNetworkByNamespace(n, t);
    if (r) {
      const o = await r.getBalance({
        address: e,
        chainId: t,
        caipNetwork: i,
        tokens: this.options.tokens,
      });
      return this.setBalance(o.balance, o.symbol, n), o;
    }
  }
  async initializeUniversalAdapter() {
    var n, r, i, o, a, c, l, d, u, p;
    const e = wN.createLogger((w, ...g) => {
        w && this.handleAlertError(w), console.error(...g);
      }),
      t = {
        projectId: (n = this.options) == null ? void 0 : n.projectId,
        metadata: {
          name:
            (r = this.options) != null && r.metadata
              ? (i = this.options) == null
                ? void 0
                : i.metadata.name
              : "",
          description:
            (o = this.options) != null && o.metadata
              ? (a = this.options) == null
                ? void 0
                : a.metadata.description
              : "",
          url:
            (c = this.options) != null && c.metadata
              ? (l = this.options) == null
                ? void 0
                : l.metadata.url
              : "",
          icons:
            (d = this.options) != null && d.metadata
              ? (u = this.options) == null
                ? void 0
                : u.metadata.icons
              : [""],
        },
        logger: e,
      };
    R.setManualWCControl(!!((p = this.options) != null && p.manualWCControl)),
      (this.universalProvider =
        this.options.universalProvider ?? (await fN.init(t))),
      R.state.enableReconnect === !1 &&
        this.universalProvider.session &&
        (await this.universalProvider.disconnect()),
      this.listenWalletConnect();
  }
  listenWalletConnect() {
    this.universalProvider &&
      this.chainNamespaces.forEach((e) => {
        Ls.listenWcProvider({
          universalProvider: this.universalProvider,
          namespace: e,
          onDisplayUri: (t) => {
            H.setUri(t);
          },
          onConnect: () => {
            H.finalizeWcConnection();
          },
          onDisconnect: () => {
            y.state.noAdapters && this.resetAccount(e), H.resetWcConnection();
          },
          onChainChanged: (t) => {
            const n = y.state.activeChain,
              r =
                n &&
                q.state.activeConnectorIds[n] === S.CONNECTOR_ID.WALLET_CONNECT;
            if (n === e && (y.state.noAdapters || r)) {
              const i = this.getCaipNetworks().find(
                  (a) =>
                    a.id.toString() === t.toString() ||
                    a.caipNetworkId.toString() === t.toString()
                ),
                o = this.getCaipNetwork();
              if (!i) {
                this.setUnsupportedNetwork(t);
                return;
              }
              (o == null ? void 0 : o.id.toString()) !==
                (i == null ? void 0 : i.id.toString()) &&
                (o == null ? void 0 : o.chainNamespace) ===
                  (i == null ? void 0 : i.chainNamespace) &&
                this.setCaipNetwork(i);
            }
          },
          onAccountsChanged: (t) => {
            const n = y.state.activeChain,
              r =
                n &&
                q.state.activeConnectorIds[n] === S.CONNECTOR_ID.WALLET_CONNECT;
            if (n === e && (y.state.noAdapters || r) && t.length > 0) {
              const i = t[0];
              this.syncAccount({
                address: i.address,
                chainId: i.chainId,
                chainNamespace: i.chainNamespace,
              });
            }
          },
        });
      });
  }
  createUniversalProvider() {
    var e;
    return (
      !this.universalProviderInitPromise &&
        ne.isClient() &&
        (e = this.options) != null &&
        e.projectId &&
        (this.universalProviderInitPromise = this.initializeUniversalAdapter()),
      this.universalProviderInitPromise
    );
  }
  async getUniversalProvider() {
    if (!this.universalProvider)
      try {
        await this.createUniversalProvider();
      } catch (e) {
        Ue.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: e instanceof Error ? e.message : "Unknown",
            uncaught: !1,
          },
        }),
          console.error(
            "AppKit:getUniversalProvider - Cannot create provider",
            e
          );
      }
    return this.universalProvider;
  }
  handleAlertError(e) {
    const t = Object.entries(vt.UniversalProviderErrors).find(
        ([, { message: a }]) => e.message.includes(a)
      ),
      [n, r] = t ?? [],
      { message: i, alertErrorKey: o } = r ?? {};
    if (n && i && !this.reportedAlertErrors[n]) {
      const a = vt.ALERT_ERRORS[o];
      a && (tt.open(a, "error"), (this.reportedAlertErrors[n] = !0));
    }
  }
  getAdapter(e) {
    var t;
    if (e) return (t = this.chainAdapters) == null ? void 0 : t[e];
  }
  createAdapter(e) {
    var r;
    if (!e) return;
    const t = e.namespace;
    if (!t) return;
    this.createClients();
    const n = e;
    (n.namespace = t),
      n.construct({
        namespace: t,
        projectId: (r = this.options) == null ? void 0 : r.projectId,
        networks: this.getCaipNetworks(),
      }),
      this.chainNamespaces.includes(t) || this.chainNamespaces.push(t),
      this.chainAdapters && (this.chainAdapters[t] = n);
  }
  async open(e) {
    if (
      (await this.injectModalUi(),
      e != null && e.uri && H.setUri(e.uri),
      e != null && e.arguments)
    )
      switch (e == null ? void 0 : e.view) {
        case "Swap":
          return Ne.open({ ...e, data: { swap: e.arguments } });
      }
    return Ne.open(e);
  }
  async close() {
    await this.injectModalUi(), Ne.close();
  }
  setLoading(e, t) {
    Ne.setLoading(e, t);
  }
  async disconnect(e) {
    await H.disconnect({ namespace: e });
  }
  getSIWX() {
    return R.state.siwx;
  }
  getError() {
    return "";
  }
  getChainId() {
    var e;
    return (e = y.state.activeCaipNetwork) == null ? void 0 : e.id;
  }
  async switchNetwork(e) {
    const t = this.getCaipNetworks().find((n) => n.id === e.id);
    if (!t) {
      tt.open(vt.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await y.switchActiveNetwork(t);
  }
  getWalletProvider() {
    return y.state.activeChain ? Le.state.providers[y.state.activeChain] : null;
  }
  getWalletProviderType() {
    return Le.getProviderId(y.state.activeChain);
  }
  subscribeProviders(e) {
    return Le.subscribeProviders(e);
  }
  getThemeMode() {
    return $t.state.themeMode;
  }
  getThemeVariables() {
    return $t.state.themeVariables;
  }
  setThemeMode(e) {
    $t.setThemeMode(e), Dg($t.state.themeMode);
  }
  setTermsConditionsUrl(e) {
    R.setTermsConditionsUrl(e);
  }
  setPrivacyPolicyUrl(e) {
    R.setPrivacyPolicyUrl(e);
  }
  setThemeVariables(e) {
    $t.setThemeVariables(e), Cx($t.state.themeVariables);
  }
  subscribeTheme(e) {
    return $t.subscribe(e);
  }
  subscribeConnections(e) {
    return this.remoteFeatures.multiWallet
      ? H.subscribe(e)
      : (tt.open(
          S.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
          "info"
        ),
        () => {});
  }
  getWalletInfo(e) {
    return e
      ? y.getAccountProp("connectedWalletInfo", e)
      : se.state.connectedWalletInfo;
  }
  getAccount(e) {
    const t = e || y.state.activeChain,
      n = q.getAuthConnector(t),
      r = y.getAccountData(t),
      i = M.getConnectedConnectorId(y.state.activeChain),
      o = H.getConnections(t);
    if (!t) throw new Error("AppKit:getAccount - namespace is required");
    const a = o.flatMap((c) =>
      c.accounts.map(({ address: l, type: d }) =>
        ne.createAccount(t, l, d || "eoa")
      )
    );
    if (r)
      return {
        allAccounts: a,
        caipAddress: r.caipAddress,
        address: ne.getPlainAddress(r.caipAddress),
        isConnected: !!r.caipAddress,
        status: r.status,
        embeddedWalletInfo:
          n && i === S.CONNECTOR_ID.AUTH
            ? {
                user: r.user
                  ? { ...r.user, username: M.getConnectedSocialUsername() }
                  : void 0,
                authProvider: r.socialProvider || "email",
                accountType: Cs(t),
                isSmartAccountDeployed: !!r.smartAccountDeployed,
              }
            : void 0,
      };
  }
  subscribeAccount(e, t) {
    const n = () => {
      const r = this.getAccount(t);
      r && e(r);
    };
    t ? y.subscribeChainProp("accountState", n, t) : y.subscribe(n),
      q.subscribe(n);
  }
  subscribeNetwork(e) {
    return y.subscribe(({ activeCaipNetwork: t }) => {
      e({
        caipNetwork: t,
        chainId: t == null ? void 0 : t.id,
        caipNetworkId: t == null ? void 0 : t.caipNetworkId,
      });
    });
  }
  subscribeWalletInfo(e, t) {
    return t
      ? se.subscribeKey("connectedWalletInfo", e, t)
      : se.subscribeKey("connectedWalletInfo", e);
  }
  subscribeShouldUpdateToAddress(e) {
    se.subscribeKey("shouldUpdateToAddress", e);
  }
  subscribeCaipNetworkChange(e) {
    y.subscribeKey("activeCaipNetwork", e);
  }
  getState() {
    return $s.state;
  }
  getRemoteFeatures() {
    return R.state.remoteFeatures;
  }
  subscribeState(e) {
    return $s.subscribe(e);
  }
  subscribeRemoteFeatures(e) {
    return R.subscribeKey("remoteFeatures", e);
  }
  showErrorMessage(e) {
    ks.showError(e);
  }
  showSuccessMessage(e) {
    ks.showSuccess(e);
  }
  getEvent() {
    return { ...Ue.state };
  }
  subscribeEvents(e) {
    return Ue.subscribe(e);
  }
  replace(e) {
    de.replace(e);
  }
  redirect(e) {
    de.push(e);
  }
  popTransactionStack(e) {
    de.popTransactionStack(e);
  }
  isOpen() {
    return Ne.state.open;
  }
  isTransactionStackEmpty() {
    return de.state.transactionStack.length === 0;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(e) {
    R.setFeatures(e);
  }
  updateRemoteFeatures(e) {
    R.setRemoteFeatures(e);
  }
  updateOptions(e) {
    const n = { ...(R.state || {}), ...e };
    R.setOptions(n);
  }
  setConnectMethodsOrder(e) {
    R.setConnectMethodsOrder(e);
  }
  setWalletFeaturesOrder(e) {
    R.setWalletFeaturesOrder(e);
  }
  setCollapseWallets(e) {
    R.setCollapseWallets(e);
  }
  setSocialsOrder(e) {
    R.setSocialsOrder(e);
  }
  getConnectMethodsOrder() {
    return Pl.getConnectOrderMethod(R.state.features, q.getConnectors());
  }
  addNetwork(e, t) {
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`);
    const n = this.extendCaipNetwork(t, this.options);
    this.getCaipNetworks().find((r) => r.id === n.id) || y.addNetwork(n);
  }
  removeNetwork(e, t) {
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`);
    this.getCaipNetworks().find((r) => r.id === t) && y.removeNetwork(e, t);
  }
}
let tp = !1;
class Bg extends xx {
  async onAuthProviderConnected(e) {
    e.message &&
      e.signature &&
      e.siwxMessage &&
      (await ms.addEmbeddedWalletSession(
        {
          chainId: e.siwxMessage.chainId,
          accountAddress: e.address,
          notBefore: e.siwxMessage.notBefore,
          statement: e.siwxMessage.statement,
          resources: e.siwxMessage.resources,
          requestId: e.siwxMessage.requestId,
          issuedAt: e.siwxMessage.issuedAt,
          domain: e.siwxMessage.domain,
          uri: e.siwxMessage.uri,
          version: e.siwxMessage.version,
          nonce: e.siwxMessage.nonce,
        },
        e.message,
        e.signature
      ));
    const t = y.state.activeChain;
    if (!t)
      throw new Error("AppKit:onAuthProviderConnected - namespace is required");
    const n =
        t === S.CHAIN.EVM
          ? `eip155:${e.chainId}:${e.address}`
          : `${e.chainId}:${e.address}`,
      r = R.state.defaultAccountTypes[t],
      i = Cs(t),
      o = e.preferredAccountType || i || r;
    At.isLowerCaseMatch(e.address, se.state.address) ||
      this.syncIdentity({
        address: e.address,
        chainId: e.chainId,
        chainNamespace: t,
      }),
      this.setCaipAddress(n, t);
    const { signature: a, siwxMessage: c, message: l, ...d } = e;
    this.setUser({ ...(se.state.user || {}), ...d }, t),
      this.setSmartAccountDeployed(!!e.smartAccountDeployed, t),
      this.setPreferredAccountType(o, t),
      this.setLoading(!1, t);
  }
  setupAuthConnectorListeners(e) {
    e.onRpcRequest((t) => {
      Vt.checkIfRequestExists(t)
        ? Vt.checkIfRequestIsSafe(t) || this.handleUnsafeRPCRequest()
        : (this.open(),
          console.error(nt.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
            method: t.method,
          }),
          setTimeout(() => {
            this.showErrorMessage(nt.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
          }, 300),
          e.rejectRpcRequests());
    }),
      e.onRpcError(() => {
        this.isOpen() &&
          (this.isTransactionStackEmpty()
            ? this.close()
            : this.popTransactionStack("error"));
      }),
      e.onRpcSuccess((t, n) => {
        const r = Vt.checkIfRequestIsSafe(n),
          i = se.state.address,
          o = y.state.activeCaipNetwork;
        r ||
          (i &&
            o != null &&
            o.id &&
            this.updateNativeBalance(i, o.id, o.chainNamespace),
          this.isTransactionStackEmpty()
            ? this.close()
            : this.popTransactionStack("success"));
      }),
      e.onNotConnected(() => {
        const t = y.state.activeChain;
        if (!t)
          throw new Error("AppKit:onNotConnected - namespace is required");
        q.getConnectorId(t) === S.CONNECTOR_ID.AUTH &&
          (this.setCaipAddress(void 0, t), this.setLoading(!1, t));
      }),
      e.onConnect(this.onAuthProviderConnected.bind(this)),
      e.onSocialConnected(this.onAuthProviderConnected.bind(this)),
      e.onSetPreferredAccount(({ address: t, type: n }) => {
        const r = y.state.activeChain;
        if (!r)
          throw new Error(
            "AppKit:onSetPreferredAccount - namespace is required"
          );
        t && this.setPreferredAccountType(n, r);
      });
  }
  async syncAuthConnectorTheme(e) {
    if (!e) return;
    const t = $t.getSnapshot(),
      n = R.getSnapshot();
    await Promise.all([
      e.syncDappData({
        metadata: n.metadata,
        sdkVersion: n.sdkVersion,
        projectId: n.projectId,
        sdkType: n.sdkType,
      }),
      e.syncTheme({
        themeMode: t.themeMode,
        themeVariables: t.themeVariables,
        w3mThemeVariables: Zs(t.themeVariables, t.themeMode),
      }),
    ]);
  }
  async syncAuthConnector(e, t) {
    var l, d, u, p;
    const n = S.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(t),
      r = t === y.state.activeChain;
    if (!n) return;
    this.setLoading(!0, t);
    const i = e.getLoginEmailUsed();
    this.setLoading(i, t), i && this.setStatus("connecting", t);
    const o = e.getEmail(),
      a = e.getUsername();
    this.setUser(
      {
        ...(((l = se.state) == null ? void 0 : l.user) || {}),
        username: a,
        email: o,
      },
      t
    ),
      this.setupAuthConnectorListeners(e);
    const { isConnected: c } = await e.isConnected();
    if ((await this.syncAuthConnectorTheme(e), t && n && r)) {
      const w = await e.getSmartAccountEnabledNetworks();
      y.setSmartAccountEnabledNetworks(
        (w == null ? void 0 : w.smartAccountEnabledNetworks) || [],
        t
      ),
        c && (d = this.connectionControllerClient) != null && d.connectExternal
          ? (await ((p = this.connectionControllerClient) == null
              ? void 0
              : p.connectExternal({
                  id: S.CONNECTOR_ID.AUTH,
                  info: { name: S.CONNECTOR_ID.AUTH },
                  type: zt.CONNECTOR_TYPE_AUTH,
                  provider: e,
                  chainId:
                    (u = y.state.activeCaipNetwork) == null ? void 0 : u.id,
                  chain: t,
                })),
            this.setStatus("connected", t))
          : q.getConnectorId(t) === S.CONNECTOR_ID.AUTH &&
            (this.setStatus("disconnected", t), M.removeConnectedNamespace(t));
    }
    this.setLoading(!1, t);
  }
  async checkExistingTelegramSocialConnection(e) {
    var t;
    try {
      if (!ne.isTelegram()) return;
      const n = M.getTelegramSocialProvider();
      if (!n || !ne.isClient()) return;
      const i = new URL(window.location.href).searchParams.get("result_uri");
      if (!i) return;
      se.setSocialProvider(n, e),
        await ((t = this.authProvider) == null ? void 0 : t.init());
      const o = q.getAuthConnector();
      n &&
        o &&
        (this.setLoading(!0, e),
        await H.connectExternal(
          { id: o.id, type: o.type, socialUri: i },
          o.chain
        ),
        M.setConnectedSocialProvider(n),
        M.removeTelegramSocialProvider(),
        Ue.sendEvent({
          type: "track",
          event: "SOCIAL_LOGIN_SUCCESS",
          properties: { provider: n },
        }));
    } catch (n) {
      this.setLoading(!1, e),
        console.error("checkExistingSTelegramocialConnection error", n);
    }
    try {
      const n = new URL(window.location.href);
      n.searchParams.delete("result_uri"),
        window.history.replaceState({}, document.title, n.toString());
    } catch (n) {
      console.error("tma social login failed", n);
    }
  }
  createAuthProvider(e) {
    var l, d, u, p;
    if (!S.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e)) return;
    const n = (l = this.remoteFeatures) == null ? void 0 : l.email,
      r =
        Array.isArray((d = this.remoteFeatures) == null ? void 0 : d.socials) &&
        this.remoteFeatures.socials.length > 0,
      i = n || r,
      a = At.getActiveNamespaceConnectedToAuth() || e;
    !this.authProvider &&
      (u = this.options) != null &&
      u.projectId &&
      i &&
      ((this.authProvider = zi.getInstance({
        projectId: this.options.projectId,
        enableLogger: this.options.enableAuthLogger,
        chainId:
          (p = this.getCaipNetwork(a)) == null ? void 0 : p.caipNetworkId,
        abortController: vt.EmbeddedWalletAbortController,
        onTimeout: (w) => {
          w === "iframe_load_failed"
            ? tt.open(vt.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error")
            : w === "iframe_request_timeout"
            ? tt.open(vt.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error")
            : w === "unverified_domain" &&
              tt.open(vt.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
        },
        getActiveCaipNetwork: (w) => y.getActiveCaipNetwork(w),
      })),
      $s.subscribeOpen((w) => {
        var g;
        !w &&
          this.isTransactionStackEmpty() &&
          ((g = this.authProvider) == null || g.rejectRpcRequests());
      }));
    const c = e === y.state.activeChain && R.state.enableReconnect;
    R.state.enableReconnect === !1
      ? this.syncAuthConnectorTheme(this.authProvider)
      : this.authProvider &&
        c &&
        (this.syncAuthConnector(this.authProvider, e),
        this.checkExistingTelegramSocialConnection(e));
  }
  createAuthProviderForAdapter(e) {
    var t, n, r;
    this.createAuthProvider(e),
      this.authProvider &&
        ((r =
          (n = (t = this.chainAdapters) == null ? void 0 : t[e]) == null
            ? void 0
            : n.setAuthProvider) == null ||
          r.call(n, this.authProvider));
  }
  initControllers(e) {
    super.initControllers(e),
      this.options.excludeWalletIds &&
        re.initializeExcludedWallets({ ids: this.options.excludeWalletIds });
  }
  async switchCaipNetwork(e) {
    var o, a;
    if (!e) return;
    const t = y.state.activeChain,
      n = e.chainNamespace,
      r = this.getAddressByChainNamespace(n);
    if (n === t && r) {
      const c = this.getAdapter(n),
        l = Le.getProvider(n),
        d = Le.getProviderId(n);
      await (c == null
        ? void 0
        : c.switchNetwork({ caipNetwork: e, provider: l, providerType: d })),
        this.setCaipNetwork(e);
    } else {
      const l = Le.getProviderId(t) === zt.CONNECTOR_TYPE_AUTH,
        d = Le.getProviderId(n),
        u = d === zt.CONNECTOR_TYPE_AUTH,
        p = S.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(n);
      if (!n)
        throw new Error(
          "AppKit:switchCaipNetwork - networkNamespace is required"
        );
      if (((l && d === void 0) || u) && p)
        try {
          if (((y.state.activeChain = e.chainNamespace), r)) {
            const w = this.getAdapter(n);
            await (w == null
              ? void 0
              : w.switchNetwork({
                  caipNetwork: e,
                  provider: this.authProvider,
                  providerType: d,
                }));
          } else
            await ((a =
              (o = this.connectionControllerClient) == null
                ? void 0
                : o.connectExternal) == null
              ? void 0
              : a.call(o, {
                  id: S.CONNECTOR_ID.AUTH,
                  provider: this.authProvider,
                  chain: n,
                  chainId: e.id,
                  type: zt.CONNECTOR_TYPE_AUTH,
                  caipNetwork: e,
                }));
          this.setCaipNetwork(e);
        } catch {
          const g = this.getAdapter(n);
          await (g == null
            ? void 0
            : g.switchNetwork({
                caipNetwork: e,
                provider: this.authProvider,
                providerType: d,
              }));
        }
      else if (d === zt.CONNECTOR_TYPE_WALLET_CONNECT) {
        if (!y.state.noAdapters) {
          const w = this.getAdapter(n),
            g = Le.getProvider(n),
            m = Le.getProviderId(n);
          await (w == null
            ? void 0
            : w.switchNetwork({
                caipNetwork: e,
                provider: g,
                providerType: m,
              }));
        }
        this.setCaipNetwork(e), this.syncWalletConnectAccount();
      } else
        this.setCaipNetwork(e),
          r &&
            this.syncAccount({ address: r, chainId: e.id, chainNamespace: n });
    }
  }
  async initialize(e) {
    var t;
    await super.initialize(e),
      (t = this.chainNamespaces) == null ||
        t.forEach((n) => {
          this.createAuthProviderForAdapter(n);
        }),
      await this.injectModalUi(),
      $s.set({ initialized: !0 });
  }
  async syncIdentity({ address: e, chainId: t, chainNamespace: n }) {
    var o;
    const r = `${n}:${t}`,
      i =
        (o = this.caipNetworks) == null
          ? void 0
          : o.find((a) => a.caipNetworkId === r);
    if (n !== S.CHAIN.EVM || (i != null && i.testnet)) {
      this.setProfileName(null, n), this.setProfileImage(null, n);
      return;
    }
    try {
      const { name: a, avatar: c } = await this.fetchIdentity({
        address: e,
        caipNetworkId: r,
      });
      this.setProfileName(a, n), this.setProfileImage(c, n);
    } catch {
      await this.syncReownName(e, n), t !== 1 && this.setProfileImage(null, n);
    }
  }
  syncConnectedWalletInfo(e) {
    const t = Le.getProviderId(e);
    if (t === zt.CONNECTOR_TYPE_AUTH) {
      const n = this.authProvider;
      if (n) {
        const r = M.getConnectedSocialProvider() ?? "email",
          i = n.getEmail() ?? n.getUsername();
        this.setConnectedWalletInfo({ name: t, identifier: i, social: r }, e);
      }
    } else super.syncConnectedWalletInfo(e);
  }
  async injectModalUi() {
    if (ne.isClient() && !tp)
      try {
        const e = { ...Pe.DEFAULT_FEATURES, ...this.options.features },
          t = this.remoteFeatures;
        if (
          (await this.loadModalComponents(e, t),
          ne.isClient() && !document.querySelector("w3m-modal"))
        ) {
          const r = document.createElement("w3m-modal");
          !R.state.disableAppend &&
            !R.state.enableEmbedded &&
            document.body.insertAdjacentElement("beforeend", r);
        }
        tp = !0;
      } catch (e) {
        console.error("Error injecting modal UI:", e);
      }
  }
  async loadModalComponents(e, t) {
    if (!ne.isClient()) return;
    const n = [];
    (t.email || (t.socials && t.socials.length > 0)) &&
      n.push(
        ts(
          () => import("./embedded-wallet-Bw6GWc0g.js"),
          __vite__mapDeps([3, 4, 1, 2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])
        )
      ),
      t.email &&
        n.push(
          ts(
            () => import("./email-ClmOx2jD.js"),
            __vite__mapDeps([15, 4, 1, 2, 14, 8, 13, 7, 12, 16, 9])
          )
        ),
      t.socials &&
        n.push(
          ts(
            () => import("./socials-CJiCiaPs.js"),
            __vite__mapDeps([
              17, 4, 1, 2, 18, 7, 19, 20, 13, 21, 12, 8, 14, 22, 6, 23, 24,
            ])
          )
        ),
      t.swaps &&
        t.swaps.length > 0 &&
        n.push(
          ts(
            () => import("./swaps-BVCMXjeT.js"),
            __vite__mapDeps([25, 4, 1, 2, 12, 8, 26, 27, 28, 6, 13, 24, 9, 7])
          )
        ),
      e.send &&
        n.push(
          ts(
            () => import("./send-BFRertPl.js"),
            __vite__mapDeps([
              29, 4, 1, 2, 12, 8, 13, 7, 19, 14, 28, 6, 9, 30, 31,
            ])
          )
        ),
      e.receive &&
        n.push(
          ts(
            () => import("./receive-CXGPcPXa.js"),
            __vite__mapDeps([32, 4, 1, 2, 33, 6, 22, 23])
          )
        ),
      t.onramp &&
        t.onramp.length > 0 &&
        n.push(
          ts(
            () => import("./onramp-o2jWTin6.js"),
            __vite__mapDeps([
              34, 4, 1, 2, 35, 24, 13, 6, 8, 36, 18, 7, 19, 37, 14, 12, 21, 9,
            ])
          )
        ),
      t.activity &&
        n.push(
          ts(
            () => import("./transactions-aaTVJ1mw.js"),
            __vite__mapDeps([38, 4, 1, 2, 39, 35, 24, 13, 14, 6])
          )
        ),
      e.pay &&
        n.push(
          ts(
            () => import("./index-DTp-ME2r.js"),
            __vite__mapDeps([40, 4, 1, 2, 12, 8, 41, 6, 13, 10, 36, 31, 21])
          )
        ),
      await Promise.all([
        ...n,
        ts(
          () => import("./index-mokCsY3_.js"),
          __vite__mapDeps([
            42, 4, 1, 2, 6, 8, 30, 13, 43, 27, 10, 36, 12, 11, 41, 39, 35, 24,
            14, 26, 31, 7, 9, 16, 18, 19, 20, 5, 21, 33, 22, 23, 37,
          ])
        ),
        ts(
          () => import("./w3m-modal-DeD7NBtf.js"),
          __vite__mapDeps([44, 4, 1, 2, 10, 6, 13, 11, 8, 27, 43])
        ),
      ]);
  }
}
const Px = "1.7.13";
function Ox(s) {
  return new Bg({
    ...s,
    sdkVersion: ne.generateSdkVersion(s.adapters ?? [], "html", Px),
  });
}
const CP = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      AccountController: se,
      AppKit: Bg,
      CoreHelperUtil: ne,
      DEFAULT_METHODS: Lg,
      WcConstantsUtil: Br,
      WcHelpersUtil: Ls,
      createAppKit: Ox,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
export {
  dw as $,
  se as A,
  ae as B,
  q as C,
  up as D,
  Di as E,
  Ct as F,
  ft as G,
  re as H,
  Vc as I,
  xi as J,
  gs as K,
  Pm as L,
  Ne as M,
  Nm as N,
  R as O,
  Mt as P,
  Le as Q,
  de as R,
  ks as S,
  $t as T,
  ra as U,
  da as V,
  nt as W,
  At as X,
  _P as Y,
  Pl as Z,
  kr as _,
  aa as a,
  ms as a0,
  wP as a1,
  at as a2,
  yP as a3,
  _g as a4,
  Ol as a5,
  bo as a6,
  cy as a7,
  Gx as a8,
  Ud as a9,
  _p as aa,
  eo as ab,
  sy as ac,
  bp as ad,
  ly as ae,
  Yx as af,
  Kx as ag,
  ua as ah,
  Jx as ai,
  Zx as aj,
  CP as ak,
  Pe as b,
  S as c,
  ne as d,
  Ue as e,
  Cs as f,
  Zs as g,
  y as h,
  qr as i,
  bP as j,
  Vt as k,
  H as l,
  zt as m,
  BR as n,
  tt as o,
  FR as p,
  M as q,
  EP as r,
  vt as s,
  xe as t,
  lp as u,
  qe as v,
  Zt as w,
  mP as x,
  iw as y,
  jl as z,
};
